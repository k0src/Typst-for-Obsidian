/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/js-untar/build/dist/untar.js
var require_untar = __commonJS({
  "node_modules/js-untar/build/dist/untar.js"(exports, module2) {
    !function(e, r) {
      "function" == typeof define && define.amd ? define([], r) : "object" == typeof exports ? module2.exports = r() : e.untar = r();
    }(exports, function() {
      "use strict";
      function e(e2) {
        function r2(e3) {
          for (var r3 = 0, n3 = t3.length; r3 < n3; ++r3)
            t3[r3](e3);
          a2.push(e3);
        }
        if ("function" != typeof Promise)
          throw new Error("Promise implementation not available in this environment.");
        var t3 = [], a2 = [], n2 = new Promise(function(t4, a3) {
          e2(t4, a3, r2);
        });
        n2.progress = function(e3) {
          if ("function" != typeof e3)
            throw new Error("cb is not a function.");
          for (var r3 = 0, i3 = a2.length; r3 < i3; ++r3)
            e3(a2[r3]);
          return t3.push(e3), n2;
        };
        var i2 = n2.then;
        return n2.then = function(e3, r3, t4) {
          return i2.call(n2, e3, r3), void 0 !== t4 && n2.progress(t4), n2;
        }, n2;
      }
      function r(r2) {
        if (!(r2 instanceof ArrayBuffer))
          throw new TypeError("arrayBuffer is not an instance of ArrayBuffer.");
        if (!n.Worker)
          throw new Error("Worker implementation is not available in this environment.");
        return new e(function(e2, n2, i2) {
          var o2 = new Worker(a), s = [];
          o2.onerror = function(e3) {
            n2(e3);
          }, o2.onmessage = function(r3) {
            switch (r3 = r3.data, r3.type) {
              case "log":
                console[r3.data.level]("Worker: " + r3.data.msg);
                break;
              case "extract":
                var a2 = t2(r3.data);
                s.push(a2), i2(a2);
                break;
              case "complete":
                o2.terminate(), e2(s);
                break;
              case "error":
                o2.terminate(), n2(new Error(r3.data.message));
                break;
              default:
                o2.terminate(), n2(new Error("Unknown message from worker: " + r3.type));
            }
          }, o2.postMessage({ type: "extract", buffer: r2 }, [r2]);
        });
      }
      function t2(e2) {
        return Object.defineProperties(e2, o), e2;
      }
      var a, n = window || this, i = n.URL || n.webkitURL, o = { blob: { get: function() {
        return this._blob || (this._blob = new Blob([this.buffer]));
      } }, getBlobUrl: { value: function() {
        return this._blobUrl || (this._blobUrl = i.createObjectURL(this.blob));
      } }, readAsString: { value: function() {
        for (var e2 = this.buffer, r2 = e2.byteLength, t3 = 1, a2 = new DataView(e2), n2 = [], i2 = 0; i2 < r2; ++i2) {
          var o2 = a2.getUint8(i2 * t3, true);
          n2.push(o2);
        }
        return this._string = String.fromCharCode.apply(null, n2);
      } }, readAsJSON: { value: function() {
        return JSON.parse(this.readAsString());
      } } };
      return a = (window || this).URL.createObjectURL(new Blob(['"use strict";function UntarWorker(){}function decodeUTF8(e){for(var r="",t=0;t<e.length;){var a=e[t++];if(a>127){if(a>191&&a<224){if(t>=e.length)throw"UTF-8 decode: incomplete 2-byte sequence";a=(31&a)<<6|63&e[t]}else if(a>223&&a<240){if(t+1>=e.length)throw"UTF-8 decode: incomplete 3-byte sequence";a=(15&a)<<12|(63&e[t])<<6|63&e[++t]}else{if(!(a>239&&a<248))throw"UTF-8 decode: unknown multibyte start 0x"+a.toString(16)+" at index "+(t-1);if(t+2>=e.length)throw"UTF-8 decode: incomplete 4-byte sequence";a=(7&a)<<18|(63&e[t])<<12|(63&e[++t])<<6|63&e[++t]}++t}if(a<=65535)r+=String.fromCharCode(a);else{if(!(a<=1114111))throw"UTF-8 decode: code point 0x"+a.toString(16)+" exceeds UTF-16 reach";a-=65536,r+=String.fromCharCode(a>>10|55296),r+=String.fromCharCode(1023&a|56320)}}return r}function PaxHeader(e){this._fields=e}function TarFile(){}function UntarStream(e){this._bufferView=new DataView(e),this._position=0}function UntarFileStream(e){this._stream=new UntarStream(e),this._globalPaxHeader=null}if(UntarWorker.prototype={onmessage:function(e){try{if("extract"!==e.data.type)throw new Error("Unknown message type: "+e.data.type);this.untarBuffer(e.data.buffer)}catch(r){this.postError(r)}},postError:function(e){this.postMessage({type:"error",data:{message:e.message}})},postLog:function(e,r){this.postMessage({type:"log",data:{level:e,msg:r}})},untarBuffer:function(e){try{for(var r=new UntarFileStream(e);r.hasNext();){var t=r.next();this.postMessage({type:"extract",data:t},[t.buffer])}this.postMessage({type:"complete"})}catch(a){this.postError(a)}},postMessage:function(e,r){self.postMessage(e,r)}},"undefined"!=typeof self){var worker=new UntarWorker;self.onmessage=function(e){worker.onmessage(e)}}PaxHeader.parse=function(e){for(var r=new Uint8Array(e),t=[];r.length>0;){var a=parseInt(decodeUTF8(r.subarray(0,r.indexOf(32)))),n=decodeUTF8(r.subarray(0,a)),i=n.match(/^\\d+ ([^=]+)=(.*)\\n$/);if(null===i)throw new Error("Invalid PAX header data format.");var s=i[1],o=i[2];0===o.length?o=null:null!==o.match(/^\\d+$/)&&(o=parseInt(o));var f={name:s,value:o};t.push(f),r=r.subarray(a)}return new PaxHeader(t)},PaxHeader.prototype={applyHeader:function(e){this._fields.forEach(function(r){var t=r.name,a=r.value;"path"===t?(t="name",void 0!==e.prefix&&delete e.prefix):"linkpath"===t&&(t="linkname"),null===a?delete e[t]:e[t]=a})}},UntarStream.prototype={readString:function(e){for(var r=1,t=e*r,a=[],n=0;n<e;++n){var i=this._bufferView.getUint8(this.position()+n*r,!0);if(0===i)break;a.push(i)}return this.seek(t),String.fromCharCode.apply(null,a)},readBuffer:function(e){var r;if("function"==typeof ArrayBuffer.prototype.slice)r=this._bufferView.buffer.slice(this.position(),this.position()+e);else{r=new ArrayBuffer(e);var t=new Uint8Array(r),a=new Uint8Array(this._bufferView.buffer,this.position(),e);t.set(a)}return this.seek(e),r},seek:function(e){this._position+=e},peekUint32:function(){return this._bufferView.getUint32(this.position(),!0)},position:function(e){return void 0===e?this._position:void(this._position=e)},size:function(){return this._bufferView.byteLength}},UntarFileStream.prototype={hasNext:function(){return this._stream.position()+4<this._stream.size()&&0!==this._stream.peekUint32()},next:function(){return this._readNextFile()},_readNextFile:function(){var e=this._stream,r=new TarFile,t=!1,a=null,n=e.position(),i=n+512;switch(r.name=e.readString(100),r.mode=e.readString(8),r.uid=parseInt(e.readString(8)),r.gid=parseInt(e.readString(8)),r.size=parseInt(e.readString(12),8),r.mtime=parseInt(e.readString(12),8),r.checksum=parseInt(e.readString(8)),r.type=e.readString(1),r.linkname=e.readString(100),r.ustarFormat=e.readString(6),r.ustarFormat.indexOf("ustar")>-1&&(r.version=e.readString(2),r.uname=e.readString(32),r.gname=e.readString(32),r.devmajor=parseInt(e.readString(8)),r.devminor=parseInt(e.readString(8)),r.namePrefix=e.readString(155),r.namePrefix.length>0&&(r.name=r.namePrefix+"/"+r.name)),e.position(i),r.type){case"0":case"":r.buffer=e.readBuffer(r.size);break;case"1":break;case"2":break;case"3":break;case"4":break;case"5":break;case"6":break;case"7":break;case"g":t=!0,this._globalPaxHeader=PaxHeader.parse(e.readBuffer(r.size));break;case"x":t=!0,a=PaxHeader.parse(e.readBuffer(r.size))}void 0===r.buffer&&(r.buffer=new ArrayBuffer(0));var s=i+r.size;return r.size%512!==0&&(s+=512-r.size%512),e.position(s),t&&(r=this._readNextFile()),null!==this._globalPaxHeader&&this._globalPaxHeader.applyHeader(r),null!==a&&a.applyHeader(r),r}};'])), r;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TypstForObsidian
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/TypstView.ts
var import_obsidian = require("obsidian");

// src/TypstEditor.ts
var import_view2 = require("@codemirror/view");
var import_state = require("@codemirror/state");

// node_modules/@codemirror/theme-one-dark/dist/index.js
var import_view = require("@codemirror/view");
var import_language = require("@codemirror/language");
var import_highlight = require("@lezer/highlight");
var chalky = "#e5c07b";
var coral = "#e06c75";
var cyan = "#56b6c2";
var invalid = "#ffffff";
var ivory = "#abb2bf";
var stone = "#7d8799";
var malibu = "#61afef";
var sage = "#98c379";
var whiskey = "#d19a66";
var violet = "#c678dd";
var darkBackground = "#21252b";
var highlightBackground = "#2c313a";
var background = "#282c34";
var tooltipBackground = "#353a42";
var selection = "#3E4451";
var cursor = "#528bff";
var oneDarkTheme = /* @__PURE__ */ import_view.EditorView.theme({
  "&": {
    color: ivory,
    backgroundColor: background
  },
  ".cm-content": {
    caretColor: cursor
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
  ".cm-panels": { backgroundColor: darkBackground, color: ivory },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: background,
    color: stone,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: highlightBackground
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: tooltipBackground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: tooltipBackground,
    borderBottomColor: tooltipBackground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: highlightBackground,
      color: ivory
    }
  }
}, { dark: true });
var oneDarkHighlightStyle = /* @__PURE__ */ import_language.HighlightStyle.define([
  {
    tag: import_highlight.tags.keyword,
    color: violet
  },
  {
    tag: [import_highlight.tags.name, import_highlight.tags.deleted, import_highlight.tags.character, import_highlight.tags.propertyName, import_highlight.tags.macroName],
    color: coral
  },
  {
    tag: [/* @__PURE__ */ import_highlight.tags.function(import_highlight.tags.variableName), import_highlight.tags.labelName],
    color: malibu
  },
  {
    tag: [import_highlight.tags.color, /* @__PURE__ */ import_highlight.tags.constant(import_highlight.tags.name), /* @__PURE__ */ import_highlight.tags.standard(import_highlight.tags.name)],
    color: whiskey
  },
  {
    tag: [/* @__PURE__ */ import_highlight.tags.definition(import_highlight.tags.name), import_highlight.tags.separator],
    color: ivory
  },
  {
    tag: [import_highlight.tags.typeName, import_highlight.tags.className, import_highlight.tags.number, import_highlight.tags.changed, import_highlight.tags.annotation, import_highlight.tags.modifier, import_highlight.tags.self, import_highlight.tags.namespace],
    color: chalky
  },
  {
    tag: [import_highlight.tags.operator, import_highlight.tags.operatorKeyword, import_highlight.tags.url, import_highlight.tags.escape, import_highlight.tags.regexp, import_highlight.tags.link, /* @__PURE__ */ import_highlight.tags.special(import_highlight.tags.string)],
    color: cyan
  },
  {
    tag: [import_highlight.tags.meta, import_highlight.tags.comment],
    color: stone
  },
  {
    tag: import_highlight.tags.strong,
    fontWeight: "bold"
  },
  {
    tag: import_highlight.tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: import_highlight.tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: import_highlight.tags.link,
    color: stone,
    textDecoration: "underline"
  },
  {
    tag: import_highlight.tags.heading,
    fontWeight: "bold",
    color: coral
  },
  {
    tag: [import_highlight.tags.atom, import_highlight.tags.bool, /* @__PURE__ */ import_highlight.tags.special(import_highlight.tags.variableName)],
    color: whiskey
  },
  {
    tag: [import_highlight.tags.processingInstruction, import_highlight.tags.string, import_highlight.tags.inserted],
    color: sage
  },
  {
    tag: import_highlight.tags.invalid,
    color: invalid
  }
]);
var oneDark = [oneDarkTheme, /* @__PURE__ */ (0, import_language.syntaxHighlighting)(oneDarkHighlightStyle)];

// src/TypstEditor.ts
var import_commands = require("@codemirror/commands");
var import_language3 = require("@codemirror/language");
var import_autocomplete = require("@codemirror/autocomplete");

// src/grammar/typst.ts
var import_language2 = require("@codemirror/language");

// src/grammar/typst-parser.js
var import_lr = require("@lezer/lr");
var spec_identifier = {
  __proto__: null,
  true: 14,
  false: 14,
  none: 18,
  auto: 22,
  not: 46,
  in: 66,
  and: 70,
  or: 72,
  if: 90,
  else: 92,
  for: 96,
  while: 100,
  let: 104,
  set: 108,
  show: 112,
  import: 116,
  include: 120,
  context: 124,
  break: 128,
  continue: 132,
  return: 136
};
var parser = import_lr.LRParser.deserialize({
  version: 14,
  states: "-hQ`QPOOO!ZQPOOOOQO'#Cb'#CbOOQO'#Cd'#CdOOQO'#Cf'#CfOOQO'#Ch'#ChO#|QPO'#ERO!ZQPO'#CqO!ZQPO'#CrO$vQPO'#ESOOQO'#ES'#ESO'rQPO'#DTO!ZQPO'#DuO'yQPO'#DxOOQO'#ER'#EROOQO'#Dz'#DzQ`QPOOQ!{QPOOO(QQPO'#ClOOQO,59T,59TO(XQPO,59YO!ZQPO,59bO!ZQPO,59bO!ZQPO,59bO!ZQPO,59bO!ZQPO,59bO!ZQPO,59bO!ZQPO,59bO(^QPO,59]O(eQPO,59^O!ZQPO,59mO+^QPO,59oO,WQPO'#DXOOQO,59o,59oO-TQPO,5:aOOQO,5:d,5:dO-[QPO,5:dOOQO-E7x-E7xO-cQPO'#EUO-mQPO,59WOOQO'#Cp'#CpOOQO1G.t1G.tO0hQPO1G.|O0oQPO1G.|O3iQPO1G.|O3sQPO1G.|O6pQPO1G.|O6zQPO1G.|O8SQPO1G.|OOQO1G.w1G.wO:RQPO1G/XO;}QPO'#DsOOQO'#EW'#EWOOQO'#D|'#D|O=aQPO,59sOOQO,59s,59sO!ZQPO'#DYO!UQPO'#D]O!ZQPO'#D_O!UQPO'#DaO!ZQPO'#DcO!ZQPO'#DeO>^QPO'#DgO>cQPO'#DiO!ZQPO'#DkOOQO'#Dm'#DmOOQO'#Do'#DoO!ZQPO'#DqOOQO1G/{1G/{OOQO1G0O1G0OO!ZQPO'#D{O>hQPO,5:pOOQO1G.r1G.rOOQO-E7z-E7zOOQO1G/_1G/_O>pQPO,59tO>wQPO,59wO>pQPO,59yO>|QPO,59{O?RQPO,59}O@eQPO,5:POOQO,5:R,5:ROOQO,5:T,5:TOAwQPO,5:VOCZQPO,5:]ODmQPO,5:gOOQO-E7y-E7yODwQPO1G/`O!ZQPO1G/cOOQO1G/e1G/eO!ZQPO1G/gOFeQPO7+$zO>pQPO7+$}OFjQPO7+%ROOQO<<Hf<<HfOOQO<<Hi<<Hi",
  stateData: "HT~O!sOS!tOSPOSQOS~OSYOTYOVQOXROZSO_VOgWOhWOiWOxZO!h[O!k]O!wTO~OSYOTYOVQOXROZSO_VOgWOhWOiWO!wTO~O_bOcdOhgOigOkeOlfOmhOnhOohOphOqhOriOsjOtkO!yiO~OS!uXT!uXV!uXX!uXZ!uXg!uXx!uX!h!uX!k!uX!q!uX!w!uX!j!uX~P!{OvnOS!vXT!vXV!vXX!vXZ!vX_!vXc!vXg!vXh!vXi!vXk!vXl!vXm!vXn!vXo!vXp!vXq!vXr!vXs!vXt!vXx!vX!h!vX!k!vX!q!vX!w!vX!y!vX^!vX!j!vXa!vXy!vX}!vX!Q!vX!S!vX!U!vX!W!vX!Y!vX![!vX!^!vX!`!vX!b!vX!d!vX!f!vXz!vX~OzpO~P!ZO!jsO~P`O^!xP~P!ZO!wxO~O^!RO~P!{O_bOcdOSfaTfaVfaXfaZfagfahfaifakfalfamfanfaofapfaqfarfasfatfaxfa!hfa!kfa!qfa!wfa!yfa^fa!jfaafayfa}fa!Qfa!Sfa!Ufa!Wfa!Yfa![fa!^fa!`fa!bfa!dfa!ffazfa~OSwaTwaVwaXwaZwagwaxwa!hwa!kwa!qwa!wwa!jwa~P!{Oy!XO}!YO!Q!ZO!S![O!U!]O!W!^O!Y!_O![!`O!^!aO!`!bO!b!cO!d!dO!f!eO~P!ZO!h!fO~P!{O!j!gO~P`Oa!hO^!xX~P!{O^!jO~O_bOcdOSjiTjiVjiXjiZjigjihjiijiljimjinjiojipjiqjirjisjitjixji!hji!kji!qji!wji!yji^ji!jjiajiyji}ji!Qji!Sji!Uji!Wji!Yji![ji!^ji!`ji!bji!dji!fjizji~Okji~P-rOkeO~P-rO_bOcdOkeOlfOSjiTjiVjiXjiZjigjimjinjiojipjiqjirjisjitjixji!hji!kji!qji!wji!yji^ji!jjiajiyji}ji!Qji!Sji!Uji!Wji!Yji![ji!^ji!`ji!bji!dji!fjizji~Ohjiiji~P0vOhgOigO~P0vO_bOcdOhgOigOkeOlfOmhOnhOohOphOqhOSjiTjiVjiXjiZjigjisjitjixji!hji!kji!qji!wji^ji!jjiajiyji}ji!Qji!Sji!Uji!Wji!Yji![ji!^ji!`ji!bji!dji!fjizji~Orji!yji~P3}OriO!yiO~P3}O_bOcdOhgOigOkeOlfOmhOnhOohOphOqhOriOsjO!yiO~OSjiTjiVjiXjiZjigjitjixji!hji!kji!qji!wji^ji!jjiajiyji}ji!Qji!Sji!Uji!Wji!Yji![ji!^ji!`ji!bji!dji!fjizji~P7UOSuiTuiVuiXuiZuiguixui!hui!kui!qui!wui^ui!juiauiyui}ui!Qui!Sui!Uui!Wui!Yui![ui!^ui!`ui!bui!dui!fuizui~P!{OS!gXT!gXV!gXX!gXZ!gXg!gXy!gX}!gX!Q!gX!S!gX!U!gX!W!gX!Y!gX![!gX!^!gX!`!gX!b!gX!d!gX!f!gX!w!gX~P!{Oy!lO}!YO!Q!ZO!S![O!U!]O!W!^O!Y!_O![!`O!^!aO!`!bO!b!cO!d!dO!f!eO~P!ZOT!sO~OT!tO~Oa!hO^!xa~OzpO~P!{Oq!zO~Ov!|O~OS!VaT!VaV!VaX!VaZ!Vag!Vay!Va}!Va!Q!Va!S!Va!U!Va!W!Va!Y!Va![!Va!^!Va!`!Va!b!Va!d!Va!f!Va!w!Va~P!{OS!XaT!XaV!XaX!XaZ!Xag!Xay!Xa}!Xa!Q!Xa!S!Xa!U!Xa!W!Xa!Y!Xa![!Xa!^!Xa!`!Xa!b!Xa!d!Xa!f!Xa!w!Xa~P!{OS!_aT!_aV!_aX!_aZ!_ag!_ay!_a}!_a!Q!_a!S!_a!U!_a!W!_a!Y!_a![!_a!^!_a!`!_a!b!_a!d!_a!f!_a!w!_a~P!{OS!eaT!eaV!eaX!eaZ!eag!eay!ea}!ea!Q!ea!S!ea!U!ea!W!ea!Y!ea![!ea!^!ea!`!ea!b!ea!d!ea!f!ea!w!ea~P!{O^!oaa!oa~P!{O!O!}OS|iT|iV|iX|iZ|i_|ig|ih|ii|iy|i}|i!Q|i!S|i!U|i!W|i!Y|i![|i!^|i!`|i!b|i!d|i!f|i!w|i~OzpO~OS!TqT!TqV!TqX!TqZ!Tqg!Tqy!Tq}!Tq!Q!Tq!S!Tq!U!Tq!W!Tq!Y!Tq![!Tq!^!Tq!`!Tq!b!Tq!d!Tq!f!Tq!w!Tq~P!{OSc!w!s!t!w~",
  goto: "(T!{PPPPPP!|P!|P!|P#m!|PP$dP!|P%P!|!|PPP!|PPPPPPPPPP!|P%SPPP%Y%iPP%iP%iP%iP%iP%iP%iP%iP%iP%iP%iP%iP%iP%SPP%SP%m%w%}PPPP&T&ZP'|P(P!]YOPVWZ[]`befghijknpt!W!Y![!^!_!b!e!h!z!|![XOPVWZ[]`befghijknpt!W!Y![!^!_!b!e!h!z!|Q!n!ZR!p!]!TcUalmorvz{|}!O!P!Q!S!T!m!o!q!r!u!v!w#O#PRydX^O]`tQqZQ!y!mQ!{!oQ#Q!}R#R#OT!Up!WQ`OQt]Tu`tQ!ivR!x!iQ!WpR!k!WX_O]`tWUO]`tQaPQlVQmWQoZQr[QvbQzeQ{fQ|gQ}hQ!OiQ!PjQ!QkQ!SnS!Tp!WQ!m!YQ!o![Q!q!^Q!r!_Q!u!bQ!v!eQ!w!hQ#O!zR#P!|RwbT!Vp!W",
  nodeNames: "\u26A0 LineComment BlockComment Document Number String Boolean BooleanLiteral None NoneLiteral Auto AutoLiteral VariableName FunctionCall ) ( ArgList , MemberExpression . PropertyName ParenthesizedExpression UnaryExpression not + - BinaryExpression ^ % < <= > >= in == and or AssignmentExpression = CodeBlock # } { Block IfStatement if else ForStatement for WhileStatement while LetStatement let SetStatement set ShowStatement show ImportStatement import IncludeStatement include ContextStatement context BreakStatement break ContinueStatement continue ReturnStatement return ExpressionStatement $ MathBlock ] [ ContentBlock SingleExpression",
  maxTerm: 88,
  nodeProps: [
    ["openedBy", 14, "(", 41, "{", 72, "["],
    ["closedBy", 15, ")", 42, "}", 73, "]"]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "4U~R!QXY$XYZ$y]^$ypq$Xqr%Ors%Zst&}tu'Suv'Xwx'^xy({yz)Q{|)V|})[}!O)a!O!P)f!P!Q-T!Q![.|!^!_/w!_!`0U!`!a0c!c!}0p!}#O1b#P#Q1g#Q#R1l#R#S0p#T#o0p#o#p1q#q#r1v$f$g$X$g#BY0p#BY#BZ1{#BZ$IS0p$IS$I_1{$I_$I|0p$I|$I}3h$I}$JO3h$JO$JT0p$JT$JU1{$JU$KV0p$KV$KW1{$KW&FU0p&FU&FV1{&FV;'S0p;'S;=`1[<%l?HT0p?HT?HU1{?HUO0p~$^X!s~XY$Xpq$X$f$g$X#BY#BZ$X$IS$I_$X$JT$JU$X$KV$KW$X&FU&FV$X?HT?HU$X~%OO!t~~%RP!_!`%U~%ZO!y~~%^WOY%ZZr%Zrs%vs#O%Z#O#P%{#P;'S%Z;'S;=`&w<%lO%Z~%{OT~~&ORO;'S%Z;'S;=`&X;=`O%Z~&[XOY%ZZr%Zrs%vs#O%Z#O#P%{#P;'S%Z;'S;=`&w;=`<%l%Z<%lO%Z~&zP;=`<%l%Z~'SOx~~'XO!h~~'^Ol~~'aWOY'^Zw'^wx%vx#O'^#O#P'y#P;'S'^;'S;=`(u<%lO'^~'|RO;'S'^;'S;=`(V;=`O'^~(YXOY'^Zw'^wx%vx#O'^#O#P'y#P;'S'^;'S;=`(u;=`<%l'^<%lO'^~(xP;=`<%l'^~)QO_~~)VO^~~)[Oh~~)aOa~~)fOi~~)kPc~!Q![)n~)sZS~uv*f!Q![)n!g!h*k#V#W+r#W#X+x#X#Y,t#Y#Z,U#]#^,[#a#b+r#d#e,b#f#g,h~*kOS~~*nR{|*w}!O*w!Q![*}~*zP!Q![*}~+SYS~uv*f!Q![*}#V#W+r#W#X+x#X#Y+r#Y#Z,U#]#^,[#a#b+r#d#e,b#f#g,h~+uP#a#b*f~+{P#X#Y,O~,RP#Z#[*f~,XP#f#g*f~,_P#b#c*f~,eP#h#i*f~,kP#T#U,n~,qP#W#X*f~,wS{|*w}!O*w!Q![*}#a#b*f~-WQz{-^!P!Q.e~-aTOz-^z{-p{;'S-^;'S;=`._<%lO-^~-sVOz-^z{-p{!P-^!P!Q.Y!Q;'S-^;'S;=`._<%lO-^~._OQ~~.bP;=`<%l-^~.jSP~OY.eZ;'S.e;'S;=`.v<%lO.e~.yP;=`<%l.e~/R[S~uv*f!O!P)n!Q![.|!g!h*k#V#W+r#W#X+x#X#Y,t#Y#Z,U#]#^,[#a#b+r#d#e,b#f#g,h~/|Pm~!_!`0P~0UOn~~0ZPv~!_!`0^~0cOr~~0hPo~!_!`0k~0pOp~~0uV!w~!Q![0p!c!}0p#R#S0p#T#o0p$g;'S0p;'S;=`1[<%lO0p~1_P;=`<%l0p~1gO!k~~1lO!j~~1qOk~~1vOz~~1{Oy~~2Sf!w~!s~XY$Xpq$X!Q![0p!c!}0p#R#S0p#T#o0p$f$g$X$g#BY0p#BY#BZ1{#BZ$IS0p$IS$I_1{$I_$JT0p$JT$JU1{$JU$KV0p$KV$KW1{$KW&FU0p&FU&FV1{&FV;'S0p;'S;=`1[<%l?HT0p?HT?HU1{?HUO0p~3oV!w~!t~!Q![0p!c!}0p#R#S0p#T#o0p$g;'S0p;'S;=`1[<%lO0p",
  tokenizers: [0],
  topRules: { Document: [0, 3], SingleExpression: [1, 75] },
  specialized: [{ term: 85, get: (value) => spec_identifier[value] || -1 }],
  tokenPrec: 1792
});

// src/grammar/typst-highlight.ts
var import_highlight2 = require("@lezer/highlight");
var typstHighlight = (0, import_highlight2.styleTags)({
  // Keywords
  if: import_highlight2.tags.keyword,
  else: import_highlight2.tags.keyword,
  for: import_highlight2.tags.keyword,
  in: import_highlight2.tags.keyword,
  while: import_highlight2.tags.keyword,
  break: import_highlight2.tags.keyword,
  continue: import_highlight2.tags.keyword,
  return: import_highlight2.tags.keyword,
  let: import_highlight2.tags.keyword,
  set: import_highlight2.tags.keyword,
  show: import_highlight2.tags.keyword,
  import: import_highlight2.tags.keyword,
  include: import_highlight2.tags.keyword,
  context: import_highlight2.tags.keyword,
  not: import_highlight2.tags.keyword,
  and: import_highlight2.tags.keyword,
  or: import_highlight2.tags.keyword,
  // Literals
  BooleanLiteral: import_highlight2.tags.bool,
  NoneLiteral: import_highlight2.tags.null,
  AutoLiteral: import_highlight2.tags.atom,
  Number: import_highlight2.tags.number,
  String: import_highlight2.tags.string,
  // Identifiers
  VariableName: import_highlight2.tags.variableName,
  PropertyName: import_highlight2.tags.propertyName,
  // Operators
  "=": import_highlight2.tags.operator,
  "==": import_highlight2.tags.operator,
  "<": import_highlight2.tags.operator,
  "<=": import_highlight2.tags.operator,
  ">": import_highlight2.tags.operator,
  ">=": import_highlight2.tags.operator,
  "+": import_highlight2.tags.operator,
  "-": import_highlight2.tags.operator,
  "%": import_highlight2.tags.operator,
  "^": import_highlight2.tags.operator,
  // Punctuation
  "(": import_highlight2.tags.paren,
  ")": import_highlight2.tags.paren,
  "[": import_highlight2.tags.paren,
  "]": import_highlight2.tags.paren,
  "{": import_highlight2.tags.paren,
  "}": import_highlight2.tags.paren,
  ".": import_highlight2.tags.punctuation,
  ",": import_highlight2.tags.punctuation,
  ";": import_highlight2.tags.punctuation,
  ":": import_highlight2.tags.punctuation,
  // Special characters
  "#": import_highlight2.tags.special(import_highlight2.tags.punctuation),
  $: import_highlight2.tags.special(import_highlight2.tags.punctuation),
  "=>": import_highlight2.tags.operator,
  "..": import_highlight2.tags.operator,
  // Comments
  LineComment: import_highlight2.tags.lineComment,
  BlockComment: import_highlight2.tags.blockComment,
  // Blocks
  Block: import_highlight2.tags.brace,
  ContentBlock: import_highlight2.tags.squareBracket,
  CodeBlock: import_highlight2.tags.special(import_highlight2.tags.brace),
  MathBlock: import_highlight2.tags.special(import_highlight2.tags.squareBracket),
  // Statements
  IfStatement: import_highlight2.tags.controlKeyword,
  ForStatement: import_highlight2.tags.controlKeyword,
  WhileStatement: import_highlight2.tags.controlKeyword,
  BreakStatement: import_highlight2.tags.controlKeyword,
  ContinueStatement: import_highlight2.tags.controlKeyword,
  ReturnStatement: import_highlight2.tags.controlKeyword,
  // Declarations
  LetStatement: import_highlight2.tags.definitionKeyword,
  SetStatement: import_highlight2.tags.keyword,
  ShowStatement: import_highlight2.tags.keyword,
  ImportStatement: import_highlight2.tags.moduleKeyword,
  IncludeStatement: import_highlight2.tags.moduleKeyword,
  ContextStatement: import_highlight2.tags.keyword,
  // Expressions
  FunctionCall: import_highlight2.tags.function(import_highlight2.tags.variableName),
  MemberExpression: import_highlight2.tags.propertyName,
  UnaryExpression: import_highlight2.tags.operator,
  BinaryExpression: import_highlight2.tags.operator,
  AssignmentExpression: import_highlight2.tags.operator
});

// src/grammar/typst.ts
var typstLanguage = import_language2.LRLanguage.define({
  parser: parser.configure({
    props: [
      import_language2.indentNodeProp.add({
        Block: (0, import_language2.delimitedIndent)({ closing: "}", align: false }),
        ContentBlock: (0, import_language2.delimitedIndent)({ closing: "]", align: false }),
        ArgList: (0, import_language2.delimitedIndent)({ closing: ")", align: false }),
        "IfStatement ForStatement WhileStatement": (context) => context.column(context.node.from) + context.unit
      }),
      import_language2.foldNodeProp.add({
        Block: import_language2.foldInside,
        ContentBlock: import_language2.foldInside,
        ArgList: import_language2.foldInside,
        "IfStatement ForStatement WhileStatement": import_language2.foldInside
      }),
      typstHighlight
    ]
  }),
  languageData: {
    name: "typst",
    extensions: [".typ"],
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*[}\]\)]$/,
    closeBrackets: { brackets: ["(", "[", "{", '"', "'"] }
  }
});
function typst() {
  return new import_language2.LanguageSupport(typstLanguage);
}

// src/TypstEditor.ts
var import_search = require("@codemirror/search");
var typstKeywords = [
  "abs",
  "acos",
  "align",
  "and",
  "angle",
  "array",
  "as",
  "asin",
  "assert",
  "atan",
  "atan2",
  "attach",
  "auto",
  "bibliography",
  "binom",
  "block",
  "bool",
  "box",
  "break",
  "bytes",
  "cbrt",
  "ceil",
  "cite",
  "circle",
  "colbreak",
  "columns",
  "content",
  "context",
  "continue",
  "cos",
  "cosh",
  "datetime",
  "dictionary",
  "dif",
  "Dif",
  "document",
  "duration",
  "ellipse",
  "else",
  "emph",
  "emoji",
  "enum",
  "equation",
  "eval",
  "exp",
  "false",
  "figure",
  "float",
  "floor",
  "for",
  "footnote",
  "frac",
  "fraction",
  "function",
  "gcd",
  "grid",
  "h",
  "hcf",
  "heading",
  "highlight",
  "hypot",
  "if",
  "image",
  "import",
  "in",
  "include",
  "int",
  "label",
  "lcm",
  "length",
  "let",
  "line",
  "link",
  "list",
  "log",
  "lorem",
  "lower",
  "mat",
  "math",
  "max",
  "measure",
  "min",
  "mod",
  "module",
  "move",
  "none",
  "not",
  "numbering",
  "or",
  "outline",
  "overline",
  "pad",
  "page",
  "pagebreak",
  "panic",
  "par",
  "parbreak",
  "path",
  "place",
  "plugin",
  "polygon",
  "pow",
  "quote",
  "ratio",
  "raw",
  "rect",
  "ref",
  "regex",
  "repeat",
  "repr",
  "return",
  "root",
  "rotate",
  "round",
  "scale",
  "selector",
  "set",
  "show",
  "sin",
  "sinh",
  "smallcaps",
  "smartquote",
  "sqrt",
  "square",
  "stack",
  "str",
  "strike",
  "strong",
  "sub",
  "super",
  "sym",
  "symbol",
  "sys",
  "table",
  "tan",
  "tanh",
  "terms",
  "text",
  "true",
  "trunc",
  "type",
  "underline",
  "upper",
  "v",
  "vec",
  "while",
  "with",
  "where"
];
function typstCompletions(context) {
  const word = context.matchBefore(/\w*/);
  if (!word || word.from === word.to && !context.explicit) {
    return null;
  }
  return {
    from: word.from,
    options: typstKeywords.map((keyword) => ({
      label: keyword,
      type: "keyword"
    }))
  };
}
var TypstEditor = class {
  constructor(container, app, onContentChange) {
    this.editorView = null;
    this.content = "";
    this.container = container;
    this.app = app;
    this.onContentChange = onContentChange;
  }
  initialize(initialContent = "") {
    this.content = initialContent;
    this.createEditor();
  }
  createEditor() {
    this.container.empty();
    const editorContainer = this.container.createDiv("typst-editor-container");
    const isDarkTheme = document.body.classList.contains("theme-dark");
    const extensions = [
      (0, import_view2.lineNumbers)(),
      (0, import_view2.dropCursor)(),
      (0, import_view2.rectangularSelection)(),
      (0, import_view2.highlightActiveLine)(),
      (0, import_commands.history)(),
      import_view2.EditorView.lineWrapping,
      // Language features
      typst(),
      (0, import_language3.bracketMatching)(),
      (0, import_autocomplete.closeBrackets)(),
      (0, import_search.highlightSelectionMatches)(),
      // Autocomplete
      (0, import_autocomplete.autocompletion)({
        override: [typstCompletions],
        activateOnTyping: true,
        maxRenderedOptions: 20
      }),
      // Multiple selections
      import_state.EditorState.allowMultipleSelections.of(true),
      // Key bindings
      import_view2.keymap.of([
        ...import_autocomplete.completionKeymap,
        import_commands.indentWithTab,
        ...import_commands.historyKeymap,
        ...import_commands.defaultKeymap,
        ...import_search.searchKeymap
      ]),
      // Theme
      ...isDarkTheme ? [oneDark] : [],
      // Update content on changes
      import_view2.EditorView.updateListener.of((update) => {
        if (update.docChanged) {
          this.content = update.state.doc.toString();
          if (this.onContentChange) {
            this.onContentChange(this.content);
          }
        }
      })
    ];
    this.editorView = new import_view2.EditorView({
      state: import_state.EditorState.create({
        doc: this.content,
        extensions
      }),
      parent: editorContainer
    });
  }
  getContent() {
    return this.editorView ? this.editorView.state.doc.toString() : this.content;
  }
  setContent(content) {
    if (this.editorView) {
      const transaction = this.editorView.state.update({
        changes: {
          from: 0,
          to: this.editorView.state.doc.length,
          insert: content
        }
      });
      this.editorView.dispatch(transaction);
    }
    this.content = content;
  }
  focus() {
    var _a3;
    (_a3 = this.editorView) == null ? void 0 : _a3.focus();
  }
  getEditorState() {
    if (!this.editorView)
      return null;
    return {
      cursorPos: this.editorView.state.selection.main.head,
      scrollTop: this.editorView.scrollDOM.scrollTop
    };
  }
  restoreEditorState(state) {
    if (!this.editorView)
      return;
    this.editorView.dispatch({
      selection: { anchor: state.cursorPos },
      scrollIntoView: false
      // We'll handle scroll manually
    });
    this.editorView.scrollDOM.scrollTop = state.scrollTop;
  }
  undo() {
    if (this.editorView) {
      return (0, import_commands.undo)(this.editorView);
    }
    return false;
  }
  redo() {
    if (this.editorView) {
      return (0, import_commands.redo)(this.editorView);
    }
    return false;
  }
  destroy() {
    if (this.editorView) {
      this.editorView.destroy();
      this.editorView = null;
    }
  }
};

// node_modules/pdfjs-dist/build/pdf.mjs
var import_meta = {};
var __webpack_require__ = {};
(() => {
  __webpack_require__.d = (exports, definition) => {
    for (var key in definition) {
      if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
        Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
      }
    }
  };
})();
(() => {
  __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();
var isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
var FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
var LINE_FACTOR = 1.35;
var LINE_DESCENT_FACTOR = 0.35;
var BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
var RenderingIntentFlag = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_STORAGE: 32,
  ANNOTATIONS_DISABLE: 64,
  IS_EDITING: 128,
  OPLIST: 256
};
var AnnotationMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
};
var AnnotationEditorPrefix = "pdfjs_internal_editor_";
var AnnotationEditorType = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15,
  POPUP: 16,
  SIGNATURE: 101,
  COMMENT: 102
};
var AnnotationEditorParamsType = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_THICKNESS: 32,
  HIGHLIGHT_FREE: 33,
  HIGHLIGHT_SHOW_ALL: 34,
  DRAW_STEP: 41
};
var PermissionFlag = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
};
var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
var util_ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
var AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
var AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
var VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
var OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91,
  setStrokeTransparent: 92,
  setFillTransparent: 93,
  rawFillPath: 94
};
var DrawOPS = {
  moveTo: 0,
  lineTo: 1,
  curveTo: 2,
  closePath: 3
};
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
var verbosity = VerbosityLevel.WARNINGS;
function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}
function getVerbosityLevel() {
  return verbosity;
}
function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.log(`Info: ${msg}`);
  }
}
function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log(`Warning: ${msg}`);
  }
}
function unreachable(msg) {
  throw new Error(msg);
}
function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}
function _isValidProtocol(url) {
  switch (url == null ? void 0 : url.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;
    default:
      return false;
  }
}
function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
  if (!url) {
    return null;
  }
  if (options && typeof url === "string") {
    if (options.addDefaultProtocol && url.startsWith("www.")) {
      const dots = url.match(/\./g);
      if ((dots == null ? void 0 : dots.length) >= 2) {
        url = `http://${url}`;
      }
    }
    if (options.tryConvertEncoding) {
      try {
        url = stringToUTF8String(url);
      } catch (e) {
      }
    }
  }
  const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
  return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;
}
function updateUrlHash(url, hash, allowRel = false) {
  const res = URL.parse(url);
  if (res) {
    res.hash = hash;
    return res.href;
  }
  if (allowRel && createValidAbsoluteUrl(url, "http://example.com")) {
    return url.split("#", 1)[0] + `${hash ? `#${hash}` : ""}`;
  }
  return "";
}
function shadow(obj, prop, value, nonSerializable = false) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: !nonSerializable,
    configurable: true,
    writable: false
  });
  return value;
}
var BaseException = function BaseExceptionClosure() {
  function BaseException2(message, name) {
    this.message = message;
    this.name = name;
  }
  BaseException2.prototype = new Error();
  BaseException2.constructor = BaseException2;
  return BaseException2;
}();
var PasswordException = class extends BaseException {
  constructor(msg, code) {
    super(msg, "PasswordException");
    this.code = code;
  }
};
var UnknownErrorException = class extends BaseException {
  constructor(msg, details) {
    super(msg, "UnknownErrorException");
    this.details = details;
  }
};
var InvalidPDFException = class extends BaseException {
  constructor(msg) {
    super(msg, "InvalidPDFException");
  }
};
var ResponseException = class extends BaseException {
  constructor(msg, status, missing) {
    super(msg, "ResponseException");
    this.status = status;
    this.missing = missing;
  }
};
var FormatError = class extends BaseException {
  constructor(msg) {
    super(msg, "FormatError");
  }
};
var AbortException = class extends BaseException {
  constructor(msg) {
    super(msg, "AbortException");
  }
};
function bytesToString(bytes) {
  if (typeof bytes !== "object" || (bytes == null ? void 0 : bytes.length) === void 0) {
    unreachable("Invalid argument for bytesToString");
  }
  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  const strBuf = [];
  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join("");
}
function stringToBytes(str) {
  if (typeof str !== "string") {
    unreachable("Invalid argument for stringToBytes");
  }
  const length = str.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 255;
  }
  return bytes;
}
function string32(value) {
  return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
}
function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}
function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch (e) {
    return false;
  }
}
var util_FeatureTest = class {
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", isLittleEndian());
  }
  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", isEvalSupported());
  }
  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
  }
  static get isImageDecoderSupported() {
    return shadow(this, "isImageDecoderSupported", typeof ImageDecoder !== "undefined");
  }
  static get platform() {
    const {
      platform,
      userAgent
    } = navigator;
    return shadow(this, "platform", {
      isAndroid: userAgent.includes("Android"),
      isLinux: platform.includes("Linux"),
      isMac: platform.includes("Mac"),
      isWindows: platform.includes("Win"),
      isFirefox: userAgent.includes("Firefox")
    });
  }
  static get isCSSRoundSupported() {
    var _a3, _b2;
    return shadow(this, "isCSSRoundSupported", (_b2 = (_a3 = globalThis.CSS) == null ? void 0 : _a3.supports) == null ? void 0 : _b2.call(_a3, "width: round(1.5px, 1px)"));
  }
};
var hexNumbers = Array.from(Array(256).keys(), (n) => n.toString(16).padStart(2, "0"));
var _getExtremumOnCurve, getExtremumOnCurve_fn, _getExtremum, getExtremum_fn;
var Util = class {
  static makeHexColor(r, g, b) {
    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
  }
  static domMatrixToTransform(dm) {
    return [dm.a, dm.b, dm.c, dm.d, dm.e, dm.f];
  }
  static scaleMinMax(transform, minMax) {
    let temp;
    if (transform[0]) {
      if (transform[0] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[2];
        minMax[2] = temp;
      }
      minMax[0] *= transform[0];
      minMax[2] *= transform[0];
      if (transform[3] < 0) {
        temp = minMax[1];
        minMax[1] = minMax[3];
        minMax[3] = temp;
      }
      minMax[1] *= transform[3];
      minMax[3] *= transform[3];
    } else {
      temp = minMax[0];
      minMax[0] = minMax[1];
      minMax[1] = temp;
      temp = minMax[2];
      minMax[2] = minMax[3];
      minMax[3] = temp;
      if (transform[1] < 0) {
        temp = minMax[1];
        minMax[1] = minMax[3];
        minMax[3] = temp;
      }
      minMax[1] *= transform[1];
      minMax[3] *= transform[1];
      if (transform[2] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[2];
        minMax[2] = temp;
      }
      minMax[0] *= transform[2];
      minMax[2] *= transform[2];
    }
    minMax[0] += transform[4];
    minMax[1] += transform[5];
    minMax[2] += transform[4];
    minMax[3] += transform[5];
  }
  static transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }
  static multiplyByDOMMatrix(m, md) {
    return [m[0] * md.a + m[2] * md.b, m[1] * md.a + m[3] * md.b, m[0] * md.c + m[2] * md.d, m[1] * md.c + m[3] * md.d, m[0] * md.e + m[2] * md.f + m[4], m[1] * md.e + m[3] * md.f + m[5]];
  }
  static applyTransform(p, m, pos = 0) {
    const p0 = p[pos];
    const p1 = p[pos + 1];
    p[pos] = p0 * m[0] + p1 * m[2] + m[4];
    p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];
  }
  static applyTransformToBezier(p, transform, pos = 0) {
    const m0 = transform[0];
    const m1 = transform[1];
    const m2 = transform[2];
    const m3 = transform[3];
    const m4 = transform[4];
    const m5 = transform[5];
    for (let i = 0; i < 6; i += 2) {
      const pI = p[pos + i];
      const pI1 = p[pos + i + 1];
      p[pos + i] = pI * m0 + pI1 * m2 + m4;
      p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;
    }
  }
  static applyInverseTransform(p, m) {
    const p0 = p[0];
    const p1 = p[1];
    const d = m[0] * m[3] - m[1] * m[2];
    p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
  }
  static axialAlignedBoundingBox(rect, transform, output) {
    const m0 = transform[0];
    const m1 = transform[1];
    const m2 = transform[2];
    const m3 = transform[3];
    const m4 = transform[4];
    const m5 = transform[5];
    const r0 = rect[0];
    const r1 = rect[1];
    const r2 = rect[2];
    const r3 = rect[3];
    let a0 = m0 * r0 + m4;
    let a2 = a0;
    let a1 = m0 * r2 + m4;
    let a3 = a1;
    let b0 = m3 * r1 + m5;
    let b2 = b0;
    let b1 = m3 * r3 + m5;
    let b3 = b1;
    if (m1 !== 0 || m2 !== 0) {
      const m1r0 = m1 * r0;
      const m1r2 = m1 * r2;
      const m2r1 = m2 * r1;
      const m2r3 = m2 * r3;
      a0 += m2r1;
      a3 += m2r1;
      a1 += m2r3;
      a2 += m2r3;
      b0 += m1r0;
      b3 += m1r0;
      b1 += m1r2;
      b2 += m1r2;
    }
    output[0] = Math.min(output[0], a0, a1, a2, a3);
    output[1] = Math.min(output[1], b0, b1, b2, b3);
    output[2] = Math.max(output[2], a0, a1, a2, a3);
    output[3] = Math.max(output[3], b0, b1, b2, b3);
  }
  static inverseTransform(m) {
    const d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  }
  static singularValueDecompose2dScale(matrix, output) {
    const m0 = matrix[0];
    const m1 = matrix[1];
    const m2 = matrix[2];
    const m3 = matrix[3];
    const a = m0 ** 2 + m1 ** 2;
    const b = m0 * m2 + m1 * m3;
    const c = m2 ** 2 + m3 ** 2;
    const first = (a + c) / 2;
    const second = Math.sqrt(first ** 2 - (a * c - b ** 2));
    output[0] = Math.sqrt(first + second || 1);
    output[1] = Math.sqrt(first - second || 1);
  }
  static normalizeRect(rect) {
    const r = rect.slice(0);
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  }
  static intersect(rect1, rect2) {
    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
    if (xLow > xHigh) {
      return null;
    }
    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
    if (yLow > yHigh) {
      return null;
    }
    return [xLow, yLow, xHigh, yHigh];
  }
  static pointBoundingBox(x, y, minMax) {
    minMax[0] = Math.min(minMax[0], x);
    minMax[1] = Math.min(minMax[1], y);
    minMax[2] = Math.max(minMax[2], x);
    minMax[3] = Math.max(minMax[3], y);
  }
  static rectBoundingBox(x0, y0, x1, y1, minMax) {
    minMax[0] = Math.min(minMax[0], x0, x1);
    minMax[1] = Math.min(minMax[1], y0, y1);
    minMax[2] = Math.max(minMax[2], x0, x1);
    minMax[3] = Math.max(minMax[3], y0, y1);
  }
  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
    minMax[0] = Math.min(minMax[0], x0, x3);
    minMax[1] = Math.min(minMax[1], y0, y3);
    minMax[2] = Math.max(minMax[2], x0, x3);
    minMax[3] = Math.max(minMax[3], y0, y3);
    __privateMethod(this, _getExtremum, getExtremum_fn).call(this, x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);
    __privateMethod(this, _getExtremum, getExtremum_fn).call(this, x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);
  }
};
_getExtremumOnCurve = new WeakSet();
getExtremumOnCurve_fn = function(x0, x1, x2, x3, y0, y1, y2, y3, t2, minMax) {
  if (t2 <= 0 || t2 >= 1) {
    return;
  }
  const mt = 1 - t2;
  const tt = t2 * t2;
  const ttt = tt * t2;
  const x = mt * (mt * (mt * x0 + 3 * t2 * x1) + 3 * tt * x2) + ttt * x3;
  const y = mt * (mt * (mt * y0 + 3 * t2 * y1) + 3 * tt * y2) + ttt * y3;
  minMax[0] = Math.min(minMax[0], x);
  minMax[1] = Math.min(minMax[1], y);
  minMax[2] = Math.max(minMax[2], x);
  minMax[3] = Math.max(minMax[3], y);
};
_getExtremum = new WeakSet();
getExtremum_fn = function(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {
  if (Math.abs(a) < 1e-12) {
    if (Math.abs(b) >= 1e-12) {
      __privateMethod(this, _getExtremumOnCurve, getExtremumOnCurve_fn).call(this, x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);
    }
    return;
  }
  const delta = b ** 2 - 4 * c * a;
  if (delta < 0) {
    return;
  }
  const sqrtDelta = Math.sqrt(delta);
  const a2 = 2 * a;
  __privateMethod(this, _getExtremumOnCurve, getExtremumOnCurve_fn).call(this, x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);
  __privateMethod(this, _getExtremumOnCurve, getExtremumOnCurve_fn).call(this, x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);
};
__privateAdd(Util, _getExtremumOnCurve);
__privateAdd(Util, _getExtremum);
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
var NormalizeRegex = null;
var NormalizationMap = null;
function normalizeUnicode(str) {
  if (!NormalizeRegex) {
    NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
    NormalizationMap = /* @__PURE__ */ new Map([["\uFB05", "\u017Ft"]]);
  }
  return str.replaceAll(NormalizeRegex, (_, p1, p2) => p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2));
}
function getUuid() {
  if (typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  const buf = new Uint8Array(32);
  crypto.getRandomValues(buf);
  return bytesToString(buf);
}
var AnnotationPrefix = "pdfjs_internal_id_";
function _isValidExplicitDest(validRef, validName, dest) {
  if (!Array.isArray(dest) || dest.length < 2) {
    return false;
  }
  const [page, zoom, ...args] = dest;
  if (!validRef(page) && !Number.isInteger(page)) {
    return false;
  }
  if (!validName(zoom)) {
    return false;
  }
  const argsLen = args.length;
  let allowNull = true;
  switch (zoom.name) {
    case "XYZ":
      if (argsLen < 2 || argsLen > 3) {
        return false;
      }
      break;
    case "Fit":
    case "FitB":
      return argsLen === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (argsLen > 1) {
        return false;
      }
      break;
    case "FitR":
      if (argsLen !== 4) {
        return false;
      }
      allowNull = false;
      break;
    default:
      return false;
  }
  for (const arg of args) {
    if (typeof arg === "number" || allowNull && arg === null) {
      continue;
    }
    return false;
  }
  return true;
}
function MathClamp(v, min, max2) {
  return Math.min(Math.max(v, min), max2);
}
function toBase64Util(arr) {
  if (Uint8Array.prototype.toBase64) {
    return arr.toBase64();
  }
  return btoa(bytesToString(arr));
}
function fromBase64Util(str) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(str);
  }
  return stringToBytes(atob(str));
}
if (typeof Promise.try !== "function") {
  Promise.try = function(fn, ...args) {
    return new Promise((resolve) => {
      resolve(fn(...args));
    });
  };
}
if (typeof Math.sumPrecise !== "function") {
  Math.sumPrecise = function(numbers) {
    return numbers.reduce((a, b) => a + b, 0);
  };
}
var SVG_NS = "http://www.w3.org/2000/svg";
var _PixelsPerInch = class _PixelsPerInch {
};
__publicField(_PixelsPerInch, "CSS", 96);
__publicField(_PixelsPerInch, "PDF", 72);
__publicField(_PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
var PixelsPerInch = _PixelsPerInch;
async function fetchData(url, type = "text") {
  if (isValidFetchUrl(url, document.baseURI)) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(response.statusText);
    }
    switch (type) {
      case "arraybuffer":
        return response.arrayBuffer();
      case "blob":
        return response.blob();
      case "json":
        return response.json();
    }
    return response.text();
  }
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = type;
    request.onreadystatechange = () => {
      if (request.readyState !== XMLHttpRequest.DONE) {
        return;
      }
      if (request.status === 200 || request.status === 0) {
        switch (type) {
          case "arraybuffer":
          case "blob":
          case "json":
            resolve(request.response);
            return;
        }
        resolve(request.responseText);
        return;
      }
      reject(new Error(request.statusText));
    };
    request.send(null);
  });
}
var PageViewport = class _PageViewport {
  constructor({
    viewBox,
    userUnit,
    scale,
    rotation,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  }) {
    this.viewBox = viewBox;
    this.userUnit = userUnit;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    scale *= userUnit;
    const centerX = (viewBox[2] + viewBox[0]) / 2;
    const centerY = (viewBox[3] + viewBox[1]) / 2;
    let rotateA, rotateB, rotateC, rotateD;
    rotation %= 360;
    if (rotation < 0) {
      rotation += 360;
    }
    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;
      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;
      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;
      case 0:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }
    let offsetCanvasX, offsetCanvasY;
    let width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = (viewBox[3] - viewBox[1]) * scale;
      height = (viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = (viewBox[2] - viewBox[0]) * scale;
      height = (viewBox[3] - viewBox[1]) * scale;
    }
    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
  }
  get rawDims() {
    const dims = this.viewBox;
    return shadow(this, "rawDims", {
      pageWidth: dims[2] - dims[0],
      pageHeight: dims[3] - dims[1],
      pageX: dims[0],
      pageY: dims[1]
    });
  }
  clone({
    scale = this.scale,
    rotation = this.rotation,
    offsetX = this.offsetX,
    offsetY = this.offsetY,
    dontFlip = false
  } = {}) {
    return new _PageViewport({
      viewBox: this.viewBox.slice(),
      userUnit: this.userUnit,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  convertToViewportPoint(x, y) {
    const p = [x, y];
    Util.applyTransform(p, this.transform);
    return p;
  }
  convertToViewportRectangle(rect) {
    const topLeft = [rect[0], rect[1]];
    Util.applyTransform(topLeft, this.transform);
    const bottomRight = [rect[2], rect[3]];
    Util.applyTransform(bottomRight, this.transform);
    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
  }
  convertToPdfPoint(x, y) {
    const p = [x, y];
    Util.applyInverseTransform(p, this.transform);
    return p;
  }
};
var RenderingCancelledException = class extends BaseException {
  constructor(msg, extraDelay = 0) {
    super(msg, "RenderingCancelledException");
    this.extraDelay = extraDelay;
  }
};
function isDataScheme(url) {
  const ii = url.length;
  let i = 0;
  while (i < ii && url[i].trim() === "") {
    i++;
  }
  return url.substring(i, i + 5).toLowerCase() === "data:";
}
function isPdfFile(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}
function getFilenameFromUrl(url) {
  [url] = url.split(/[#?]/, 1);
  return url.substring(url.lastIndexOf("/") + 1);
}
function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
  if (typeof url !== "string") {
    return defaultFilename;
  }
  if (isDataScheme(url)) {
    warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return defaultFilename;
  }
  const getURL = (urlString) => {
    try {
      return new URL(urlString);
    } catch (e) {
      try {
        return new URL(decodeURIComponent(urlString));
      } catch (e2) {
        try {
          return new URL(urlString, "https://foo.bar");
        } catch (e3) {
          try {
            return new URL(decodeURIComponent(urlString), "https://foo.bar");
          } catch (e4) {
            return null;
          }
        }
      }
    }
  };
  const newURL = getURL(url);
  if (!newURL) {
    return defaultFilename;
  }
  const decode = (name) => {
    try {
      let decoded = decodeURIComponent(name);
      if (decoded.includes("/")) {
        decoded = decoded.split("/").at(-1);
        if (decoded.test(/^\.pdf$/i)) {
          return decoded;
        }
        return name;
      }
      return decoded;
    } catch (e) {
      return name;
    }
  };
  const pdfRegex = /\.pdf$/i;
  const filename = newURL.pathname.split("/").at(-1);
  if (pdfRegex.test(filename)) {
    return decode(filename);
  }
  if (newURL.searchParams.size > 0) {
    const values = Array.from(newURL.searchParams.values()).reverse();
    for (const value of values) {
      if (pdfRegex.test(value)) {
        return decode(value);
      }
    }
    const keys = Array.from(newURL.searchParams.keys()).reverse();
    for (const key of keys) {
      if (pdfRegex.test(key)) {
        return decode(key);
      }
    }
  }
  if (newURL.hash) {
    const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
    const hashFilename = reFilename.exec(newURL.hash);
    if (hashFilename) {
      return decode(hashFilename[0]);
    }
  }
  return defaultFilename;
}
var StatTimer = class {
  constructor() {
    __publicField(this, "started", /* @__PURE__ */ Object.create(null));
    __publicField(this, "times", []);
  }
  time(name) {
    if (name in this.started) {
      warn(`Timer is already running for ${name}`);
    }
    this.started[name] = Date.now();
  }
  timeEnd(name) {
    if (!(name in this.started)) {
      warn(`Timer has not been started for ${name}`);
    }
    this.times.push({
      name,
      start: this.started[name],
      end: Date.now()
    });
    delete this.started[name];
  }
  toString() {
    const outBuf = [];
    let longest = 0;
    for (const {
      name
    } of this.times) {
      longest = Math.max(name.length, longest);
    }
    for (const {
      name,
      start,
      end
    } of this.times) {
      outBuf.push(`${name.padEnd(longest)} ${end - start}ms
`);
    }
    return outBuf.join("");
  }
};
function isValidFetchUrl(url, baseUrl) {
  const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
  return (res == null ? void 0 : res.protocol) === "http:" || (res == null ? void 0 : res.protocol) === "https:";
}
function noContextMenu(e) {
  e.preventDefault();
}
function stopEvent(e) {
  e.preventDefault();
  e.stopPropagation();
}
function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}
var _regex;
var PDFDateString = class {
  static toDateObject(input) {
    if (input instanceof Date) {
      return input;
    }
    if (!input || typeof input !== "string") {
      return null;
    }
    __privateGet(this, _regex) || __privateSet(this, _regex, new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
    const matches = __privateGet(this, _regex).exec(input);
    if (!matches) {
      return null;
    }
    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }
    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }
};
_regex = new WeakMap();
__privateAdd(PDFDateString, _regex, void 0);
function getXfaPageViewport(xfaPage, {
  scale = 1,
  rotation = 0
}) {
  const {
    width,
    height
  } = xfaPage.attributes.style;
  const viewBox = [0, 0, parseInt(width), parseInt(height)];
  return new PageViewport({
    viewBox,
    userUnit: 1,
    scale,
    rotation
  });
}
function getRGB(color) {
  if (color.startsWith("#")) {
    const colorRGB = parseInt(color.slice(1), 16);
    return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
  }
  if (color.startsWith("rgb(")) {
    return color.slice(4, -1).split(",").map((x) => parseInt(x));
  }
  if (color.startsWith("rgba(")) {
    return color.slice(5, -1).split(",").map((x) => parseInt(x)).slice(0, 3);
  }
  warn(`Not a valid color format: "${color}"`);
  return [0, 0, 0];
}
function getColorValues(colors) {
  const span = document.createElement("span");
  span.style.visibility = "hidden";
  span.style.colorScheme = "only light";
  document.body.append(span);
  for (const name of colors.keys()) {
    span.style.color = name;
    const computedColor = window.getComputedStyle(span).color;
    colors.set(name, getRGB(computedColor));
  }
  span.remove();
}
function getCurrentTransform(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform();
  return [a, b, c, d, e, f];
}
function getCurrentTransformInverse(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform().invertSelf();
  return [a, b, c, d, e, f];
}
function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
  if (viewport instanceof PageViewport) {
    const {
      pageWidth,
      pageHeight
    } = viewport.rawDims;
    const {
      style
    } = div;
    const useRound = util_FeatureTest.isCSSRoundSupported;
    const w = `var(--total-scale-factor) * ${pageWidth}px`, h = `var(--total-scale-factor) * ${pageHeight}px`;
    const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;
    if (!mustFlip || viewport.rotation % 180 === 0) {
      style.width = widthStr;
      style.height = heightStr;
    } else {
      style.width = heightStr;
      style.height = widthStr;
    }
  }
  if (mustRotate) {
    div.setAttribute("data-main-rotation", viewport.rotation);
  }
}
var OutputScale = class _OutputScale {
  constructor() {
    const {
      pixelRatio
    } = _OutputScale;
    this.sx = pixelRatio;
    this.sy = pixelRatio;
  }
  get scaled() {
    return this.sx !== 1 || this.sy !== 1;
  }
  get symmetric() {
    return this.sx === this.sy;
  }
  limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {
    let maxAreaScale = Infinity, maxWidthScale = Infinity, maxHeightScale = Infinity;
    maxPixels = _OutputScale.capPixels(maxPixels, capAreaFactor);
    if (maxPixels > 0) {
      maxAreaScale = Math.sqrt(maxPixels / (width * height));
    }
    if (maxDim !== -1) {
      maxWidthScale = maxDim / width;
      maxHeightScale = maxDim / height;
    }
    const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);
    if (this.sx > maxScale || this.sy > maxScale) {
      this.sx = maxScale;
      this.sy = maxScale;
      return true;
    }
    return false;
  }
  static get pixelRatio() {
    return globalThis.devicePixelRatio || 1;
  }
  static capPixels(maxPixels, capAreaFactor) {
    if (capAreaFactor >= 0) {
      const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));
      return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;
    }
    return maxPixels;
  }
};
var SupportedImageMimeTypes = ["image/apng", "image/avif", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/svg+xml", "image/webp", "image/x-icon"];
var _toolbar, _colorPicker, _editor, _buttons, _altText, _comment, _signatureDescriptionButton, _l10nRemove, _pointerDown, pointerDown_fn, _focusIn, focusIn_fn, _focusOut, focusOut_fn, _addListenersToElement, addListenersToElement_fn, _divider, divider_get;
var _EditorToolbar = class _EditorToolbar {
  constructor(editor) {
    __privateAdd(this, _focusIn);
    __privateAdd(this, _focusOut);
    __privateAdd(this, _addListenersToElement);
    __privateAdd(this, _divider);
    __privateAdd(this, _toolbar, null);
    __privateAdd(this, _colorPicker, null);
    __privateAdd(this, _editor, void 0);
    __privateAdd(this, _buttons, null);
    __privateAdd(this, _altText, null);
    __privateAdd(this, _comment, null);
    __privateAdd(this, _signatureDescriptionButton, null);
    __privateSet(this, _editor, editor);
    __privateGet(_EditorToolbar, _l10nRemove) || __privateSet(_EditorToolbar, _l10nRemove, Object.freeze({
      freetext: "pdfjs-editor-remove-freetext-button",
      highlight: "pdfjs-editor-remove-highlight-button",
      ink: "pdfjs-editor-remove-ink-button",
      stamp: "pdfjs-editor-remove-stamp-button",
      signature: "pdfjs-editor-remove-signature-button"
    }));
  }
  render() {
    const editToolbar = __privateSet(this, _toolbar, document.createElement("div"));
    editToolbar.classList.add("editToolbar", "hidden");
    editToolbar.setAttribute("role", "toolbar");
    const signal = __privateGet(this, _editor)._uiManager._signal;
    if (signal instanceof AbortSignal && !signal.aborted) {
      editToolbar.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      editToolbar.addEventListener("pointerdown", __privateMethod(_EditorToolbar, _pointerDown, pointerDown_fn), {
        signal
      });
    }
    const buttons = __privateSet(this, _buttons, document.createElement("div"));
    buttons.className = "buttons";
    editToolbar.append(buttons);
    const position = __privateGet(this, _editor).toolbarPosition;
    if (position) {
      const {
        style
      } = editToolbar;
      const x = __privateGet(this, _editor)._uiManager.direction === "ltr" ? 1 - position[0] : position[0];
      style.insetInlineEnd = `${100 * x}%`;
      style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    return editToolbar;
  }
  get div() {
    return __privateGet(this, _toolbar);
  }
  hide() {
    var _a3;
    __privateGet(this, _toolbar).classList.add("hidden");
    (_a3 = __privateGet(this, _colorPicker)) == null ? void 0 : _a3.hideDropdown();
  }
  show() {
    var _a3, _b2;
    __privateGet(this, _toolbar).classList.remove("hidden");
    (_a3 = __privateGet(this, _altText)) == null ? void 0 : _a3.shown();
    (_b2 = __privateGet(this, _comment)) == null ? void 0 : _b2.shown();
  }
  addDeleteButton() {
    const {
      editorType,
      _uiManager: _uiManager5
    } = __privateGet(this, _editor);
    const button = document.createElement("button");
    button.classList.add("basic", "deleteButton");
    button.tabIndex = 0;
    button.setAttribute("data-l10n-id", __privateGet(_EditorToolbar, _l10nRemove)[editorType]);
    if (__privateMethod(this, _addListenersToElement, addListenersToElement_fn).call(this, button)) {
      button.addEventListener("click", (e) => {
        _uiManager5.delete();
      }, {
        signal: _uiManager5._signal
      });
    }
    __privateGet(this, _buttons).append(button);
  }
  async addAltText(altText) {
    const button = await altText.render();
    __privateMethod(this, _addListenersToElement, addListenersToElement_fn).call(this, button);
    __privateGet(this, _buttons).append(button, __privateGet(this, _divider, divider_get));
    __privateSet(this, _altText, altText);
  }
  addComment(comment) {
    if (__privateGet(this, _comment)) {
      return;
    }
    const button = comment.render();
    if (!button) {
      return;
    }
    __privateMethod(this, _addListenersToElement, addListenersToElement_fn).call(this, button);
    __privateGet(this, _buttons).append(button, __privateGet(this, _divider, divider_get));
    __privateSet(this, _comment, comment);
    comment.toolbar = this;
  }
  addColorPicker(colorPicker) {
    if (__privateGet(this, _colorPicker)) {
      return;
    }
    __privateSet(this, _colorPicker, colorPicker);
    const button = colorPicker.renderButton();
    __privateMethod(this, _addListenersToElement, addListenersToElement_fn).call(this, button);
    __privateGet(this, _buttons).append(button, __privateGet(this, _divider, divider_get));
  }
  async addEditSignatureButton(signatureManager) {
    const button = __privateSet(this, _signatureDescriptionButton, await signatureManager.renderEditButton(__privateGet(this, _editor)));
    __privateMethod(this, _addListenersToElement, addListenersToElement_fn).call(this, button);
    __privateGet(this, _buttons).append(button, __privateGet(this, _divider, divider_get));
  }
  async addButton(name, tool) {
    switch (name) {
      case "colorPicker":
        this.addColorPicker(tool);
        break;
      case "altText":
        await this.addAltText(tool);
        break;
      case "editSignature":
        await this.addEditSignatureButton(tool);
        break;
      case "delete":
        this.addDeleteButton();
        break;
      case "comment":
        this.addComment(tool);
        break;
    }
  }
  updateEditSignatureButton(description) {
    if (__privateGet(this, _signatureDescriptionButton)) {
      __privateGet(this, _signatureDescriptionButton).title = description;
    }
  }
  remove() {
    var _a3;
    __privateGet(this, _toolbar).remove();
    (_a3 = __privateGet(this, _colorPicker)) == null ? void 0 : _a3.destroy();
    __privateSet(this, _colorPicker, null);
  }
};
_toolbar = new WeakMap();
_colorPicker = new WeakMap();
_editor = new WeakMap();
_buttons = new WeakMap();
_altText = new WeakMap();
_comment = new WeakMap();
_signatureDescriptionButton = new WeakMap();
_l10nRemove = new WeakMap();
_pointerDown = new WeakSet();
pointerDown_fn = function(e) {
  e.stopPropagation();
};
_focusIn = new WeakSet();
focusIn_fn = function(e) {
  __privateGet(this, _editor)._focusEventsAllowed = false;
  stopEvent(e);
};
_focusOut = new WeakSet();
focusOut_fn = function(e) {
  __privateGet(this, _editor)._focusEventsAllowed = true;
  stopEvent(e);
};
_addListenersToElement = new WeakSet();
addListenersToElement_fn = function(element) {
  const signal = __privateGet(this, _editor)._uiManager._signal;
  if (!(signal instanceof AbortSignal) || signal.aborted) {
    return false;
  }
  element.addEventListener("focusin", __privateMethod(this, _focusIn, focusIn_fn).bind(this), {
    capture: true,
    signal
  });
  element.addEventListener("focusout", __privateMethod(this, _focusOut, focusOut_fn).bind(this), {
    capture: true,
    signal
  });
  element.addEventListener("contextmenu", noContextMenu, {
    signal
  });
  return true;
};
_divider = new WeakSet();
divider_get = function() {
  const divider = document.createElement("div");
  divider.className = "divider";
  return divider;
};
__privateAdd(_EditorToolbar, _pointerDown);
__privateAdd(_EditorToolbar, _l10nRemove, null);
var EditorToolbar = _EditorToolbar;
var _buttons2, _toolbar2, _uiManager, _render, render_fn, _getLastPoint, getLastPoint_fn, _makeButton, makeButton_fn;
var FloatingToolbar = class {
  constructor(uiManager) {
    __privateAdd(this, _render);
    __privateAdd(this, _getLastPoint);
    __privateAdd(this, _makeButton);
    __privateAdd(this, _buttons2, null);
    __privateAdd(this, _toolbar2, null);
    __privateAdd(this, _uiManager, void 0);
    __privateSet(this, _uiManager, uiManager);
  }
  show(parent, boxes, isLTR) {
    const [x, y] = __privateMethod(this, _getLastPoint, getLastPoint_fn).call(this, boxes, isLTR);
    const {
      style
    } = __privateGet(this, _toolbar2) || __privateSet(this, _toolbar2, __privateMethod(this, _render, render_fn).call(this));
    parent.append(__privateGet(this, _toolbar2));
    style.insetInlineEnd = `${100 * x}%`;
    style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    __privateGet(this, _toolbar2).remove();
  }
};
_buttons2 = new WeakMap();
_toolbar2 = new WeakMap();
_uiManager = new WeakMap();
_render = new WeakSet();
render_fn = function() {
  const editToolbar = __privateSet(this, _toolbar2, document.createElement("div"));
  editToolbar.className = "editToolbar";
  editToolbar.setAttribute("role", "toolbar");
  const signal = __privateGet(this, _uiManager)._signal;
  if (signal instanceof AbortSignal && !signal.aborted) {
    editToolbar.addEventListener("contextmenu", noContextMenu, {
      signal
    });
  }
  const buttons = __privateSet(this, _buttons2, document.createElement("div"));
  buttons.className = "buttons";
  editToolbar.append(buttons);
  if (__privateGet(this, _uiManager).hasCommentManager()) {
    __privateMethod(this, _makeButton, makeButton_fn).call(this, "commentButton", `pdfjs-comment-floating-button`, "pdfjs-comment-floating-button-label", () => {
      __privateGet(this, _uiManager).commentSelection("floating_button");
    });
  }
  __privateMethod(this, _makeButton, makeButton_fn).call(this, "highlightButton", `pdfjs-highlight-floating-button1`, "pdfjs-highlight-floating-button-label", () => {
    __privateGet(this, _uiManager).highlightSelection("floating_button");
  });
  return editToolbar;
};
_getLastPoint = new WeakSet();
getLastPoint_fn = function(boxes, isLTR) {
  let lastY = 0;
  let lastX = 0;
  for (const box of boxes) {
    const y = box.y + box.height;
    if (y < lastY) {
      continue;
    }
    const x = box.x + (isLTR ? box.width : 0);
    if (y > lastY) {
      lastX = x;
      lastY = y;
      continue;
    }
    if (isLTR) {
      if (x > lastX) {
        lastX = x;
      }
    } else if (x < lastX) {
      lastX = x;
    }
  }
  return [isLTR ? 1 - lastX : lastX, lastY];
};
_makeButton = new WeakSet();
makeButton_fn = function(buttonClass, l10nId, labelL10nId, clickHandler) {
  const button = document.createElement("button");
  button.classList.add("basic", buttonClass);
  button.tabIndex = 0;
  button.setAttribute("data-l10n-id", l10nId);
  const span = document.createElement("span");
  button.append(span);
  span.className = "visuallyHidden";
  span.setAttribute("data-l10n-id", labelL10nId);
  const signal = __privateGet(this, _uiManager)._signal;
  if (signal instanceof AbortSignal && !signal.aborted) {
    button.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    button.addEventListener("click", clickHandler, {
      signal
    });
  }
  __privateGet(this, _buttons2).append(button);
};
function bindEvents(obj, element, names) {
  for (const name of names) {
    element.addEventListener(name, obj[name].bind(obj));
  }
}
var _id;
var IdManager = class {
  constructor() {
    __privateAdd(this, _id, 0);
  }
  get id() {
    return `${AnnotationEditorPrefix}${__privateWrapper(this, _id)._++}`;
  }
};
_id = new WeakMap();
var _baseId, _id2, _cache, _get, get_fn;
var _ImageManager = class _ImageManager {
  constructor() {
    __privateAdd(this, _get);
    __privateAdd(this, _baseId, getUuid());
    __privateAdd(this, _id2, 0);
    __privateAdd(this, _cache, null);
  }
  static get _isSVGFittingCanvas() {
    const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
    const canvas = new OffscreenCanvas(1, 3);
    const ctx = canvas.getContext("2d", {
      willReadFrequently: true
    });
    const image = new Image();
    image.src = svg;
    const promise = image.decode().then(() => {
      ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
      return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
    });
    return shadow(this, "_isSVGFittingCanvas", promise);
  }
  async getFromFile(file) {
    const {
      lastModified,
      name,
      size,
      type
    } = file;
    return __privateMethod(this, _get, get_fn).call(this, `${lastModified}_${name}_${size}_${type}`, file);
  }
  async getFromUrl(url) {
    return __privateMethod(this, _get, get_fn).call(this, url, url);
  }
  async getFromBlob(id, blobPromise) {
    const blob = await blobPromise;
    return __privateMethod(this, _get, get_fn).call(this, id, blob);
  }
  async getFromId(id) {
    __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
    const data = __privateGet(this, _cache).get(id);
    if (!data) {
      return null;
    }
    if (data.bitmap) {
      data.refCounter += 1;
      return data;
    }
    if (data.file) {
      return this.getFromFile(data.file);
    }
    if (data.blobPromise) {
      const {
        blobPromise
      } = data;
      delete data.blobPromise;
      return this.getFromBlob(data.id, blobPromise);
    }
    return this.getFromUrl(data.url);
  }
  getFromCanvas(id, canvas) {
    __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
    let data = __privateGet(this, _cache).get(id);
    if (data == null ? void 0 : data.bitmap) {
      data.refCounter += 1;
      return data;
    }
    const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
    const ctx = offscreen.getContext("2d");
    ctx.drawImage(canvas, 0, 0);
    data = {
      bitmap: offscreen.transferToImageBitmap(),
      id: `image_${__privateGet(this, _baseId)}_${__privateWrapper(this, _id2)._++}`,
      refCounter: 1,
      isSvg: false
    };
    __privateGet(this, _cache).set(id, data);
    __privateGet(this, _cache).set(data.id, data);
    return data;
  }
  getSvgUrl(id) {
    const data = __privateGet(this, _cache).get(id);
    if (!(data == null ? void 0 : data.isSvg)) {
      return null;
    }
    return data.svgUrl;
  }
  deleteId(id) {
    var _a3;
    __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
    const data = __privateGet(this, _cache).get(id);
    if (!data) {
      return;
    }
    data.refCounter -= 1;
    if (data.refCounter !== 0) {
      return;
    }
    const {
      bitmap
    } = data;
    if (!data.url && !data.file) {
      const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
      const ctx = canvas.getContext("bitmaprenderer");
      ctx.transferFromImageBitmap(bitmap);
      data.blobPromise = canvas.convertToBlob();
    }
    (_a3 = bitmap.close) == null ? void 0 : _a3.call(bitmap);
    data.bitmap = null;
  }
  isValidId(id) {
    return id.startsWith(`image_${__privateGet(this, _baseId)}_`);
  }
};
_baseId = new WeakMap();
_id2 = new WeakMap();
_cache = new WeakMap();
_get = new WeakSet();
get_fn = async function(key, rawData) {
  __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
  let data = __privateGet(this, _cache).get(key);
  if (data === null) {
    return null;
  }
  if (data == null ? void 0 : data.bitmap) {
    data.refCounter += 1;
    return data;
  }
  try {
    data || (data = {
      bitmap: null,
      id: `image_${__privateGet(this, _baseId)}_${__privateWrapper(this, _id2)._++}`,
      refCounter: 0,
      isSvg: false
    });
    let image;
    if (typeof rawData === "string") {
      data.url = rawData;
      image = await fetchData(rawData, "blob");
    } else if (rawData instanceof File) {
      image = data.file = rawData;
    } else if (rawData instanceof Blob) {
      image = rawData;
    }
    if (image.type === "image/svg+xml") {
      const mustRemoveAspectRatioPromise = _ImageManager._isSVGFittingCanvas;
      const fileReader = new FileReader();
      const imageElement = new Image();
      const imagePromise = new Promise((resolve, reject) => {
        imageElement.onload = () => {
          data.bitmap = imageElement;
          data.isSvg = true;
          resolve();
        };
        fileReader.onload = async () => {
          const url = data.svgUrl = fileReader.result;
          imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;
        };
        imageElement.onerror = fileReader.onerror = reject;
      });
      fileReader.readAsDataURL(image);
      await imagePromise;
    } else {
      data.bitmap = await createImageBitmap(image);
    }
    data.refCounter = 1;
  } catch (e) {
    warn(e);
    data = null;
  }
  __privateGet(this, _cache).set(key, data);
  if (data) {
    __privateGet(this, _cache).set(data.id, data);
  }
  return data;
};
var ImageManager = _ImageManager;
var _commands, _locked, _maxSize, _position;
var CommandManager = class {
  constructor(maxSize = 128) {
    __privateAdd(this, _commands, []);
    __privateAdd(this, _locked, false);
    __privateAdd(this, _maxSize, void 0);
    __privateAdd(this, _position, -1);
    __privateSet(this, _maxSize, maxSize);
  }
  add({
    cmd,
    undo: undo2,
    post,
    mustExec,
    type = NaN,
    overwriteIfSameType = false,
    keepUndo = false
  }) {
    if (mustExec) {
      cmd();
    }
    if (__privateGet(this, _locked)) {
      return;
    }
    const save = {
      cmd,
      undo: undo2,
      post,
      type
    };
    if (__privateGet(this, _position) === -1) {
      if (__privateGet(this, _commands).length > 0) {
        __privateGet(this, _commands).length = 0;
      }
      __privateSet(this, _position, 0);
      __privateGet(this, _commands).push(save);
      return;
    }
    if (overwriteIfSameType && __privateGet(this, _commands)[__privateGet(this, _position)].type === type) {
      if (keepUndo) {
        save.undo = __privateGet(this, _commands)[__privateGet(this, _position)].undo;
      }
      __privateGet(this, _commands)[__privateGet(this, _position)] = save;
      return;
    }
    const next = __privateGet(this, _position) + 1;
    if (next === __privateGet(this, _maxSize)) {
      __privateGet(this, _commands).splice(0, 1);
    } else {
      __privateSet(this, _position, next);
      if (next < __privateGet(this, _commands).length) {
        __privateGet(this, _commands).splice(next);
      }
    }
    __privateGet(this, _commands).push(save);
  }
  undo() {
    if (__privateGet(this, _position) === -1) {
      return;
    }
    __privateSet(this, _locked, true);
    const {
      undo: undo2,
      post
    } = __privateGet(this, _commands)[__privateGet(this, _position)];
    undo2();
    post == null ? void 0 : post();
    __privateSet(this, _locked, false);
    __privateSet(this, _position, __privateGet(this, _position) - 1);
  }
  redo() {
    if (__privateGet(this, _position) < __privateGet(this, _commands).length - 1) {
      __privateSet(this, _position, __privateGet(this, _position) + 1);
      __privateSet(this, _locked, true);
      const {
        cmd,
        post
      } = __privateGet(this, _commands)[__privateGet(this, _position)];
      cmd();
      post == null ? void 0 : post();
      __privateSet(this, _locked, false);
    }
  }
  hasSomethingToUndo() {
    return __privateGet(this, _position) !== -1;
  }
  hasSomethingToRedo() {
    return __privateGet(this, _position) < __privateGet(this, _commands).length - 1;
  }
  cleanType(type) {
    if (__privateGet(this, _position) === -1) {
      return;
    }
    for (let i = __privateGet(this, _position); i >= 0; i--) {
      if (__privateGet(this, _commands)[i].type !== type) {
        __privateGet(this, _commands).splice(i + 1, __privateGet(this, _position) - i);
        __privateSet(this, _position, i);
        return;
      }
    }
    __privateGet(this, _commands).length = 0;
    __privateSet(this, _position, -1);
  }
  destroy() {
    __privateSet(this, _commands, null);
  }
};
_commands = new WeakMap();
_locked = new WeakMap();
_maxSize = new WeakMap();
_position = new WeakMap();
var _serialize, serialize_fn;
var KeyboardManager = class {
  constructor(callbacks) {
    __privateAdd(this, _serialize);
    this.buffer = [];
    this.callbacks = /* @__PURE__ */ new Map();
    this.allKeys = /* @__PURE__ */ new Set();
    const {
      isMac
    } = util_FeatureTest.platform;
    for (const [keys, callback, options = {}] of callbacks) {
      for (const key of keys) {
        const isMacKey = key.startsWith("mac+");
        if (isMac && isMacKey) {
          this.callbacks.set(key.slice(4), {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        } else if (!isMac && !isMacKey) {
          this.callbacks.set(key, {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        }
      }
    }
  }
  exec(self, event) {
    if (!this.allKeys.has(event.key)) {
      return;
    }
    const info2 = this.callbacks.get(__privateMethod(this, _serialize, serialize_fn).call(this, event));
    if (!info2) {
      return;
    }
    const {
      callback,
      options: {
        bubbles = false,
        args = [],
        checker = null
      }
    } = info2;
    if (checker && !checker(self, event)) {
      return;
    }
    callback.bind(self, ...args, event)();
    if (!bubbles) {
      stopEvent(event);
    }
  }
};
_serialize = new WeakSet();
serialize_fn = function(event) {
  if (event.altKey) {
    this.buffer.push("alt");
  }
  if (event.ctrlKey) {
    this.buffer.push("ctrl");
  }
  if (event.metaKey) {
    this.buffer.push("meta");
  }
  if (event.shiftKey) {
    this.buffer.push("shift");
  }
  this.buffer.push(event.key);
  const str = this.buffer.join("+");
  this.buffer.length = 0;
  return str;
};
var _ColorManager = class _ColorManager {
  get _colors() {
    const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    getColorValues(colors);
    return shadow(this, "_colors", colors);
  }
  convert(color) {
    const rgb = getRGB(color);
    if (!window.matchMedia("(forced-colors: active)").matches) {
      return rgb;
    }
    for (const [name, RGB] of this._colors) {
      if (RGB.every((x, i) => x === rgb[i])) {
        return _ColorManager._colorsMapping.get(name);
      }
    }
    return rgb;
  }
  getHexCode(name) {
    const rgb = this._colors.get(name);
    if (!rgb) {
      return name;
    }
    return Util.makeHexColor(...rgb);
  }
};
__publicField(_ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
var ColorManager = _ColorManager;
var _abortController, _activeEditor, _allEditableAnnotations, _allEditors, _allLayers, _altTextManager, _annotationStorage, _changedExistingAnnotations, _commandManager, _commentManager, _copyPasteAC, _currentDrawingSession, _currentPageIndex, _deletedAnnotationsElementIds, _draggingEditors, _editorTypes, _editorsToRescale, _enableHighlightFloatingButton, _enableUpdatedAddImage, _enableNewAltTextWhenAddingImage, _filterFactory, _focusMainContainerTimeoutId, _focusManagerAC, _highlightColors, _highlightWhenShiftUp, _floatingToolbar, _idManager, _isEnabled, _isPointerDown, _isWaiting, _keyboardManagerAC, _lastActiveElement, _mainHighlightColorPicker, _missingCanvases, _mlManager, _mode, _selectedEditors, _selectedTextNode, _signatureManager, _pageColors, _showAllStates, _pdfDocument, _previousStates, _translation, _translationTimeoutId, _container, _viewer, _viewerAlert, _updateModeCapability, _getAnchorElementForSelection, getAnchorElementForSelection_fn, _getLayerForTextLayer, getLayerForTextLayer_fn, _displayFloatingToolbar, displayFloatingToolbar_fn, _selectionChange, selectionChange_fn, _onSelectEnd, onSelectEnd_fn, _addSelectionListener, addSelectionListener_fn, _addFocusManager, addFocusManager_fn, _removeFocusManager, removeFocusManager_fn, _addKeyboardManager, addKeyboardManager_fn, _removeKeyboardManager, removeKeyboardManager_fn, _addCopyPasteListeners, addCopyPasteListeners_fn, _removeCopyPasteListeners, removeCopyPasteListeners_fn, _addDragAndDropListeners, addDragAndDropListeners_fn, _dispatchUpdateStates, dispatchUpdateStates_fn, _dispatchUpdateUI, dispatchUpdateUI_fn, _enableAll, enableAll_fn, _disableAll, disableAll_fn, _addEditorToLayer, addEditorToLayer_fn, _lastSelectedEditor, lastSelectedEditor_get, _isEmpty, isEmpty_fn, _selectEditors, selectEditors_fn;
var _AnnotationEditorUIManager = class _AnnotationEditorUIManager {
  constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom) {
    __privateAdd(this, _getAnchorElementForSelection);
    __privateAdd(this, _getLayerForTextLayer);
    __privateAdd(this, _displayFloatingToolbar);
    __privateAdd(this, _selectionChange);
    __privateAdd(this, _onSelectEnd);
    __privateAdd(this, _addSelectionListener);
    __privateAdd(this, _addFocusManager);
    __privateAdd(this, _removeFocusManager);
    __privateAdd(this, _addKeyboardManager);
    __privateAdd(this, _removeKeyboardManager);
    __privateAdd(this, _addCopyPasteListeners);
    __privateAdd(this, _removeCopyPasteListeners);
    __privateAdd(this, _addDragAndDropListeners);
    __privateAdd(this, _dispatchUpdateStates);
    __privateAdd(this, _dispatchUpdateUI);
    __privateAdd(this, _enableAll);
    __privateAdd(this, _disableAll);
    __privateAdd(this, _addEditorToLayer);
    __privateAdd(this, _lastSelectedEditor);
    __privateAdd(this, _isEmpty);
    __privateAdd(this, _selectEditors);
    __privateAdd(this, _abortController, new AbortController());
    __privateAdd(this, _activeEditor, null);
    __privateAdd(this, _allEditableAnnotations, null);
    __privateAdd(this, _allEditors, /* @__PURE__ */ new Map());
    __privateAdd(this, _allLayers, /* @__PURE__ */ new Map());
    __privateAdd(this, _altTextManager, null);
    __privateAdd(this, _annotationStorage, null);
    __privateAdd(this, _changedExistingAnnotations, null);
    __privateAdd(this, _commandManager, new CommandManager());
    __privateAdd(this, _commentManager, null);
    __privateAdd(this, _copyPasteAC, null);
    __privateAdd(this, _currentDrawingSession, null);
    __privateAdd(this, _currentPageIndex, 0);
    __privateAdd(this, _deletedAnnotationsElementIds, /* @__PURE__ */ new Set());
    __privateAdd(this, _draggingEditors, null);
    __privateAdd(this, _editorTypes, null);
    __privateAdd(this, _editorsToRescale, /* @__PURE__ */ new Set());
    __publicField(this, "_editorUndoBar", null);
    __privateAdd(this, _enableHighlightFloatingButton, false);
    __privateAdd(this, _enableUpdatedAddImage, false);
    __privateAdd(this, _enableNewAltTextWhenAddingImage, false);
    __privateAdd(this, _filterFactory, null);
    __privateAdd(this, _focusMainContainerTimeoutId, null);
    __privateAdd(this, _focusManagerAC, null);
    __privateAdd(this, _highlightColors, null);
    __privateAdd(this, _highlightWhenShiftUp, false);
    __privateAdd(this, _floatingToolbar, null);
    __privateAdd(this, _idManager, new IdManager());
    __privateAdd(this, _isEnabled, false);
    __privateAdd(this, _isPointerDown, false);
    __privateAdd(this, _isWaiting, false);
    __privateAdd(this, _keyboardManagerAC, null);
    __privateAdd(this, _lastActiveElement, null);
    __privateAdd(this, _mainHighlightColorPicker, null);
    __privateAdd(this, _missingCanvases, null);
    __privateAdd(this, _mlManager, null);
    __privateAdd(this, _mode, AnnotationEditorType.NONE);
    __privateAdd(this, _selectedEditors, /* @__PURE__ */ new Set());
    __privateAdd(this, _selectedTextNode, null);
    __privateAdd(this, _signatureManager, null);
    __privateAdd(this, _pageColors, null);
    __privateAdd(this, _showAllStates, null);
    __privateAdd(this, _pdfDocument, null);
    __privateAdd(this, _previousStates, {
      isEditing: false,
      isEmpty: true,
      hasSomethingToUndo: false,
      hasSomethingToRedo: false,
      hasSelectedEditor: false,
      hasSelectedText: false
    });
    __privateAdd(this, _translation, [0, 0]);
    __privateAdd(this, _translationTimeoutId, null);
    __privateAdd(this, _container, null);
    __privateAdd(this, _viewer, null);
    __privateAdd(this, _viewerAlert, null);
    __privateAdd(this, _updateModeCapability, null);
    const signal = this._signal = __privateGet(this, _abortController).signal;
    __privateSet(this, _container, container);
    __privateSet(this, _viewer, viewer);
    __privateSet(this, _viewerAlert, viewerAlert);
    __privateSet(this, _altTextManager, altTextManager);
    __privateSet(this, _commentManager, commentManager);
    __privateSet(this, _signatureManager, signatureManager);
    __privateSet(this, _pdfDocument, pdfDocument);
    this._eventBus = eventBus;
    eventBus._on("editingaction", this.onEditingAction.bind(this), {
      signal
    });
    eventBus._on("pagechanging", this.onPageChanging.bind(this), {
      signal
    });
    eventBus._on("scalechanging", this.onScaleChanging.bind(this), {
      signal
    });
    eventBus._on("rotationchanging", this.onRotationChanging.bind(this), {
      signal
    });
    eventBus._on("setpreference", this.onSetPreference.bind(this), {
      signal
    });
    eventBus._on("switchannotationeditorparams", (evt) => this.updateParams(evt.type, evt.value), {
      signal
    });
    window.addEventListener("pointerdown", () => {
      __privateSet(this, _isPointerDown, true);
    }, {
      capture: true,
      signal
    });
    window.addEventListener("pointerup", () => {
      __privateSet(this, _isPointerDown, false);
    }, {
      capture: true,
      signal
    });
    __privateMethod(this, _addSelectionListener, addSelectionListener_fn).call(this);
    __privateMethod(this, _addDragAndDropListeners, addDragAndDropListeners_fn).call(this);
    __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
    __privateSet(this, _annotationStorage, pdfDocument.annotationStorage);
    __privateSet(this, _filterFactory, pdfDocument.filterFactory);
    __privateSet(this, _pageColors, pageColors);
    __privateSet(this, _highlightColors, highlightColors || null);
    __privateSet(this, _enableHighlightFloatingButton, enableHighlightFloatingButton);
    __privateSet(this, _enableUpdatedAddImage, enableUpdatedAddImage);
    __privateSet(this, _enableNewAltTextWhenAddingImage, enableNewAltTextWhenAddingImage);
    __privateSet(this, _mlManager, mlManager || null);
    this.viewParameters = {
      realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
      rotation: 0
    };
    this.isShiftKeyDown = false;
    this._editorUndoBar = editorUndoBar || null;
    this._supportsPinchToZoom = supportsPinchToZoom !== false;
  }
  static get _keyboardManager() {
    const proto = _AnnotationEditorUIManager.prototype;
    const arrowChecker = (self) => __privateGet(self, _container).contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && self.hasSomethingToControl();
    const textInputChecker = (_self, {
      target: el
    }) => {
      if (el instanceof HTMLInputElement) {
        const {
          type
        } = el;
        return type !== "text" && type !== "number";
      }
      return true;
    };
    const small = this.TRANSLATE_SMALL;
    const big = this.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll, {
      checker: textInputChecker
    }], [["ctrl+z", "mac+meta+z"], proto.undo, {
      checker: textInputChecker
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo, {
      checker: textInputChecker
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete, {
      checker: textInputChecker
    }], [["Enter", "mac+Enter"], proto.addNewEditorFromKeyboard, {
      checker: (self, {
        target: el
      }) => !(el instanceof HTMLButtonElement) && __privateGet(self, _container).contains(el) && !self.isEnterHandled
    }], [[" ", "mac+ "], proto.addNewEditorFromKeyboard, {
      checker: (self, {
        target: el
      }) => !(el instanceof HTMLButtonElement) && __privateGet(self, _container).contains(document.activeElement)
    }], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  destroy() {
    var _a3, _b2, _c, _d, _e, _f, _g, _h, _i;
    (_a3 = __privateGet(this, _updateModeCapability)) == null ? void 0 : _a3.resolve();
    __privateSet(this, _updateModeCapability, null);
    (_b2 = __privateGet(this, _abortController)) == null ? void 0 : _b2.abort();
    __privateSet(this, _abortController, null);
    this._signal = null;
    for (const layer of __privateGet(this, _allLayers).values()) {
      layer.destroy();
    }
    __privateGet(this, _allLayers).clear();
    __privateGet(this, _allEditors).clear();
    __privateGet(this, _editorsToRescale).clear();
    (_c = __privateGet(this, _missingCanvases)) == null ? void 0 : _c.clear();
    __privateSet(this, _activeEditor, null);
    __privateGet(this, _selectedEditors).clear();
    __privateGet(this, _commandManager).destroy();
    (_d = __privateGet(this, _altTextManager)) == null ? void 0 : _d.destroy();
    (_e = __privateGet(this, _commentManager)) == null ? void 0 : _e.destroy();
    (_f = __privateGet(this, _signatureManager)) == null ? void 0 : _f.destroy();
    (_g = __privateGet(this, _floatingToolbar)) == null ? void 0 : _g.hide();
    __privateSet(this, _floatingToolbar, null);
    (_h = __privateGet(this, _mainHighlightColorPicker)) == null ? void 0 : _h.destroy();
    __privateSet(this, _mainHighlightColorPicker, null);
    __privateSet(this, _allEditableAnnotations, null);
    if (__privateGet(this, _focusMainContainerTimeoutId)) {
      clearTimeout(__privateGet(this, _focusMainContainerTimeoutId));
      __privateSet(this, _focusMainContainerTimeoutId, null);
    }
    if (__privateGet(this, _translationTimeoutId)) {
      clearTimeout(__privateGet(this, _translationTimeoutId));
      __privateSet(this, _translationTimeoutId, null);
    }
    (_i = this._editorUndoBar) == null ? void 0 : _i.destroy();
    __privateSet(this, _pdfDocument, null);
  }
  combinedSignal(ac) {
    return AbortSignal.any([this._signal, ac.signal]);
  }
  get mlManager() {
    return __privateGet(this, _mlManager);
  }
  get useNewAltTextFlow() {
    return __privateGet(this, _enableUpdatedAddImage);
  }
  get useNewAltTextWhenAddingImage() {
    return __privateGet(this, _enableNewAltTextWhenAddingImage);
  }
  get hcmFilter() {
    return shadow(this, "hcmFilter", __privateGet(this, _pageColors) ? __privateGet(this, _filterFactory).addHCMFilter(__privateGet(this, _pageColors).foreground, __privateGet(this, _pageColors).background) : "none");
  }
  get direction() {
    return shadow(this, "direction", getComputedStyle(__privateGet(this, _container)).direction);
  }
  get _highlightColors() {
    return shadow(this, "_highlightColors", __privateGet(this, _highlightColors) ? new Map(__privateGet(this, _highlightColors).split(",").map((pair) => {
      pair = pair.split("=").map((x) => x.trim());
      pair[1] = pair[1].toUpperCase();
      return pair;
    })) : null);
  }
  get highlightColors() {
    const {
      _highlightColors: _highlightColors2
    } = this;
    if (!_highlightColors2) {
      return shadow(this, "highlightColors", null);
    }
    const map = /* @__PURE__ */ new Map();
    const hasHCM = !!__privateGet(this, _pageColors);
    for (const [name, color] of _highlightColors2) {
      const isNameForHCM = name.endsWith("_HCM");
      if (hasHCM && isNameForHCM) {
        map.set(name.replace("_HCM", ""), color);
        continue;
      }
      if (!hasHCM && !isNameForHCM) {
        map.set(name, color);
      }
    }
    return shadow(this, "highlightColors", map);
  }
  get highlightColorNames() {
    return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e) => e.reverse())) : null);
  }
  getNonHCMColor(color) {
    if (!this._highlightColors) {
      return color;
    }
    const colorName = this.highlightColorNames.get(color);
    return this._highlightColors.get(colorName) || color;
  }
  getNonHCMColorName(color) {
    return this.highlightColorNames.get(color) || color;
  }
  setCurrentDrawingSession(layer) {
    if (layer) {
      this.unselectAll();
      this.disableUserSelect(true);
    } else {
      this.disableUserSelect(false);
    }
    __privateSet(this, _currentDrawingSession, layer);
  }
  setMainHighlightColorPicker(colorPicker) {
    __privateSet(this, _mainHighlightColorPicker, colorPicker);
  }
  editAltText(editor, firstTime = false) {
    var _a3;
    (_a3 = __privateGet(this, _altTextManager)) == null ? void 0 : _a3.editAltText(this, editor, firstTime);
  }
  hasCommentManager() {
    return !!__privateGet(this, _commentManager);
  }
  editComment(editor, position) {
    var _a3;
    (_a3 = __privateGet(this, _commentManager)) == null ? void 0 : _a3.open(this, editor, position);
  }
  getSignature(editor) {
    var _a3;
    (_a3 = __privateGet(this, _signatureManager)) == null ? void 0 : _a3.getSignature({
      uiManager: this,
      editor
    });
  }
  get signatureManager() {
    return __privateGet(this, _signatureManager);
  }
  switchToMode(mode, callback) {
    this._eventBus.on("annotationeditormodechanged", callback, {
      once: true,
      signal: this._signal
    });
    this._eventBus.dispatch("showannotationeditorui", {
      source: this,
      mode
    });
  }
  setPreference(name, value) {
    this._eventBus.dispatch("setpreference", {
      source: this,
      name,
      value
    });
  }
  onSetPreference({
    name,
    value
  }) {
    switch (name) {
      case "enableNewAltTextWhenAddingImage":
        __privateSet(this, _enableNewAltTextWhenAddingImage, value);
        break;
    }
  }
  onPageChanging({
    pageNumber
  }) {
    __privateSet(this, _currentPageIndex, pageNumber - 1);
  }
  focusMainContainer() {
    __privateGet(this, _container).focus();
  }
  findParent(x, y) {
    for (const layer of __privateGet(this, _allLayers).values()) {
      const {
        x: layerX,
        y: layerY,
        width,
        height
      } = layer.div.getBoundingClientRect();
      if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {
        return layer;
      }
    }
    return null;
  }
  disableUserSelect(value = false) {
    __privateGet(this, _viewer).classList.toggle("noUserSelect", value);
  }
  addShouldRescale(editor) {
    __privateGet(this, _editorsToRescale).add(editor);
  }
  removeShouldRescale(editor) {
    __privateGet(this, _editorsToRescale).delete(editor);
  }
  onScaleChanging({
    scale
  }) {
    var _a3;
    this.commitOrRemove();
    this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
    for (const editor of __privateGet(this, _editorsToRescale)) {
      editor.onScaleChanging();
    }
    (_a3 = __privateGet(this, _currentDrawingSession)) == null ? void 0 : _a3.onScaleChanging();
  }
  onRotationChanging({
    pagesRotation
  }) {
    this.commitOrRemove();
    this.viewParameters.rotation = pagesRotation;
  }
  highlightSelection(methodOfCreation = "", comment = false) {
    const selection2 = document.getSelection();
    if (!selection2 || selection2.isCollapsed) {
      return;
    }
    const {
      anchorNode,
      anchorOffset,
      focusNode,
      focusOffset
    } = selection2;
    const text = selection2.toString();
    const anchorElement = __privateMethod(this, _getAnchorElementForSelection, getAnchorElementForSelection_fn).call(this, selection2);
    const textLayer = anchorElement.closest(".textLayer");
    const boxes = this.getSelectionBoxes(textLayer);
    if (!boxes) {
      return;
    }
    selection2.empty();
    const layer = __privateMethod(this, _getLayerForTextLayer, getLayerForTextLayer_fn).call(this, textLayer);
    const isNoneMode = __privateGet(this, _mode) === AnnotationEditorType.NONE;
    const callback = () => {
      const editor = layer == null ? void 0 : layer.createAndAddNewEditor({
        x: 0,
        y: 0
      }, false, {
        methodOfCreation,
        boxes,
        anchorNode,
        anchorOffset,
        focusNode,
        focusOffset,
        text
      });
      if (isNoneMode) {
        this.showAllEditors("highlight", true, true);
      }
      if (comment) {
        editor == null ? void 0 : editor.editComment();
      }
    };
    if (isNoneMode) {
      this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);
      return;
    }
    callback();
  }
  commentSelection(methodOfCreation = "") {
    this.highlightSelection(methodOfCreation, true);
  }
  addToAnnotationStorage(editor) {
    if (!editor.isEmpty() && __privateGet(this, _annotationStorage) && !__privateGet(this, _annotationStorage).has(editor.id)) {
      __privateGet(this, _annotationStorage).setValue(editor.id, editor);
    }
  }
  a11yAlert(messageId, args = null) {
    const viewerAlert = __privateGet(this, _viewerAlert);
    if (!viewerAlert) {
      return;
    }
    viewerAlert.setAttribute("data-l10n-id", messageId);
    if (args) {
      viewerAlert.setAttribute("data-l10n-args", JSON.stringify(args));
    } else {
      viewerAlert.removeAttribute("data-l10n-args");
    }
  }
  blur() {
    this.isShiftKeyDown = false;
    if (__privateGet(this, _highlightWhenShiftUp)) {
      __privateSet(this, _highlightWhenShiftUp, false);
      __privateMethod(this, _onSelectEnd, onSelectEnd_fn).call(this, "main_toolbar");
    }
    if (!this.hasSelection) {
      return;
    }
    const {
      activeElement
    } = document;
    for (const editor of __privateGet(this, _selectedEditors)) {
      if (editor.div.contains(activeElement)) {
        __privateSet(this, _lastActiveElement, [editor, activeElement]);
        editor._focusEventsAllowed = false;
        break;
      }
    }
  }
  focus() {
    if (!__privateGet(this, _lastActiveElement)) {
      return;
    }
    const [lastEditor, lastActiveElement] = __privateGet(this, _lastActiveElement);
    __privateSet(this, _lastActiveElement, null);
    lastActiveElement.addEventListener("focusin", () => {
      lastEditor._focusEventsAllowed = true;
    }, {
      once: true,
      signal: this._signal
    });
    lastActiveElement.focus();
  }
  addEditListeners() {
    __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
    __privateMethod(this, _addCopyPasteListeners, addCopyPasteListeners_fn).call(this);
  }
  removeEditListeners() {
    __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
    __privateMethod(this, _removeCopyPasteListeners, removeCopyPasteListeners_fn).call(this);
  }
  dragOver(event) {
    for (const {
      type
    } of event.dataTransfer.items) {
      for (const editorType of __privateGet(this, _editorTypes)) {
        if (editorType.isHandlingMimeForPasting(type)) {
          event.dataTransfer.dropEffect = "copy";
          event.preventDefault();
          return;
        }
      }
    }
  }
  drop(event) {
    for (const item of event.dataTransfer.items) {
      for (const editorType of __privateGet(this, _editorTypes)) {
        if (editorType.isHandlingMimeForPasting(item.type)) {
          editorType.paste(item, this.currentLayer);
          event.preventDefault();
          return;
        }
      }
    }
  }
  copy(event) {
    var _a3;
    event.preventDefault();
    (_a3 = __privateGet(this, _activeEditor)) == null ? void 0 : _a3.commitOrRemove();
    if (!this.hasSelection) {
      return;
    }
    const editors = [];
    for (const editor of __privateGet(this, _selectedEditors)) {
      const serialized = editor.serialize(true);
      if (serialized) {
        editors.push(serialized);
      }
    }
    if (editors.length === 0) {
      return;
    }
    event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
  }
  cut(event) {
    this.copy(event);
    this.delete();
  }
  async paste(event) {
    event.preventDefault();
    const {
      clipboardData
    } = event;
    for (const item of clipboardData.items) {
      for (const editorType of __privateGet(this, _editorTypes)) {
        if (editorType.isHandlingMimeForPasting(item.type)) {
          editorType.paste(item, this.currentLayer);
          return;
        }
      }
    }
    let data = clipboardData.getData("application/pdfjs");
    if (!data) {
      return;
    }
    try {
      data = JSON.parse(data);
    } catch (ex) {
      warn(`paste: "${ex.message}".`);
      return;
    }
    if (!Array.isArray(data)) {
      return;
    }
    this.unselectAll();
    const layer = this.currentLayer;
    try {
      const newEditors = [];
      for (const editor of data) {
        const deserializedEditor = await layer.deserialize(editor);
        if (!deserializedEditor) {
          return;
        }
        newEditors.push(deserializedEditor);
      }
      const cmd = () => {
        for (const editor of newEditors) {
          __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
        }
        __privateMethod(this, _selectEditors, selectEditors_fn).call(this, newEditors);
      };
      const undo2 = () => {
        for (const editor of newEditors) {
          editor.remove();
        }
      };
      this.addCommands({
        cmd,
        undo: undo2,
        mustExec: true
      });
    } catch (ex) {
      warn(`paste: "${ex.message}".`);
    }
  }
  keydown(event) {
    if (!this.isShiftKeyDown && event.key === "Shift") {
      this.isShiftKeyDown = true;
    }
    if (__privateGet(this, _mode) !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {
      _AnnotationEditorUIManager._keyboardManager.exec(this, event);
    }
  }
  keyup(event) {
    if (this.isShiftKeyDown && event.key === "Shift") {
      this.isShiftKeyDown = false;
      if (__privateGet(this, _highlightWhenShiftUp)) {
        __privateSet(this, _highlightWhenShiftUp, false);
        __privateMethod(this, _onSelectEnd, onSelectEnd_fn).call(this, "main_toolbar");
      }
    }
  }
  onEditingAction({
    name
  }) {
    switch (name) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[name]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
      case "commentSelection":
        this.commentSelection("context_menu");
        break;
    }
  }
  setEditingState(isEditing) {
    if (isEditing) {
      __privateMethod(this, _addFocusManager, addFocusManager_fn).call(this);
      __privateMethod(this, _addCopyPasteListeners, addCopyPasteListeners_fn).call(this);
      __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
        isEditing: __privateGet(this, _mode) !== AnnotationEditorType.NONE,
        isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this),
        hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
        hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
        hasSelectedEditor: false
      });
    } else {
      __privateMethod(this, _removeFocusManager, removeFocusManager_fn).call(this);
      __privateMethod(this, _removeCopyPasteListeners, removeCopyPasteListeners_fn).call(this);
      __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
        isEditing: false
      });
      this.disableUserSelect(false);
    }
  }
  registerEditorTypes(types) {
    if (__privateGet(this, _editorTypes)) {
      return;
    }
    __privateSet(this, _editorTypes, types);
    for (const editorType of __privateGet(this, _editorTypes)) {
      __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editorType.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return __privateGet(this, _idManager).id;
  }
  get currentLayer() {
    return __privateGet(this, _allLayers).get(__privateGet(this, _currentPageIndex));
  }
  getLayer(pageIndex) {
    return __privateGet(this, _allLayers).get(pageIndex);
  }
  get currentPageIndex() {
    return __privateGet(this, _currentPageIndex);
  }
  addLayer(layer) {
    __privateGet(this, _allLayers).set(layer.pageIndex, layer);
    if (__privateGet(this, _isEnabled)) {
      layer.enable();
    } else {
      layer.disable();
    }
  }
  removeLayer(layer) {
    __privateGet(this, _allLayers).delete(layer.pageIndex);
  }
  async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {
    var _a3, _b2, _c, _d, _e;
    if (__privateGet(this, _mode) === mode) {
      return;
    }
    if (__privateGet(this, _updateModeCapability)) {
      await __privateGet(this, _updateModeCapability).promise;
      if (!__privateGet(this, _updateModeCapability)) {
        return;
      }
    }
    __privateSet(this, _updateModeCapability, Promise.withResolvers());
    (_a3 = __privateGet(this, _currentDrawingSession)) == null ? void 0 : _a3.commitOrRemove();
    if (__privateGet(this, _mode) === AnnotationEditorType.POPUP) {
      (_b2 = __privateGet(this, _commentManager)) == null ? void 0 : _b2.hideSidebar();
    }
    __privateSet(this, _mode, mode);
    if (mode === AnnotationEditorType.NONE) {
      this.setEditingState(false);
      __privateMethod(this, _disableAll, disableAll_fn).call(this);
      (_c = this._editorUndoBar) == null ? void 0 : _c.hide();
      __privateGet(this, _updateModeCapability).resolve();
      return;
    }
    if (mode === AnnotationEditorType.SIGNATURE) {
      await ((_d = __privateGet(this, _signatureManager)) == null ? void 0 : _d.loadSignatures());
    }
    if (mode === AnnotationEditorType.POPUP) {
      __privateGet(this, _allEditableAnnotations) || __privateSet(this, _allEditableAnnotations, await __privateGet(this, _pdfDocument).getAnnotationsByType(new Set(__privateGet(this, _editorTypes).map((editorClass) => editorClass._editorType))));
      (_e = __privateGet(this, _commentManager)) == null ? void 0 : _e.showSidebar(__privateGet(this, _allEditableAnnotations));
    }
    this.setEditingState(true);
    await __privateMethod(this, _enableAll, enableAll_fn).call(this);
    this.unselectAll();
    for (const layer of __privateGet(this, _allLayers).values()) {
      layer.updateMode(mode);
    }
    if (!editId) {
      if (isFromKeyboard) {
        this.addNewEditorFromKeyboard();
      }
      __privateGet(this, _updateModeCapability).resolve();
      return;
    }
    for (const editor of __privateGet(this, _allEditors).values()) {
      if (editor.annotationElementId === editId || editor.id === editId) {
        this.setSelected(editor);
        if (editComment) {
          editor.editComment();
        } else if (mustEnterInEditMode) {
          editor.enterInEditMode();
        }
      } else {
        editor.unselect();
      }
    }
    __privateGet(this, _updateModeCapability).resolve();
  }
  addNewEditorFromKeyboard() {
    if (this.currentLayer.canCreateNewEmptyEditor()) {
      this.currentLayer.addNewEditor();
    }
  }
  updateToolbar(options) {
    if (options.mode === __privateGet(this, _mode)) {
      return;
    }
    this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      ...options
    });
  }
  updateParams(type, value) {
    if (!__privateGet(this, _editorTypes)) {
      return;
    }
    switch (type) {
      case AnnotationEditorParamsType.CREATE:
        this.currentLayer.addNewEditor(value);
        return;
      case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
        this._eventBus.dispatch("reporttelemetry", {
          source: this,
          details: {
            type: "editing",
            data: {
              type: "highlight",
              action: "toggle_visibility"
            }
          }
        });
        (__privateGet(this, _showAllStates) || __privateSet(this, _showAllStates, /* @__PURE__ */ new Map())).set(type, value);
        this.showAllEditors("highlight", value);
        break;
    }
    if (this.hasSelection) {
      for (const editor of __privateGet(this, _selectedEditors)) {
        editor.updateParams(type, value);
      }
    } else {
      for (const editorType of __privateGet(this, _editorTypes)) {
        editorType.updateDefaultParams(type, value);
      }
    }
  }
  showAllEditors(type, visible, updateButton = false) {
    var _a3, _b2;
    for (const editor of __privateGet(this, _allEditors).values()) {
      if (editor.editorType === type) {
        editor.show(visible);
      }
    }
    const state = (_b2 = (_a3 = __privateGet(this, _showAllStates)) == null ? void 0 : _a3.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL)) != null ? _b2 : true;
    if (state !== visible) {
      __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, [[AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible]]);
    }
  }
  enableWaiting(mustWait = false) {
    if (__privateGet(this, _isWaiting) === mustWait) {
      return;
    }
    __privateSet(this, _isWaiting, mustWait);
    for (const layer of __privateGet(this, _allLayers).values()) {
      if (mustWait) {
        layer.disableClick();
      } else {
        layer.enableClick();
      }
      layer.div.classList.toggle("waiting", mustWait);
    }
  }
  getEditors(pageIndex) {
    const editors = [];
    for (const editor of __privateGet(this, _allEditors).values()) {
      if (editor.pageIndex === pageIndex) {
        editors.push(editor);
      }
    }
    return editors;
  }
  getEditor(id) {
    return __privateGet(this, _allEditors).get(id);
  }
  addEditor(editor) {
    __privateGet(this, _allEditors).set(editor.id, editor);
  }
  removeEditor(editor) {
    var _a3, _b2;
    if (editor.div.contains(document.activeElement)) {
      if (__privateGet(this, _focusMainContainerTimeoutId)) {
        clearTimeout(__privateGet(this, _focusMainContainerTimeoutId));
      }
      __privateSet(this, _focusMainContainerTimeoutId, setTimeout(() => {
        this.focusMainContainer();
        __privateSet(this, _focusMainContainerTimeoutId, null);
      }, 0));
    }
    __privateGet(this, _allEditors).delete(editor.id);
    if (editor.annotationElementId) {
      (_a3 = __privateGet(this, _missingCanvases)) == null ? void 0 : _a3.delete(editor.annotationElementId);
    }
    this.unselect(editor);
    if (!editor.annotationElementId || !__privateGet(this, _deletedAnnotationsElementIds).has(editor.annotationElementId)) {
      (_b2 = __privateGet(this, _annotationStorage)) == null ? void 0 : _b2.remove(editor.id);
    }
  }
  addDeletedAnnotationElement(editor) {
    __privateGet(this, _deletedAnnotationsElementIds).add(editor.annotationElementId);
    this.addChangedExistingAnnotation(editor);
    editor.deleted = true;
  }
  isDeletedAnnotationElement(annotationElementId) {
    return __privateGet(this, _deletedAnnotationsElementIds).has(annotationElementId);
  }
  removeDeletedAnnotationElement(editor) {
    __privateGet(this, _deletedAnnotationsElementIds).delete(editor.annotationElementId);
    this.removeChangedExistingAnnotation(editor);
    editor.deleted = false;
  }
  setActiveEditor(editor) {
    if (__privateGet(this, _activeEditor) === editor) {
      return;
    }
    __privateSet(this, _activeEditor, editor);
    if (editor) {
      __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
    }
  }
  updateUI(editor) {
    if (__privateGet(this, _lastSelectedEditor, lastSelectedEditor_get) === editor) {
      __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
    }
  }
  updateUIForDefaultProperties(editorType) {
    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editorType.defaultPropertiesToUpdate);
  }
  toggleSelected(editor) {
    if (__privateGet(this, _selectedEditors).has(editor)) {
      __privateGet(this, _selectedEditors).delete(editor);
      editor.unselect();
      __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    __privateGet(this, _selectedEditors).add(editor);
    editor.select();
    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSelectedEditor: true
    });
  }
  setSelected(editor) {
    var _a3;
    this.updateToolbar({
      mode: editor.mode,
      editId: editor.id
    });
    (_a3 = __privateGet(this, _currentDrawingSession)) == null ? void 0 : _a3.commitOrRemove();
    for (const ed of __privateGet(this, _selectedEditors)) {
      if (ed !== editor) {
        ed.unselect();
      }
    }
    __privateGet(this, _selectedEditors).clear();
    __privateGet(this, _selectedEditors).add(editor);
    editor.select();
    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSelectedEditor: true
    });
  }
  isSelected(editor) {
    return __privateGet(this, _selectedEditors).has(editor);
  }
  get firstSelectedEditor() {
    return __privateGet(this, _selectedEditors).values().next().value;
  }
  unselect(editor) {
    editor.unselect();
    __privateGet(this, _selectedEditors).delete(editor);
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return __privateGet(this, _selectedEditors).size !== 0;
  }
  get isEnterHandled() {
    return __privateGet(this, _selectedEditors).size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    var _a3;
    __privateGet(this, _commandManager).undo();
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
      hasSomethingToRedo: true,
      isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
    });
    (_a3 = this._editorUndoBar) == null ? void 0 : _a3.hide();
  }
  redo() {
    __privateGet(this, _commandManager).redo();
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSomethingToUndo: true,
      hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
      isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
    });
  }
  addCommands(params) {
    __privateGet(this, _commandManager).add(params);
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSomethingToUndo: true,
      hasSomethingToRedo: false,
      isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
    });
  }
  cleanUndoStack(type) {
    __privateGet(this, _commandManager).cleanType(type);
  }
  delete() {
    var _a3;
    this.commitOrRemove();
    const drawingEditor = (_a3 = this.currentLayer) == null ? void 0 : _a3.endDrawingSession(true);
    if (!this.hasSelection && !drawingEditor) {
      return;
    }
    const editors = drawingEditor ? [drawingEditor] : [...__privateGet(this, _selectedEditors)];
    const cmd = () => {
      var _a4;
      (_a4 = this._editorUndoBar) == null ? void 0 : _a4.show(undo2, editors.length === 1 ? editors[0].editorType : editors.length);
      for (const editor of editors) {
        editor.remove();
      }
    };
    const undo2 = () => {
      for (const editor of editors) {
        __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
      }
    };
    this.addCommands({
      cmd,
      undo: undo2,
      mustExec: true
    });
  }
  commitOrRemove() {
    var _a3;
    (_a3 = __privateGet(this, _activeEditor)) == null ? void 0 : _a3.commitOrRemove();
  }
  hasSomethingToControl() {
    return __privateGet(this, _activeEditor) || this.hasSelection;
  }
  selectAll() {
    for (const editor of __privateGet(this, _selectedEditors)) {
      editor.commit();
    }
    __privateMethod(this, _selectEditors, selectEditors_fn).call(this, __privateGet(this, _allEditors).values());
  }
  unselectAll() {
    var _a3;
    if (__privateGet(this, _activeEditor)) {
      __privateGet(this, _activeEditor).commitOrRemove();
      if (__privateGet(this, _mode) !== AnnotationEditorType.NONE) {
        return;
      }
    }
    if ((_a3 = __privateGet(this, _currentDrawingSession)) == null ? void 0 : _a3.commitOrRemove()) {
      return;
    }
    if (!this.hasSelection) {
      return;
    }
    for (const editor of __privateGet(this, _selectedEditors)) {
      editor.unselect();
    }
    __privateGet(this, _selectedEditors).clear();
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSelectedEditor: false
    });
  }
  translateSelectedEditors(x, y, noCommit = false) {
    if (!noCommit) {
      this.commitOrRemove();
    }
    if (!this.hasSelection) {
      return;
    }
    __privateGet(this, _translation)[0] += x;
    __privateGet(this, _translation)[1] += y;
    const [totalX, totalY] = __privateGet(this, _translation);
    const editors = [...__privateGet(this, _selectedEditors)];
    const TIME_TO_WAIT = 1e3;
    if (__privateGet(this, _translationTimeoutId)) {
      clearTimeout(__privateGet(this, _translationTimeoutId));
    }
    __privateSet(this, _translationTimeoutId, setTimeout(() => {
      __privateSet(this, _translationTimeoutId, null);
      __privateGet(this, _translation)[0] = __privateGet(this, _translation)[1] = 0;
      this.addCommands({
        cmd: () => {
          for (const editor of editors) {
            if (__privateGet(this, _allEditors).has(editor.id)) {
              editor.translateInPage(totalX, totalY);
              editor.translationDone();
            }
          }
        },
        undo: () => {
          for (const editor of editors) {
            if (__privateGet(this, _allEditors).has(editor.id)) {
              editor.translateInPage(-totalX, -totalY);
              editor.translationDone();
            }
          }
        },
        mustExec: false
      });
    }, TIME_TO_WAIT));
    for (const editor of editors) {
      editor.translateInPage(x, y);
      editor.translationDone();
    }
  }
  setUpDragSession() {
    if (!this.hasSelection) {
      return;
    }
    this.disableUserSelect(true);
    __privateSet(this, _draggingEditors, /* @__PURE__ */ new Map());
    for (const editor of __privateGet(this, _selectedEditors)) {
      __privateGet(this, _draggingEditors).set(editor, {
        savedX: editor.x,
        savedY: editor.y,
        savedPageIndex: editor.pageIndex,
        newX: 0,
        newY: 0,
        newPageIndex: -1
      });
    }
  }
  endDragSession() {
    if (!__privateGet(this, _draggingEditors)) {
      return false;
    }
    this.disableUserSelect(false);
    const map = __privateGet(this, _draggingEditors);
    __privateSet(this, _draggingEditors, null);
    let mustBeAddedInUndoStack = false;
    for (const [{
      x,
      y,
      pageIndex
    }, value] of map) {
      value.newX = x;
      value.newY = y;
      value.newPageIndex = pageIndex;
      mustBeAddedInUndoStack || (mustBeAddedInUndoStack = x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex);
    }
    if (!mustBeAddedInUndoStack) {
      return false;
    }
    const move = (editor, x, y, pageIndex) => {
      if (__privateGet(this, _allEditors).has(editor.id)) {
        const parent = __privateGet(this, _allLayers).get(pageIndex);
        if (parent) {
          editor._setParentAndPosition(parent, x, y);
        } else {
          editor.pageIndex = pageIndex;
          editor.x = x;
          editor.y = y;
        }
      }
    };
    this.addCommands({
      cmd: () => {
        for (const [editor, {
          newX,
          newY,
          newPageIndex
        }] of map) {
          move(editor, newX, newY, newPageIndex);
        }
      },
      undo: () => {
        for (const [editor, {
          savedX,
          savedY,
          savedPageIndex
        }] of map) {
          move(editor, savedX, savedY, savedPageIndex);
        }
      },
      mustExec: true
    });
    return true;
  }
  dragSelectedEditors(tx, ty) {
    if (!__privateGet(this, _draggingEditors)) {
      return;
    }
    for (const editor of __privateGet(this, _draggingEditors).keys()) {
      editor.drag(tx, ty);
    }
  }
  rebuild(editor) {
    if (editor.parent === null) {
      const parent = this.getLayer(editor.pageIndex);
      if (parent) {
        parent.changeParent(editor);
        parent.addOrRebuild(editor);
      } else {
        this.addEditor(editor);
        this.addToAnnotationStorage(editor);
        editor.rebuild();
      }
    } else {
      editor.parent.addOrRebuild(editor);
    }
  }
  get isEditorHandlingKeyboard() {
    var _a3;
    return ((_a3 = this.getActive()) == null ? void 0 : _a3.shouldGetKeyboardEvents()) || __privateGet(this, _selectedEditors).size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(editor) {
    return __privateGet(this, _activeEditor) === editor;
  }
  getActive() {
    return __privateGet(this, _activeEditor);
  }
  getMode() {
    return __privateGet(this, _mode);
  }
  get imageManager() {
    return shadow(this, "imageManager", new ImageManager());
  }
  getSelectionBoxes(textLayer) {
    if (!textLayer) {
      return null;
    }
    const selection2 = document.getSelection();
    for (let i = 0, ii = selection2.rangeCount; i < ii; i++) {
      if (!textLayer.contains(selection2.getRangeAt(i).commonAncestorContainer)) {
        return null;
      }
    }
    const {
      x: layerX,
      y: layerY,
      width: parentWidth,
      height: parentHeight
    } = textLayer.getBoundingClientRect();
    let rotator;
    switch (textLayer.getAttribute("data-main-rotation")) {
      case "90":
        rotator = (x, y, w, h) => ({
          x: (y - layerY) / parentHeight,
          y: 1 - (x + w - layerX) / parentWidth,
          width: h / parentHeight,
          height: w / parentWidth
        });
        break;
      case "180":
        rotator = (x, y, w, h) => ({
          x: 1 - (x + w - layerX) / parentWidth,
          y: 1 - (y + h - layerY) / parentHeight,
          width: w / parentWidth,
          height: h / parentHeight
        });
        break;
      case "270":
        rotator = (x, y, w, h) => ({
          x: 1 - (y + h - layerY) / parentHeight,
          y: (x - layerX) / parentWidth,
          width: h / parentHeight,
          height: w / parentWidth
        });
        break;
      default:
        rotator = (x, y, w, h) => ({
          x: (x - layerX) / parentWidth,
          y: (y - layerY) / parentHeight,
          width: w / parentWidth,
          height: h / parentHeight
        });
        break;
    }
    const boxes = [];
    for (let i = 0, ii = selection2.rangeCount; i < ii; i++) {
      const range = selection2.getRangeAt(i);
      if (range.collapsed) {
        continue;
      }
      for (const {
        x,
        y,
        width,
        height
      } of range.getClientRects()) {
        if (width === 0 || height === 0) {
          continue;
        }
        boxes.push(rotator(x, y, width, height));
      }
    }
    return boxes.length === 0 ? null : boxes;
  }
  addChangedExistingAnnotation({
    annotationElementId,
    id
  }) {
    (__privateGet(this, _changedExistingAnnotations) || __privateSet(this, _changedExistingAnnotations, /* @__PURE__ */ new Map())).set(annotationElementId, id);
  }
  removeChangedExistingAnnotation({
    annotationElementId
  }) {
    var _a3;
    (_a3 = __privateGet(this, _changedExistingAnnotations)) == null ? void 0 : _a3.delete(annotationElementId);
  }
  renderAnnotationElement(annotation) {
    var _a3;
    const editorId = (_a3 = __privateGet(this, _changedExistingAnnotations)) == null ? void 0 : _a3.get(annotation.data.id);
    if (!editorId) {
      return;
    }
    const editor = __privateGet(this, _annotationStorage).getRawValue(editorId);
    if (!editor) {
      return;
    }
    if (__privateGet(this, _mode) === AnnotationEditorType.NONE && !editor.hasBeenModified) {
      return;
    }
    editor.renderAnnotationElement(annotation);
  }
  setMissingCanvas(annotationId, annotationElementId, canvas) {
    var _a3;
    const editor = (_a3 = __privateGet(this, _missingCanvases)) == null ? void 0 : _a3.get(annotationId);
    if (!editor) {
      return;
    }
    editor.setCanvas(annotationElementId, canvas);
    __privateGet(this, _missingCanvases).delete(annotationId);
  }
  addMissingCanvas(annotationId, editor) {
    (__privateGet(this, _missingCanvases) || __privateSet(this, _missingCanvases, /* @__PURE__ */ new Map())).set(annotationId, editor);
  }
};
_abortController = new WeakMap();
_activeEditor = new WeakMap();
_allEditableAnnotations = new WeakMap();
_allEditors = new WeakMap();
_allLayers = new WeakMap();
_altTextManager = new WeakMap();
_annotationStorage = new WeakMap();
_changedExistingAnnotations = new WeakMap();
_commandManager = new WeakMap();
_commentManager = new WeakMap();
_copyPasteAC = new WeakMap();
_currentDrawingSession = new WeakMap();
_currentPageIndex = new WeakMap();
_deletedAnnotationsElementIds = new WeakMap();
_draggingEditors = new WeakMap();
_editorTypes = new WeakMap();
_editorsToRescale = new WeakMap();
_enableHighlightFloatingButton = new WeakMap();
_enableUpdatedAddImage = new WeakMap();
_enableNewAltTextWhenAddingImage = new WeakMap();
_filterFactory = new WeakMap();
_focusMainContainerTimeoutId = new WeakMap();
_focusManagerAC = new WeakMap();
_highlightColors = new WeakMap();
_highlightWhenShiftUp = new WeakMap();
_floatingToolbar = new WeakMap();
_idManager = new WeakMap();
_isEnabled = new WeakMap();
_isPointerDown = new WeakMap();
_isWaiting = new WeakMap();
_keyboardManagerAC = new WeakMap();
_lastActiveElement = new WeakMap();
_mainHighlightColorPicker = new WeakMap();
_missingCanvases = new WeakMap();
_mlManager = new WeakMap();
_mode = new WeakMap();
_selectedEditors = new WeakMap();
_selectedTextNode = new WeakMap();
_signatureManager = new WeakMap();
_pageColors = new WeakMap();
_showAllStates = new WeakMap();
_pdfDocument = new WeakMap();
_previousStates = new WeakMap();
_translation = new WeakMap();
_translationTimeoutId = new WeakMap();
_container = new WeakMap();
_viewer = new WeakMap();
_viewerAlert = new WeakMap();
_updateModeCapability = new WeakMap();
_getAnchorElementForSelection = new WeakSet();
getAnchorElementForSelection_fn = function({
  anchorNode
}) {
  return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;
};
_getLayerForTextLayer = new WeakSet();
getLayerForTextLayer_fn = function(textLayer) {
  const {
    currentLayer
  } = this;
  if (currentLayer.hasTextLayer(textLayer)) {
    return currentLayer;
  }
  for (const layer of __privateGet(this, _allLayers).values()) {
    if (layer.hasTextLayer(textLayer)) {
      return layer;
    }
  }
  return null;
};
_displayFloatingToolbar = new WeakSet();
displayFloatingToolbar_fn = function() {
  const selection2 = document.getSelection();
  if (!selection2 || selection2.isCollapsed) {
    return;
  }
  const anchorElement = __privateMethod(this, _getAnchorElementForSelection, getAnchorElementForSelection_fn).call(this, selection2);
  const textLayer = anchorElement.closest(".textLayer");
  const boxes = this.getSelectionBoxes(textLayer);
  if (!boxes) {
    return;
  }
  __privateGet(this, _floatingToolbar) || __privateSet(this, _floatingToolbar, new FloatingToolbar(this));
  __privateGet(this, _floatingToolbar).show(textLayer, boxes, this.direction === "ltr");
};
_selectionChange = new WeakSet();
selectionChange_fn = function() {
  var _a3, _b2, _c;
  const selection2 = document.getSelection();
  if (!selection2 || selection2.isCollapsed) {
    if (__privateGet(this, _selectedTextNode)) {
      (_a3 = __privateGet(this, _floatingToolbar)) == null ? void 0 : _a3.hide();
      __privateSet(this, _selectedTextNode, null);
      __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
        hasSelectedText: false
      });
    }
    return;
  }
  const {
    anchorNode
  } = selection2;
  if (anchorNode === __privateGet(this, _selectedTextNode)) {
    return;
  }
  const anchorElement = __privateMethod(this, _getAnchorElementForSelection, getAnchorElementForSelection_fn).call(this, selection2);
  const textLayer = anchorElement.closest(".textLayer");
  if (!textLayer) {
    if (__privateGet(this, _selectedTextNode)) {
      (_b2 = __privateGet(this, _floatingToolbar)) == null ? void 0 : _b2.hide();
      __privateSet(this, _selectedTextNode, null);
      __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
        hasSelectedText: false
      });
    }
    return;
  }
  (_c = __privateGet(this, _floatingToolbar)) == null ? void 0 : _c.hide();
  __privateSet(this, _selectedTextNode, anchorNode);
  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
    hasSelectedText: true
  });
  if (__privateGet(this, _mode) !== AnnotationEditorType.HIGHLIGHT && __privateGet(this, _mode) !== AnnotationEditorType.NONE) {
    return;
  }
  if (__privateGet(this, _mode) === AnnotationEditorType.HIGHLIGHT) {
    this.showAllEditors("highlight", true, true);
  }
  __privateSet(this, _highlightWhenShiftUp, this.isShiftKeyDown);
  if (!this.isShiftKeyDown) {
    const activeLayer = __privateGet(this, _mode) === AnnotationEditorType.HIGHLIGHT ? __privateMethod(this, _getLayerForTextLayer, getLayerForTextLayer_fn).call(this, textLayer) : null;
    activeLayer == null ? void 0 : activeLayer.toggleDrawing();
    if (__privateGet(this, _isPointerDown)) {
      const ac = new AbortController();
      const signal = this.combinedSignal(ac);
      const pointerup = (e) => {
        if (e.type === "pointerup" && e.button !== 0) {
          return;
        }
        ac.abort();
        activeLayer == null ? void 0 : activeLayer.toggleDrawing(true);
        if (e.type === "pointerup") {
          __privateMethod(this, _onSelectEnd, onSelectEnd_fn).call(this, "main_toolbar");
        }
      };
      window.addEventListener("pointerup", pointerup, {
        signal
      });
      window.addEventListener("blur", pointerup, {
        signal
      });
    } else {
      activeLayer == null ? void 0 : activeLayer.toggleDrawing(true);
      __privateMethod(this, _onSelectEnd, onSelectEnd_fn).call(this, "main_toolbar");
    }
  }
};
_onSelectEnd = new WeakSet();
onSelectEnd_fn = function(methodOfCreation = "") {
  if (__privateGet(this, _mode) === AnnotationEditorType.HIGHLIGHT) {
    this.highlightSelection(methodOfCreation);
  } else if (__privateGet(this, _enableHighlightFloatingButton)) {
    __privateMethod(this, _displayFloatingToolbar, displayFloatingToolbar_fn).call(this);
  }
};
_addSelectionListener = new WeakSet();
addSelectionListener_fn = function() {
  document.addEventListener("selectionchange", __privateMethod(this, _selectionChange, selectionChange_fn).bind(this), {
    signal: this._signal
  });
};
_addFocusManager = new WeakSet();
addFocusManager_fn = function() {
  if (__privateGet(this, _focusManagerAC)) {
    return;
  }
  __privateSet(this, _focusManagerAC, new AbortController());
  const signal = this.combinedSignal(__privateGet(this, _focusManagerAC));
  window.addEventListener("focus", this.focus.bind(this), {
    signal
  });
  window.addEventListener("blur", this.blur.bind(this), {
    signal
  });
};
_removeFocusManager = new WeakSet();
removeFocusManager_fn = function() {
  var _a3;
  (_a3 = __privateGet(this, _focusManagerAC)) == null ? void 0 : _a3.abort();
  __privateSet(this, _focusManagerAC, null);
};
_addKeyboardManager = new WeakSet();
addKeyboardManager_fn = function() {
  if (__privateGet(this, _keyboardManagerAC)) {
    return;
  }
  __privateSet(this, _keyboardManagerAC, new AbortController());
  const signal = this.combinedSignal(__privateGet(this, _keyboardManagerAC));
  window.addEventListener("keydown", this.keydown.bind(this), {
    signal
  });
  window.addEventListener("keyup", this.keyup.bind(this), {
    signal
  });
};
_removeKeyboardManager = new WeakSet();
removeKeyboardManager_fn = function() {
  var _a3;
  (_a3 = __privateGet(this, _keyboardManagerAC)) == null ? void 0 : _a3.abort();
  __privateSet(this, _keyboardManagerAC, null);
};
_addCopyPasteListeners = new WeakSet();
addCopyPasteListeners_fn = function() {
  if (__privateGet(this, _copyPasteAC)) {
    return;
  }
  __privateSet(this, _copyPasteAC, new AbortController());
  const signal = this.combinedSignal(__privateGet(this, _copyPasteAC));
  document.addEventListener("copy", this.copy.bind(this), {
    signal
  });
  document.addEventListener("cut", this.cut.bind(this), {
    signal
  });
  document.addEventListener("paste", this.paste.bind(this), {
    signal
  });
};
_removeCopyPasteListeners = new WeakSet();
removeCopyPasteListeners_fn = function() {
  var _a3;
  (_a3 = __privateGet(this, _copyPasteAC)) == null ? void 0 : _a3.abort();
  __privateSet(this, _copyPasteAC, null);
};
_addDragAndDropListeners = new WeakSet();
addDragAndDropListeners_fn = function() {
  const signal = this._signal;
  document.addEventListener("dragover", this.dragOver.bind(this), {
    signal
  });
  document.addEventListener("drop", this.drop.bind(this), {
    signal
  });
};
_dispatchUpdateStates = new WeakSet();
dispatchUpdateStates_fn = function(details) {
  const hasChanged = Object.entries(details).some(([key, value]) => __privateGet(this, _previousStates)[key] !== value);
  if (hasChanged) {
    this._eventBus.dispatch("annotationeditorstateschanged", {
      source: this,
      details: Object.assign(__privateGet(this, _previousStates), details)
    });
    if (__privateGet(this, _mode) === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {
      __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, [[AnnotationEditorParamsType.HIGHLIGHT_FREE, true]]);
    }
  }
};
_dispatchUpdateUI = new WeakSet();
dispatchUpdateUI_fn = function(details) {
  this._eventBus.dispatch("annotationeditorparamschanged", {
    source: this,
    details
  });
};
_enableAll = new WeakSet();
enableAll_fn = async function() {
  if (!__privateGet(this, _isEnabled)) {
    __privateSet(this, _isEnabled, true);
    const promises2 = [];
    for (const layer of __privateGet(this, _allLayers).values()) {
      promises2.push(layer.enable());
    }
    await Promise.all(promises2);
    for (const editor of __privateGet(this, _allEditors).values()) {
      editor.enable();
    }
  }
};
_disableAll = new WeakSet();
disableAll_fn = function() {
  this.unselectAll();
  if (__privateGet(this, _isEnabled)) {
    __privateSet(this, _isEnabled, false);
    for (const layer of __privateGet(this, _allLayers).values()) {
      layer.disable();
    }
    for (const editor of __privateGet(this, _allEditors).values()) {
      editor.disable();
    }
  }
};
_addEditorToLayer = new WeakSet();
addEditorToLayer_fn = function(editor) {
  const layer = __privateGet(this, _allLayers).get(editor.pageIndex);
  if (layer) {
    layer.addOrRebuild(editor);
  } else {
    this.addEditor(editor);
    this.addToAnnotationStorage(editor);
  }
};
_lastSelectedEditor = new WeakSet();
lastSelectedEditor_get = function() {
  let ed = null;
  for (ed of __privateGet(this, _selectedEditors)) {
  }
  return ed;
};
_isEmpty = new WeakSet();
isEmpty_fn = function() {
  if (__privateGet(this, _allEditors).size === 0) {
    return true;
  }
  if (__privateGet(this, _allEditors).size === 1) {
    for (const editor of __privateGet(this, _allEditors).values()) {
      return editor.isEmpty();
    }
  }
  return false;
};
_selectEditors = new WeakSet();
selectEditors_fn = function(editors) {
  for (const editor of __privateGet(this, _selectedEditors)) {
    editor.unselect();
  }
  __privateGet(this, _selectedEditors).clear();
  for (const editor of editors) {
    if (editor.isEmpty()) {
      continue;
    }
    __privateGet(this, _selectedEditors).add(editor);
    editor.select();
  }
  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
    hasSelectedEditor: this.hasSelection
  });
};
__publicField(_AnnotationEditorUIManager, "TRANSLATE_SMALL", 1);
__publicField(_AnnotationEditorUIManager, "TRANSLATE_BIG", 10);
var AnnotationEditorUIManager = _AnnotationEditorUIManager;
var _altText2, _altTextDecorative, _altTextButton, _altTextButtonLabel, _altTextTooltip, _altTextTooltipTimeout, _altTextWasFromKeyBoard, _badge, _editor2, _guessedText, _textWithDisclaimer, _useNewAltTextFlow, _l10nNewButton, _label, label_get, _setState, setState_fn;
var _AltText = class _AltText {
  constructor(editor) {
    __privateAdd(this, _label);
    __privateAdd(this, _setState);
    __privateAdd(this, _altText2, null);
    __privateAdd(this, _altTextDecorative, false);
    __privateAdd(this, _altTextButton, null);
    __privateAdd(this, _altTextButtonLabel, null);
    __privateAdd(this, _altTextTooltip, null);
    __privateAdd(this, _altTextTooltipTimeout, null);
    __privateAdd(this, _altTextWasFromKeyBoard, false);
    __privateAdd(this, _badge, null);
    __privateAdd(this, _editor2, null);
    __privateAdd(this, _guessedText, null);
    __privateAdd(this, _textWithDisclaimer, null);
    __privateAdd(this, _useNewAltTextFlow, false);
    __privateSet(this, _editor2, editor);
    __privateSet(this, _useNewAltTextFlow, editor._uiManager.useNewAltTextFlow);
    __privateGet(_AltText, _l10nNewButton) || __privateSet(_AltText, _l10nNewButton, Object.freeze({
      added: "pdfjs-editor-new-alt-text-added-button",
      "added-label": "pdfjs-editor-new-alt-text-added-button-label",
      missing: "pdfjs-editor-new-alt-text-missing-button",
      "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
      review: "pdfjs-editor-new-alt-text-to-review-button",
      "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
    }));
  }
  static initialize(l10n) {
    var _a3;
    (_a3 = _AltText._l10n) != null ? _a3 : _AltText._l10n = l10n;
  }
  async render() {
    const altText = __privateSet(this, _altTextButton, document.createElement("button"));
    altText.className = "altText";
    altText.tabIndex = "0";
    const label = __privateSet(this, _altTextButtonLabel, document.createElement("span"));
    altText.append(label);
    if (__privateGet(this, _useNewAltTextFlow)) {
      altText.classList.add("new");
      altText.setAttribute("data-l10n-id", __privateGet(_AltText, _l10nNewButton).missing);
      label.setAttribute("data-l10n-id", __privateGet(_AltText, _l10nNewButton)["missing-label"]);
    } else {
      altText.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button");
      label.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label");
    }
    const signal = __privateGet(this, _editor2)._uiManager._signal;
    altText.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    altText.addEventListener("pointerdown", (event) => event.stopPropagation(), {
      signal
    });
    const onClick = (event) => {
      event.preventDefault();
      __privateGet(this, _editor2)._uiManager.editAltText(__privateGet(this, _editor2));
      if (__privateGet(this, _useNewAltTextFlow)) {
        __privateGet(this, _editor2)._reportTelemetry({
          action: "pdfjs.image.alt_text.image_status_label_clicked",
          data: {
            label: __privateGet(this, _label, label_get)
          }
        });
      }
    };
    altText.addEventListener("click", onClick, {
      capture: true,
      signal
    });
    altText.addEventListener("keydown", (event) => {
      if (event.target === altText && event.key === "Enter") {
        __privateSet(this, _altTextWasFromKeyBoard, true);
        onClick(event);
      }
    }, {
      signal
    });
    await __privateMethod(this, _setState, setState_fn).call(this);
    return altText;
  }
  finish() {
    if (!__privateGet(this, _altTextButton)) {
      return;
    }
    __privateGet(this, _altTextButton).focus({
      focusVisible: __privateGet(this, _altTextWasFromKeyBoard)
    });
    __privateSet(this, _altTextWasFromKeyBoard, false);
  }
  isEmpty() {
    if (__privateGet(this, _useNewAltTextFlow)) {
      return __privateGet(this, _altText2) === null;
    }
    return !__privateGet(this, _altText2) && !__privateGet(this, _altTextDecorative);
  }
  hasData() {
    if (__privateGet(this, _useNewAltTextFlow)) {
      return __privateGet(this, _altText2) !== null || !!__privateGet(this, _guessedText);
    }
    return this.isEmpty();
  }
  get guessedText() {
    return __privateGet(this, _guessedText);
  }
  async setGuessedText(guessedText) {
    if (__privateGet(this, _altText2) !== null) {
      return;
    }
    __privateSet(this, _guessedText, guessedText);
    __privateSet(this, _textWithDisclaimer, await _AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
      generatedAltText: guessedText
    }));
    __privateMethod(this, _setState, setState_fn).call(this);
  }
  toggleAltTextBadge(visibility = false) {
    var _a3;
    if (!__privateGet(this, _useNewAltTextFlow) || __privateGet(this, _altText2)) {
      (_a3 = __privateGet(this, _badge)) == null ? void 0 : _a3.remove();
      __privateSet(this, _badge, null);
      return;
    }
    if (!__privateGet(this, _badge)) {
      const badge = __privateSet(this, _badge, document.createElement("div"));
      badge.className = "noAltTextBadge";
      __privateGet(this, _editor2).div.append(badge);
    }
    __privateGet(this, _badge).classList.toggle("hidden", !visibility);
  }
  serialize(isForCopying) {
    let altText = __privateGet(this, _altText2);
    if (!isForCopying && __privateGet(this, _guessedText) === altText) {
      altText = __privateGet(this, _textWithDisclaimer);
    }
    return {
      altText,
      decorative: __privateGet(this, _altTextDecorative),
      guessedText: __privateGet(this, _guessedText),
      textWithDisclaimer: __privateGet(this, _textWithDisclaimer)
    };
  }
  get data() {
    return {
      altText: __privateGet(this, _altText2),
      decorative: __privateGet(this, _altTextDecorative)
    };
  }
  set data({
    altText,
    decorative,
    guessedText,
    textWithDisclaimer,
    cancel = false
  }) {
    if (guessedText) {
      __privateSet(this, _guessedText, guessedText);
      __privateSet(this, _textWithDisclaimer, textWithDisclaimer);
    }
    if (__privateGet(this, _altText2) === altText && __privateGet(this, _altTextDecorative) === decorative) {
      return;
    }
    if (!cancel) {
      __privateSet(this, _altText2, altText);
      __privateSet(this, _altTextDecorative, decorative);
    }
    __privateMethod(this, _setState, setState_fn).call(this);
  }
  toggle(enabled = false) {
    if (!__privateGet(this, _altTextButton)) {
      return;
    }
    if (!enabled && __privateGet(this, _altTextTooltipTimeout)) {
      clearTimeout(__privateGet(this, _altTextTooltipTimeout));
      __privateSet(this, _altTextTooltipTimeout, null);
    }
    __privateGet(this, _altTextButton).disabled = !enabled;
  }
  shown() {
    __privateGet(this, _editor2)._reportTelemetry({
      action: "pdfjs.image.alt_text.image_status_label_displayed",
      data: {
        label: __privateGet(this, _label, label_get)
      }
    });
  }
  destroy() {
    var _a3, _b2;
    (_a3 = __privateGet(this, _altTextButton)) == null ? void 0 : _a3.remove();
    __privateSet(this, _altTextButton, null);
    __privateSet(this, _altTextButtonLabel, null);
    __privateSet(this, _altTextTooltip, null);
    (_b2 = __privateGet(this, _badge)) == null ? void 0 : _b2.remove();
    __privateSet(this, _badge, null);
  }
};
_altText2 = new WeakMap();
_altTextDecorative = new WeakMap();
_altTextButton = new WeakMap();
_altTextButtonLabel = new WeakMap();
_altTextTooltip = new WeakMap();
_altTextTooltipTimeout = new WeakMap();
_altTextWasFromKeyBoard = new WeakMap();
_badge = new WeakMap();
_editor2 = new WeakMap();
_guessedText = new WeakMap();
_textWithDisclaimer = new WeakMap();
_useNewAltTextFlow = new WeakMap();
_l10nNewButton = new WeakMap();
_label = new WeakSet();
label_get = function() {
  return __privateGet(this, _altText2) && "added" || __privateGet(this, _altText2) === null && this.guessedText && "review" || "missing";
};
_setState = new WeakSet();
setState_fn = async function() {
  var _a3, _b2, _c;
  const button = __privateGet(this, _altTextButton);
  if (!button) {
    return;
  }
  if (__privateGet(this, _useNewAltTextFlow)) {
    button.classList.toggle("done", !!__privateGet(this, _altText2));
    button.setAttribute("data-l10n-id", __privateGet(_AltText, _l10nNewButton)[__privateGet(this, _label, label_get)]);
    (_a3 = __privateGet(this, _altTextButtonLabel)) == null ? void 0 : _a3.setAttribute("data-l10n-id", __privateGet(_AltText, _l10nNewButton)[`${__privateGet(this, _label, label_get)}-label`]);
    if (!__privateGet(this, _altText2)) {
      (_b2 = __privateGet(this, _altTextTooltip)) == null ? void 0 : _b2.remove();
      return;
    }
  } else {
    if (!__privateGet(this, _altText2) && !__privateGet(this, _altTextDecorative)) {
      button.classList.remove("done");
      (_c = __privateGet(this, _altTextTooltip)) == null ? void 0 : _c.remove();
      return;
    }
    button.classList.add("done");
    button.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
  }
  let tooltip = __privateGet(this, _altTextTooltip);
  if (!tooltip) {
    __privateSet(this, _altTextTooltip, tooltip = document.createElement("span"));
    tooltip.className = "tooltip";
    tooltip.setAttribute("role", "tooltip");
    tooltip.id = `alt-text-tooltip-${__privateGet(this, _editor2).id}`;
    const DELAY_TO_SHOW_TOOLTIP = 100;
    const signal = __privateGet(this, _editor2)._uiManager._signal;
    signal.addEventListener("abort", () => {
      clearTimeout(__privateGet(this, _altTextTooltipTimeout));
      __privateSet(this, _altTextTooltipTimeout, null);
    }, {
      once: true
    });
    button.addEventListener("mouseenter", () => {
      __privateSet(this, _altTextTooltipTimeout, setTimeout(() => {
        __privateSet(this, _altTextTooltipTimeout, null);
        __privateGet(this, _altTextTooltip).classList.add("show");
        __privateGet(this, _editor2)._reportTelemetry({
          action: "alt_text_tooltip"
        });
      }, DELAY_TO_SHOW_TOOLTIP));
    }, {
      signal
    });
    button.addEventListener("mouseleave", () => {
      var _a4;
      if (__privateGet(this, _altTextTooltipTimeout)) {
        clearTimeout(__privateGet(this, _altTextTooltipTimeout));
        __privateSet(this, _altTextTooltipTimeout, null);
      }
      (_a4 = __privateGet(this, _altTextTooltip)) == null ? void 0 : _a4.classList.remove("show");
    }, {
      signal
    });
  }
  if (__privateGet(this, _altTextDecorative)) {
    tooltip.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip");
  } else {
    tooltip.removeAttribute("data-l10n-id");
    tooltip.textContent = __privateGet(this, _altText2);
  }
  if (!tooltip.parentNode) {
    button.append(tooltip);
  }
  const element = __privateGet(this, _editor2).getElementForAltText();
  element == null ? void 0 : element.setAttribute("aria-describedby", tooltip.id);
};
__privateAdd(_AltText, _l10nNewButton, null);
__publicField(_AltText, "_l10n", null);
var AltText = _AltText;
var _commentButton, _commentWasFromKeyBoard, _editor3, _initialText, _text, _date, _deleted;
var Comment = class {
  constructor(editor) {
    __privateAdd(this, _commentButton, null);
    __privateAdd(this, _commentWasFromKeyBoard, false);
    __privateAdd(this, _editor3, null);
    __privateAdd(this, _initialText, null);
    __privateAdd(this, _text, null);
    __privateAdd(this, _date, null);
    __privateAdd(this, _deleted, false);
    __privateSet(this, _editor3, editor);
    this.toolbar = null;
  }
  render() {
    if (!__privateGet(this, _editor3)._uiManager.hasCommentManager()) {
      return null;
    }
    const comment = __privateSet(this, _commentButton, document.createElement("button"));
    comment.className = "comment";
    comment.tabIndex = "0";
    comment.setAttribute("data-l10n-id", "pdfjs-editor-edit-comment-button");
    const signal = __privateGet(this, _editor3)._uiManager._signal;
    if (!(signal instanceof AbortSignal) || signal.aborted) {
      return comment;
    }
    comment.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    comment.addEventListener("pointerdown", (event) => event.stopPropagation(), {
      signal
    });
    const onClick = (event) => {
      event.preventDefault();
      this.edit();
    };
    comment.addEventListener("click", onClick, {
      capture: true,
      signal
    });
    comment.addEventListener("keydown", (event) => {
      if (event.target === comment && event.key === "Enter") {
        __privateSet(this, _commentWasFromKeyBoard, true);
        onClick(event);
      }
    }, {
      signal
    });
    return comment;
  }
  edit() {
    const {
      bottom,
      left,
      right
    } = __privateGet(this, _editor3).getClientDimensions();
    const position = {
      top: bottom
    };
    if (__privateGet(this, _editor3)._uiManager.direction === "ltr") {
      position.right = right;
    } else {
      position.left = left;
    }
    __privateGet(this, _editor3)._uiManager.editComment(__privateGet(this, _editor3), position);
  }
  finish() {
    if (!__privateGet(this, _commentButton)) {
      return;
    }
    __privateGet(this, _commentButton).focus({
      focusVisible: __privateGet(this, _commentWasFromKeyBoard)
    });
    __privateSet(this, _commentWasFromKeyBoard, false);
  }
  isDeleted() {
    return __privateGet(this, _deleted) || __privateGet(this, _text) === "";
  }
  hasBeenEdited() {
    return this.isDeleted() || __privateGet(this, _text) !== __privateGet(this, _initialText);
  }
  serialize() {
    return this.data;
  }
  get data() {
    return {
      text: __privateGet(this, _text),
      date: __privateGet(this, _date),
      deleted: __privateGet(this, _deleted)
    };
  }
  set data(text) {
    if (text === null) {
      __privateSet(this, _text, "");
      __privateSet(this, _deleted, true);
      return;
    }
    __privateSet(this, _text, text);
    __privateSet(this, _date, /* @__PURE__ */ new Date());
    __privateSet(this, _deleted, false);
  }
  setInitialText(text) {
    __privateSet(this, _initialText, text);
    this.data = text;
  }
  toggle(enabled = false) {
    if (!__privateGet(this, _commentButton)) {
      return;
    }
    __privateGet(this, _commentButton).disabled = !enabled;
  }
  shown() {
  }
  destroy() {
    var _a3;
    (_a3 = __privateGet(this, _commentButton)) == null ? void 0 : _a3.remove();
    __privateSet(this, _commentButton, null);
    __privateSet(this, _text, "");
    __privateSet(this, _date, null);
    __privateSet(this, _editor3, null);
    __privateSet(this, _commentWasFromKeyBoard, false);
    __privateSet(this, _deleted, false);
  }
};
_commentButton = new WeakMap();
_commentWasFromKeyBoard = new WeakMap();
_editor3 = new WeakMap();
_initialText = new WeakMap();
_text = new WeakMap();
_date = new WeakMap();
_deleted = new WeakMap();
var _container2, _isPinching, _isPinchingStopped, _isPinchingDisabled, _onPinchStart, _onPinching, _onPinchEnd, _pointerDownAC, _signal, _touchInfo, _touchManagerAC, _touchMoveAC, _onTouchStart, onTouchStart_fn, _onTouchMove, onTouchMove_fn, _onTouchEnd, onTouchEnd_fn;
var _TouchManager = class _TouchManager {
  constructor({
    container,
    isPinchingDisabled = null,
    isPinchingStopped = null,
    onPinchStart = null,
    onPinching = null,
    onPinchEnd = null,
    signal
  }) {
    __privateAdd(this, _onTouchStart);
    __privateAdd(this, _onTouchMove);
    __privateAdd(this, _onTouchEnd);
    __privateAdd(this, _container2, void 0);
    __privateAdd(this, _isPinching, false);
    __privateAdd(this, _isPinchingStopped, null);
    __privateAdd(this, _isPinchingDisabled, void 0);
    __privateAdd(this, _onPinchStart, void 0);
    __privateAdd(this, _onPinching, void 0);
    __privateAdd(this, _onPinchEnd, void 0);
    __privateAdd(this, _pointerDownAC, null);
    __privateAdd(this, _signal, void 0);
    __privateAdd(this, _touchInfo, null);
    __privateAdd(this, _touchManagerAC, void 0);
    __privateAdd(this, _touchMoveAC, null);
    __privateSet(this, _container2, container);
    __privateSet(this, _isPinchingStopped, isPinchingStopped);
    __privateSet(this, _isPinchingDisabled, isPinchingDisabled);
    __privateSet(this, _onPinchStart, onPinchStart);
    __privateSet(this, _onPinching, onPinching);
    __privateSet(this, _onPinchEnd, onPinchEnd);
    __privateSet(this, _touchManagerAC, new AbortController());
    __privateSet(this, _signal, AbortSignal.any([signal, __privateGet(this, _touchManagerAC).signal]));
    container.addEventListener("touchstart", __privateMethod(this, _onTouchStart, onTouchStart_fn).bind(this), {
      passive: false,
      signal: __privateGet(this, _signal)
    });
  }
  get MIN_TOUCH_DISTANCE_TO_PINCH() {
    return 35 / OutputScale.pixelRatio;
  }
  destroy() {
    var _a3, _b2;
    (_a3 = __privateGet(this, _touchManagerAC)) == null ? void 0 : _a3.abort();
    __privateSet(this, _touchManagerAC, null);
    (_b2 = __privateGet(this, _pointerDownAC)) == null ? void 0 : _b2.abort();
    __privateSet(this, _pointerDownAC, null);
  }
};
_container2 = new WeakMap();
_isPinching = new WeakMap();
_isPinchingStopped = new WeakMap();
_isPinchingDisabled = new WeakMap();
_onPinchStart = new WeakMap();
_onPinching = new WeakMap();
_onPinchEnd = new WeakMap();
_pointerDownAC = new WeakMap();
_signal = new WeakMap();
_touchInfo = new WeakMap();
_touchManagerAC = new WeakMap();
_touchMoveAC = new WeakMap();
_onTouchStart = new WeakSet();
onTouchStart_fn = function(evt) {
  var _a3, _b2, _c;
  if ((_a3 = __privateGet(this, _isPinchingDisabled)) == null ? void 0 : _a3.call(this)) {
    return;
  }
  if (evt.touches.length === 1) {
    if (__privateGet(this, _pointerDownAC)) {
      return;
    }
    const pointerDownAC = __privateSet(this, _pointerDownAC, new AbortController());
    const signal = AbortSignal.any([__privateGet(this, _signal), pointerDownAC.signal]);
    const container = __privateGet(this, _container2);
    const opts = {
      capture: true,
      signal,
      passive: false
    };
    const cancelPointerDown = (e) => {
      var _a4;
      if (e.pointerType === "touch") {
        (_a4 = __privateGet(this, _pointerDownAC)) == null ? void 0 : _a4.abort();
        __privateSet(this, _pointerDownAC, null);
      }
    };
    container.addEventListener("pointerdown", (e) => {
      if (e.pointerType === "touch") {
        stopEvent(e);
        cancelPointerDown(e);
      }
    }, opts);
    container.addEventListener("pointerup", cancelPointerDown, opts);
    container.addEventListener("pointercancel", cancelPointerDown, opts);
    return;
  }
  if (!__privateGet(this, _touchMoveAC)) {
    __privateSet(this, _touchMoveAC, new AbortController());
    const signal = AbortSignal.any([__privateGet(this, _signal), __privateGet(this, _touchMoveAC).signal]);
    const container = __privateGet(this, _container2);
    const opt = {
      signal,
      capture: false,
      passive: false
    };
    container.addEventListener("touchmove", __privateMethod(this, _onTouchMove, onTouchMove_fn).bind(this), opt);
    const onTouchEnd = __privateMethod(this, _onTouchEnd, onTouchEnd_fn).bind(this);
    container.addEventListener("touchend", onTouchEnd, opt);
    container.addEventListener("touchcancel", onTouchEnd, opt);
    opt.capture = true;
    container.addEventListener("pointerdown", stopEvent, opt);
    container.addEventListener("pointermove", stopEvent, opt);
    container.addEventListener("pointercancel", stopEvent, opt);
    container.addEventListener("pointerup", stopEvent, opt);
    (_b2 = __privateGet(this, _onPinchStart)) == null ? void 0 : _b2.call(this);
  }
  stopEvent(evt);
  if (evt.touches.length !== 2 || ((_c = __privateGet(this, _isPinchingStopped)) == null ? void 0 : _c.call(this))) {
    __privateSet(this, _touchInfo, null);
    return;
  }
  let [touch0, touch1] = evt.touches;
  if (touch0.identifier > touch1.identifier) {
    [touch0, touch1] = [touch1, touch0];
  }
  __privateSet(this, _touchInfo, {
    touch0X: touch0.screenX,
    touch0Y: touch0.screenY,
    touch1X: touch1.screenX,
    touch1Y: touch1.screenY
  });
};
_onTouchMove = new WeakSet();
onTouchMove_fn = function(evt) {
  var _a3;
  if (!__privateGet(this, _touchInfo) || evt.touches.length !== 2) {
    return;
  }
  stopEvent(evt);
  let [touch0, touch1] = evt.touches;
  if (touch0.identifier > touch1.identifier) {
    [touch0, touch1] = [touch1, touch0];
  }
  const {
    screenX: screen0X,
    screenY: screen0Y
  } = touch0;
  const {
    screenX: screen1X,
    screenY: screen1Y
  } = touch1;
  const touchInfo = __privateGet(this, _touchInfo);
  const {
    touch0X: pTouch0X,
    touch0Y: pTouch0Y,
    touch1X: pTouch1X,
    touch1Y: pTouch1Y
  } = touchInfo;
  const prevGapX = pTouch1X - pTouch0X;
  const prevGapY = pTouch1Y - pTouch0Y;
  const currGapX = screen1X - screen0X;
  const currGapY = screen1Y - screen0Y;
  const distance = Math.hypot(currGapX, currGapY) || 1;
  const pDistance = Math.hypot(prevGapX, prevGapY) || 1;
  if (!__privateGet(this, _isPinching) && Math.abs(pDistance - distance) <= _TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {
    return;
  }
  touchInfo.touch0X = screen0X;
  touchInfo.touch0Y = screen0Y;
  touchInfo.touch1X = screen1X;
  touchInfo.touch1Y = screen1Y;
  if (!__privateGet(this, _isPinching)) {
    __privateSet(this, _isPinching, true);
    return;
  }
  const origin = [(screen0X + screen1X) / 2, (screen0Y + screen1Y) / 2];
  (_a3 = __privateGet(this, _onPinching)) == null ? void 0 : _a3.call(this, origin, pDistance, distance);
};
_onTouchEnd = new WeakSet();
onTouchEnd_fn = function(evt) {
  var _a3;
  if (evt.touches.length >= 2) {
    return;
  }
  if (__privateGet(this, _touchMoveAC)) {
    __privateGet(this, _touchMoveAC).abort();
    __privateSet(this, _touchMoveAC, null);
    (_a3 = __privateGet(this, _onPinchEnd)) == null ? void 0 : _a3.call(this);
  }
  if (!__privateGet(this, _touchInfo)) {
    return;
  }
  stopEvent(evt);
  __privateSet(this, _touchInfo, null);
  __privateSet(this, _isPinching, false);
};
var TouchManager = _TouchManager;
var _accessibilityData, _allResizerDivs, _altText3, _comment2, _disabled, _dragPointerId, _dragPointerType, _keepAspectRatio, _resizersDiv, _lastPointerCoords, _savedDimensions, _focusAC, _focusedResizerName, _hasBeenClicked, _initialRect, _isEditing, _isInEditMode, _isResizerEnabledForKeyboard, _moveInDOMTimeout, _prevDragX, _prevDragY, _telemetryTimeouts, _touchManager, _isDraggable, _zIndex, _translate, translate_fn, _rotatePoint, rotatePoint_fn, _getRotationMatrix, getRotationMatrix_fn, _createResizers, createResizers_fn, _resizerPointerdown, resizerPointerdown_fn, _resize, resize_fn, _addResizeToUndoStack, addResizeToUndoStack_fn, _resizerPointermove, resizerPointermove_fn, _touchPinchStartCallback, touchPinchStartCallback_fn, _touchPinchCallback, touchPinchCallback_fn, _touchPinchEndCallback, touchPinchEndCallback_fn, _selectOnPointerEvent, selectOnPointerEvent_fn, _setUpDragSession, setUpDragSession_fn, _addFocusListeners, addFocusListeners_fn, _resizerKeydown, resizerKeydown_fn, _resizerBlur, resizerBlur_fn, _resizerFocus, resizerFocus_fn, _setResizerTabIndex, setResizerTabIndex_fn, _stopResizing, stopResizing_fn;
var _AnnotationEditor = class _AnnotationEditor {
  constructor(parameters) {
    __privateAdd(this, _translate);
    __privateAdd(this, _getRotationMatrix);
    __privateAdd(this, _createResizers);
    __privateAdd(this, _resizerPointerdown);
    __privateAdd(this, _resize);
    __privateAdd(this, _addResizeToUndoStack);
    __privateAdd(this, _resizerPointermove);
    __privateAdd(this, _touchPinchStartCallback);
    __privateAdd(this, _touchPinchCallback);
    __privateAdd(this, _touchPinchEndCallback);
    __privateAdd(this, _selectOnPointerEvent);
    __privateAdd(this, _setUpDragSession);
    __privateAdd(this, _addFocusListeners);
    __privateAdd(this, _resizerKeydown);
    __privateAdd(this, _resizerBlur);
    __privateAdd(this, _resizerFocus);
    __privateAdd(this, _setResizerTabIndex);
    __privateAdd(this, _stopResizing);
    __privateAdd(this, _accessibilityData, null);
    __privateAdd(this, _allResizerDivs, null);
    __privateAdd(this, _altText3, null);
    __privateAdd(this, _comment2, null);
    __privateAdd(this, _disabled, false);
    __privateAdd(this, _dragPointerId, null);
    __privateAdd(this, _dragPointerType, "");
    __privateAdd(this, _keepAspectRatio, false);
    __privateAdd(this, _resizersDiv, null);
    __privateAdd(this, _lastPointerCoords, null);
    __privateAdd(this, _savedDimensions, null);
    __privateAdd(this, _focusAC, null);
    __privateAdd(this, _focusedResizerName, "");
    __privateAdd(this, _hasBeenClicked, false);
    __privateAdd(this, _initialRect, null);
    __privateAdd(this, _isEditing, false);
    __privateAdd(this, _isInEditMode, false);
    __privateAdd(this, _isResizerEnabledForKeyboard, false);
    __privateAdd(this, _moveInDOMTimeout, null);
    __privateAdd(this, _prevDragX, 0);
    __privateAdd(this, _prevDragY, 0);
    __privateAdd(this, _telemetryTimeouts, null);
    __privateAdd(this, _touchManager, null);
    __publicField(this, "isSelected", false);
    __publicField(this, "_isCopy", false);
    __publicField(this, "_editToolbar", null);
    __publicField(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
    __publicField(this, "_initialData", null);
    __publicField(this, "_isVisible", true);
    __publicField(this, "_uiManager", null);
    __publicField(this, "_focusEventsAllowed", true);
    __privateAdd(this, _isDraggable, false);
    __privateAdd(this, _zIndex, _AnnotationEditor._zIndex++);
    this.parent = parameters.parent;
    this.id = parameters.id;
    this.width = this.height = null;
    this.pageIndex = parameters.parent.pageIndex;
    this.name = parameters.name;
    this.div = null;
    this._uiManager = parameters.uiManager;
    this.annotationElementId = null;
    this._willKeepAspectRatio = false;
    this._initialOptions.isCentered = parameters.isCentered;
    this._structTreeParentId = null;
    this.annotationElementId = parameters.annotationElementId || null;
    const {
      rotation,
      rawDims: {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      }
    } = this.parent.viewport;
    this.rotation = rotation;
    this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
    this.pageDimensions = [pageWidth, pageHeight];
    this.pageTranslation = [pageX, pageY];
    const [width, height] = this.parentDimensions;
    this.x = parameters.x / width;
    this.y = parameters.y / height;
    this.isAttachedToDOM = false;
    this.deleted = false;
  }
  static get _resizerKeyboardManager() {
    const resize = _AnnotationEditor.prototype._resizeWithKeyboard;
    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
    const big = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], resize, {
      args: [-small, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], resize, {
      args: [-big, 0]
    }], [["ArrowRight", "mac+ArrowRight"], resize, {
      args: [small, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], resize, {
      args: [big, 0]
    }], [["ArrowUp", "mac+ArrowUp"], resize, {
      args: [0, -small]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], resize, {
      args: [0, -big]
    }], [["ArrowDown", "mac+ArrowDown"], resize, {
      args: [0, small]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], resize, {
      args: [0, big]
    }], [["Escape", "mac+Escape"], _AnnotationEditor.prototype._stopResizingWithKeyboard]]));
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  get mode() {
    return Object.getPrototypeOf(this).constructor._editorType;
  }
  static get isDrawer() {
    return false;
  }
  static get _defaultLineColor() {
    return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(editor) {
    const fakeEditor = new FakeEditor({
      id: editor.parent.getNextId(),
      parent: editor.parent,
      uiManager: editor._uiManager
    });
    fakeEditor.annotationElementId = editor.annotationElementId;
    fakeEditor.deleted = true;
    fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
  }
  static initialize(l10n, _uiManager5) {
    var _a3;
    (_a3 = _AnnotationEditor._l10n) != null ? _a3 : _AnnotationEditor._l10n = l10n;
    _AnnotationEditor._l10nResizer || (_AnnotationEditor._l10nResizer = Object.freeze({
      topLeft: "pdfjs-editor-resizer-top-left",
      topMiddle: "pdfjs-editor-resizer-top-middle",
      topRight: "pdfjs-editor-resizer-top-right",
      middleRight: "pdfjs-editor-resizer-middle-right",
      bottomRight: "pdfjs-editor-resizer-bottom-right",
      bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
      bottomLeft: "pdfjs-editor-resizer-bottom-left",
      middleLeft: "pdfjs-editor-resizer-middle-left"
    }));
    if (_AnnotationEditor._borderLineWidth !== -1) {
      return;
    }
    const style = getComputedStyle(document.documentElement);
    _AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(_type, _value) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(mime) {
    return false;
  }
  static paste(item, parent) {
    unreachable("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return __privateGet(this, _isDraggable);
  }
  set _isDraggable(value) {
    var _a3;
    __privateSet(this, _isDraggable, value);
    (_a3 = this.div) == null ? void 0 : _a3.classList.toggle("draggable", value);
  }
  get isEnterHandled() {
    return true;
  }
  center() {
    const [pageWidth, pageHeight] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * pageHeight / (pageWidth * 2);
        this.y += this.width * pageWidth / (pageHeight * 2);
        break;
      case 180:
        this.x += this.width / 2;
        this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * pageHeight / (pageWidth * 2);
        this.y -= this.width * pageWidth / (pageHeight * 2);
        break;
      default:
        this.x -= this.width / 2;
        this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(params) {
    this._uiManager.addCommands(params);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = __privateGet(this, _zIndex);
  }
  setParent(parent) {
    if (parent !== null) {
      this.pageIndex = parent.pageIndex;
      this.pageDimensions = parent.pageDimensions;
    } else {
      __privateMethod(this, _stopResizing, stopResizing_fn).call(this);
    }
    this.parent = parent;
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!__privateGet(this, _hasBeenClicked)) {
      this.parent.setSelected(this);
    } else {
      __privateSet(this, _hasBeenClicked, false);
    }
  }
  focusout(event) {
    var _a3;
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!this.isAttachedToDOM) {
      return;
    }
    const target = event.relatedTarget;
    if (target == null ? void 0 : target.closest(`#${this.id}`)) {
      return;
    }
    event.preventDefault();
    if (!((_a3 = this.parent) == null ? void 0 : _a3.isMultipleSelection)) {
      this.commitOrRemove();
    }
  }
  commitOrRemove() {
    if (this.isEmpty()) {
      this.remove();
    } else {
      this.commit();
    }
  }
  commit() {
    if (!this.isInEditMode()) {
      return;
    }
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(x, y, tx, ty) {
    const [width, height] = this.parentDimensions;
    [tx, ty] = this.screenToPageTranslation(tx, ty);
    this.x = (x + tx) / width;
    this.y = (y + ty) / height;
    this.fixAndSetPosition();
  }
  _moveAfterPaste(baseX, baseY) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
    this._onTranslated();
  }
  translate(x, y) {
    __privateMethod(this, _translate, translate_fn).call(this, this.parentDimensions, x, y);
  }
  translateInPage(x, y) {
    __privateGet(this, _initialRect) || __privateSet(this, _initialRect, [this.x, this.y, this.width, this.height]);
    __privateMethod(this, _translate, translate_fn).call(this, this.pageDimensions, x, y);
    this.div.scrollIntoView({
      block: "nearest"
    });
  }
  translationDone() {
    this._onTranslated(this.x, this.y);
  }
  drag(tx, ty) {
    __privateGet(this, _initialRect) || __privateSet(this, _initialRect, [this.x, this.y, this.width, this.height]);
    const {
      div,
      parentDimensions: [parentWidth, parentHeight]
    } = this;
    this.x += tx / parentWidth;
    this.y += ty / parentHeight;
    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x: x2,
        y: y2
      } = this.div.getBoundingClientRect();
      if (this.parent.findNewParent(this, x2, y2)) {
        this.x -= Math.floor(this.x);
        this.y -= Math.floor(this.y);
      }
    }
    let {
      x,
      y
    } = this;
    const [bx, by] = this.getBaseTranslation();
    x += bx;
    y += by;
    const {
      style
    } = div;
    style.left = `${(100 * x).toFixed(2)}%`;
    style.top = `${(100 * y).toFixed(2)}%`;
    this._onTranslating(x, y);
    div.scrollIntoView({
      block: "nearest"
    });
  }
  _onTranslating(x, y) {
  }
  _onTranslated(x, y) {
  }
  get _hasBeenMoved() {
    return !!__privateGet(this, _initialRect) && (__privateGet(this, _initialRect)[0] !== this.x || __privateGet(this, _initialRect)[1] !== this.y);
  }
  get _hasBeenResized() {
    return !!__privateGet(this, _initialRect) && (__privateGet(this, _initialRect)[2] !== this.width || __privateGet(this, _initialRect)[3] !== this.height);
  }
  getBaseTranslation() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const {
      _borderLineWidth
    } = _AnnotationEditor;
    const x = _borderLineWidth / parentWidth;
    const y = _borderLineWidth / parentHeight;
    switch (this.rotation) {
      case 90:
        return [-x, y];
      case 180:
        return [x, y];
      case 270:
        return [x, -y];
      default:
        return [-x, -y];
    }
  }
  get _mustFixPosition() {
    return true;
  }
  fixAndSetPosition(rotation = this.rotation) {
    const {
      div: {
        style
      },
      pageDimensions: [pageWidth, pageHeight]
    } = this;
    let {
      x,
      y,
      width,
      height
    } = this;
    width *= pageWidth;
    height *= pageHeight;
    x *= pageWidth;
    y *= pageHeight;
    if (this._mustFixPosition) {
      switch (rotation) {
        case 0:
          x = MathClamp(x, 0, pageWidth - width);
          y = MathClamp(y, 0, pageHeight - height);
          break;
        case 90:
          x = MathClamp(x, 0, pageWidth - height);
          y = MathClamp(y, width, pageHeight);
          break;
        case 180:
          x = MathClamp(x, width, pageWidth);
          y = MathClamp(y, height, pageHeight);
          break;
        case 270:
          x = MathClamp(x, height, pageWidth);
          y = MathClamp(y, 0, pageHeight - width);
          break;
      }
    }
    this.x = x /= pageWidth;
    this.y = y /= pageHeight;
    const [bx, by] = this.getBaseTranslation();
    x += bx;
    y += by;
    style.left = `${(100 * x).toFixed(2)}%`;
    style.top = `${(100 * y).toFixed(2)}%`;
    this.moveInDOM();
  }
  screenToPageTranslation(x, y) {
    var _a3;
    return __privateMethod(_a3 = _AnnotationEditor, _rotatePoint, rotatePoint_fn).call(_a3, x, y, this.parentRotation);
  }
  pageTranslationToScreen(x, y) {
    var _a3;
    return __privateMethod(_a3 = _AnnotationEditor, _rotatePoint, rotatePoint_fn).call(_a3, x, y, 360 - this.parentRotation);
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale,
      pageDimensions: [pageWidth, pageHeight]
    } = this;
    return [pageWidth * parentScale, pageHeight * parentScale];
  }
  setDims(width, height) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const {
      style
    } = this.div;
    style.width = `${(100 * width / parentWidth).toFixed(2)}%`;
    if (!__privateGet(this, _keepAspectRatio)) {
      style.height = `${(100 * height / parentHeight).toFixed(2)}%`;
    }
  }
  fixDims() {
    const {
      style
    } = this.div;
    const {
      height,
      width
    } = style;
    const widthPercent = width.endsWith("%");
    const heightPercent = !__privateGet(this, _keepAspectRatio) && height.endsWith("%");
    if (widthPercent && heightPercent) {
      return;
    }
    const [parentWidth, parentHeight] = this.parentDimensions;
    if (!widthPercent) {
      style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;
    }
    if (!__privateGet(this, _keepAspectRatio) && !heightPercent) {
      style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;
    }
  }
  getInitialTranslation() {
    return [0, 0];
  }
  _onResized() {
  }
  static _round(x) {
    return Math.round(x * 1e4) / 1e4;
  }
  _onResizing() {
  }
  altTextFinish() {
    var _a3;
    (_a3 = __privateGet(this, _altText3)) == null ? void 0 : _a3.finish();
  }
  get toolbarButtons() {
    return null;
  }
  async addEditToolbar() {
    if (this._editToolbar || __privateGet(this, _isInEditMode)) {
      return this._editToolbar;
    }
    this._editToolbar = new EditorToolbar(this);
    this.div.append(this._editToolbar.render());
    const {
      toolbarButtons
    } = this;
    if (toolbarButtons) {
      for (const [name, tool] of toolbarButtons) {
        await this._editToolbar.addButton(name, tool);
      }
    }
    this._editToolbar.addButton("comment", this.addCommentButton());
    this._editToolbar.addButton("delete");
    return this._editToolbar;
  }
  removeEditToolbar() {
    var _a3;
    if (!this._editToolbar) {
      return;
    }
    this._editToolbar.remove();
    this._editToolbar = null;
    (_a3 = __privateGet(this, _altText3)) == null ? void 0 : _a3.destroy();
  }
  addContainer(container) {
    var _a3;
    const editToolbarDiv = (_a3 = this._editToolbar) == null ? void 0 : _a3.div;
    if (editToolbarDiv) {
      editToolbarDiv.before(container);
    } else {
      this.div.append(container);
    }
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  createAltText() {
    if (!__privateGet(this, _altText3)) {
      AltText.initialize(_AnnotationEditor._l10n);
      __privateSet(this, _altText3, new AltText(this));
      if (__privateGet(this, _accessibilityData)) {
        __privateGet(this, _altText3).data = __privateGet(this, _accessibilityData);
        __privateSet(this, _accessibilityData, null);
      }
    }
    return __privateGet(this, _altText3);
  }
  get altTextData() {
    var _a3;
    return (_a3 = __privateGet(this, _altText3)) == null ? void 0 : _a3.data;
  }
  set altTextData(data) {
    if (!__privateGet(this, _altText3)) {
      return;
    }
    __privateGet(this, _altText3).data = data;
  }
  get guessedAltText() {
    var _a3;
    return (_a3 = __privateGet(this, _altText3)) == null ? void 0 : _a3.guessedText;
  }
  async setGuessedAltText(text) {
    var _a3;
    await ((_a3 = __privateGet(this, _altText3)) == null ? void 0 : _a3.setGuessedText(text));
  }
  serializeAltText(isForCopying) {
    var _a3;
    return (_a3 = __privateGet(this, _altText3)) == null ? void 0 : _a3.serialize(isForCopying);
  }
  hasAltText() {
    return !!__privateGet(this, _altText3) && !__privateGet(this, _altText3).isEmpty();
  }
  hasAltTextData() {
    var _a3, _b2;
    return (_b2 = (_a3 = __privateGet(this, _altText3)) == null ? void 0 : _a3.hasData()) != null ? _b2 : false;
  }
  addCommentButton() {
    if (__privateGet(this, _comment2)) {
      return __privateGet(this, _comment2);
    }
    return __privateSet(this, _comment2, new Comment(this));
  }
  get commentColor() {
    return null;
  }
  get comment() {
    const comment = __privateGet(this, _comment2);
    return {
      text: comment.data.text,
      date: comment.data.date,
      deleted: comment.isDeleted(),
      color: this.commentColor
    };
  }
  set comment(text) {
    if (!__privateGet(this, _comment2)) {
      __privateSet(this, _comment2, new Comment(this));
    }
    __privateGet(this, _comment2).data = text;
  }
  setCommentData(text) {
    if (!__privateGet(this, _comment2)) {
      __privateSet(this, _comment2, new Comment(this));
    }
    __privateGet(this, _comment2).setInitialText(text);
  }
  get hasEditedComment() {
    var _a3;
    return (_a3 = __privateGet(this, _comment2)) == null ? void 0 : _a3.hasBeenEdited();
  }
  async editComment() {
    if (!__privateGet(this, _comment2)) {
      __privateSet(this, _comment2, new Comment(this));
    }
    __privateGet(this, _comment2).edit();
  }
  addComment(serialized) {
    if (this.hasEditedComment) {
      const DEFAULT_POPUP_WIDTH = 180;
      const DEFAULT_POPUP_HEIGHT = 100;
      const [, , , trY] = serialized.rect;
      const [pageWidth] = this.pageDimensions;
      const [pageX] = this.pageTranslation;
      const blX = pageX + pageWidth + 1;
      const blY = trY - DEFAULT_POPUP_HEIGHT;
      const trX = blX + DEFAULT_POPUP_WIDTH;
      serialized.popup = {
        contents: this.comment.text,
        deleted: this.comment.deleted,
        rect: [blX, blY, trX, trY]
      };
    }
  }
  render() {
    var _a3;
    const div = this.div = document.createElement("div");
    div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
    div.className = this.name;
    div.setAttribute("id", this.id);
    div.tabIndex = __privateGet(this, _disabled) ? -1 : 0;
    div.setAttribute("role", "application");
    if (this.defaultL10nId) {
      div.setAttribute("data-l10n-id", this.defaultL10nId);
    }
    if (!this._isVisible) {
      div.classList.add("hidden");
    }
    this.setInForeground();
    __privateMethod(this, _addFocusListeners, addFocusListeners_fn).call(this);
    const [parentWidth, parentHeight] = this.parentDimensions;
    if (this.parentRotation % 180 !== 0) {
      div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
      div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
    }
    const [tx, ty] = this.getInitialTranslation();
    this.translate(tx, ty);
    bindEvents(this, div, ["keydown", "pointerdown", "dblclick"]);
    if (this.isResizable && this._uiManager._supportsPinchToZoom) {
      __privateGet(this, _touchManager) || __privateSet(this, _touchManager, new TouchManager({
        container: div,
        isPinchingDisabled: () => !this.isSelected,
        onPinchStart: __privateMethod(this, _touchPinchStartCallback, touchPinchStartCallback_fn).bind(this),
        onPinching: __privateMethod(this, _touchPinchCallback, touchPinchCallback_fn).bind(this),
        onPinchEnd: __privateMethod(this, _touchPinchEndCallback, touchPinchEndCallback_fn).bind(this),
        signal: this._uiManager._signal
      }));
    }
    (_a3 = this._uiManager._editorUndoBar) == null ? void 0 : _a3.hide();
    return div;
  }
  pointerdown(event) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      event.preventDefault();
      return;
    }
    __privateSet(this, _hasBeenClicked, true);
    if (this._isDraggable) {
      __privateMethod(this, _setUpDragSession, setUpDragSession_fn).call(this, event);
      return;
    }
    __privateMethod(this, _selectOnPointerEvent, selectOnPointerEvent_fn).call(this, event);
  }
  _onStartDragging() {
  }
  _onStopDragging() {
  }
  moveInDOM() {
    if (__privateGet(this, _moveInDOMTimeout)) {
      clearTimeout(__privateGet(this, _moveInDOMTimeout));
    }
    __privateSet(this, _moveInDOMTimeout, setTimeout(() => {
      var _a3;
      __privateSet(this, _moveInDOMTimeout, null);
      (_a3 = this.parent) == null ? void 0 : _a3.moveEditorInDOM(this);
    }, 0));
  }
  _setParentAndPosition(parent, x, y) {
    parent.changeParent(this);
    this.x = x;
    this.y = y;
    this.fixAndSetPosition();
    this._onTranslated();
  }
  getRect(tx, ty, rotation = this.rotation) {
    const scale = this.parentScale;
    const [pageWidth, pageHeight] = this.pageDimensions;
    const [pageX, pageY] = this.pageTranslation;
    const shiftX = tx / scale;
    const shiftY = ty / scale;
    const x = this.x * pageWidth;
    const y = this.y * pageHeight;
    const width = this.width * pageWidth;
    const height = this.height * pageHeight;
    switch (rotation) {
      case 0:
        return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];
      case 90:
        return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];
      case 180:
        return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];
      case 270:
        return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(rect, pageHeight) {
    const [x1, y1, x2, y2] = rect;
    const width = x2 - x1;
    const height = y2 - y1;
    switch (this.rotation) {
      case 0:
        return [x1, pageHeight - y2, width, height];
      case 90:
        return [x1, pageHeight - y1, height, width];
      case 180:
        return [x2, pageHeight - y1, width, height];
      case 270:
        return [x2, pageHeight - y2, height, width];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getPDFRect() {
    return this.getRect(0, 0);
  }
  onceAdded(focus) {
  }
  isEmpty() {
    return false;
  }
  enableEditMode() {
    if (this.isInEditMode()) {
      return false;
    }
    this.parent.setEditingState(false);
    __privateSet(this, _isInEditMode, true);
    return true;
  }
  disableEditMode() {
    if (!this.isInEditMode()) {
      return false;
    }
    this.parent.setEditingState(true);
    __privateSet(this, _isInEditMode, false);
    return true;
  }
  isInEditMode() {
    return __privateGet(this, _isInEditMode);
  }
  shouldGetKeyboardEvents() {
    return __privateGet(this, _isResizerEnabledForKeyboard);
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  get isOnScreen() {
    const {
      top,
      left,
      bottom,
      right
    } = this.getClientDimensions();
    const {
      innerHeight,
      innerWidth
    } = window;
    return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;
  }
  rebuild() {
    __privateMethod(this, _addFocusListeners, addFocusListeners_fn).call(this);
  }
  rotate(_angle) {
  }
  resize() {
  }
  serializeDeleted() {
    var _a3;
    return {
      id: this.annotationElementId,
      deleted: true,
      pageIndex: this.pageIndex,
      popupRef: ((_a3 = this._initialData) == null ? void 0 : _a3.popupRef) || ""
    };
  }
  serialize(isForCopying = false, context = null) {
    unreachable("An editor must be serializable");
  }
  static async deserialize(data, parent, uiManager) {
    const editor = new this.prototype.constructor({
      parent,
      id: parent.getNextId(),
      uiManager,
      annotationElementId: data.annotationElementId
    });
    editor.rotation = data.rotation;
    __privateSet(editor, _accessibilityData, data.accessibilityData);
    editor._isCopy = data.isCopy || false;
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
    editor.x = x / pageWidth;
    editor.y = y / pageHeight;
    editor.width = width / pageWidth;
    editor.height = height / pageHeight;
    return editor;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    var _a3, _b2;
    (_a3 = __privateGet(this, _focusAC)) == null ? void 0 : _a3.abort();
    __privateSet(this, _focusAC, null);
    if (!this.isEmpty()) {
      this.commit();
    }
    if (this.parent) {
      this.parent.remove(this);
    } else {
      this._uiManager.removeEditor(this);
    }
    if (__privateGet(this, _moveInDOMTimeout)) {
      clearTimeout(__privateGet(this, _moveInDOMTimeout));
      __privateSet(this, _moveInDOMTimeout, null);
    }
    __privateMethod(this, _stopResizing, stopResizing_fn).call(this);
    this.removeEditToolbar();
    if (__privateGet(this, _telemetryTimeouts)) {
      for (const timeout of __privateGet(this, _telemetryTimeouts).values()) {
        clearTimeout(timeout);
      }
      __privateSet(this, _telemetryTimeouts, null);
    }
    this.parent = null;
    (_b2 = __privateGet(this, _touchManager)) == null ? void 0 : _b2.destroy();
    __privateSet(this, _touchManager, null);
  }
  get isResizable() {
    return false;
  }
  makeResizable() {
    if (this.isResizable) {
      __privateMethod(this, _createResizers, createResizers_fn).call(this);
      __privateGet(this, _resizersDiv).classList.remove("hidden");
    }
  }
  get toolbarPosition() {
    return null;
  }
  keydown(event) {
    if (!this.isResizable || event.target !== this.div || event.key !== "Enter") {
      return;
    }
    this._uiManager.setSelected(this);
    __privateSet(this, _savedDimensions, {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    });
    const children = __privateGet(this, _resizersDiv).children;
    if (!__privateGet(this, _allResizerDivs)) {
      __privateSet(this, _allResizerDivs, Array.from(children));
      const boundResizerKeydown = __privateMethod(this, _resizerKeydown, resizerKeydown_fn).bind(this);
      const boundResizerBlur = __privateMethod(this, _resizerBlur, resizerBlur_fn).bind(this);
      const signal = this._uiManager._signal;
      for (const div of __privateGet(this, _allResizerDivs)) {
        const name = div.getAttribute("data-resizer-name");
        div.setAttribute("role", "spinbutton");
        div.addEventListener("keydown", boundResizerKeydown, {
          signal
        });
        div.addEventListener("blur", boundResizerBlur, {
          signal
        });
        div.addEventListener("focus", __privateMethod(this, _resizerFocus, resizerFocus_fn).bind(this, name), {
          signal
        });
        div.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[name]);
      }
    }
    const first = __privateGet(this, _allResizerDivs)[0];
    let firstPosition = 0;
    for (const div of children) {
      if (div === first) {
        break;
      }
      firstPosition++;
    }
    const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (__privateGet(this, _allResizerDivs).length / 4);
    if (nextFirstPosition !== firstPosition) {
      if (nextFirstPosition < firstPosition) {
        for (let i2 = 0; i2 < firstPosition - nextFirstPosition; i2++) {
          __privateGet(this, _resizersDiv).append(__privateGet(this, _resizersDiv).firstChild);
        }
      } else if (nextFirstPosition > firstPosition) {
        for (let i2 = 0; i2 < nextFirstPosition - firstPosition; i2++) {
          __privateGet(this, _resizersDiv).firstChild.before(__privateGet(this, _resizersDiv).lastChild);
        }
      }
      let i = 0;
      for (const child of children) {
        const div = __privateGet(this, _allResizerDivs)[i++];
        const name = div.getAttribute("data-resizer-name");
        child.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[name]);
      }
    }
    __privateMethod(this, _setResizerTabIndex, setResizerTabIndex_fn).call(this, 0);
    __privateSet(this, _isResizerEnabledForKeyboard, true);
    __privateGet(this, _resizersDiv).firstChild.focus({
      focusVisible: true
    });
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  _resizeWithKeyboard(x, y) {
    if (!__privateGet(this, _isResizerEnabledForKeyboard)) {
      return;
    }
    __privateMethod(this, _resizerPointermove, resizerPointermove_fn).call(this, __privateGet(this, _focusedResizerName), {
      deltaX: x,
      deltaY: y,
      fromKeyboard: true
    });
  }
  _stopResizingWithKeyboard() {
    __privateMethod(this, _stopResizing, stopResizing_fn).call(this);
    this.div.focus();
  }
  select() {
    var _a3, _b2, _c;
    if (this.isSelected && this._editToolbar) {
      return;
    }
    this.isSelected = true;
    this.makeResizable();
    (_a3 = this.div) == null ? void 0 : _a3.classList.add("selectedEditor");
    if (!this._editToolbar) {
      this.addEditToolbar().then(() => {
        var _a4, _b3;
        if ((_a4 = this.div) == null ? void 0 : _a4.classList.contains("selectedEditor")) {
          (_b3 = this._editToolbar) == null ? void 0 : _b3.show();
        }
      });
      return;
    }
    (_b2 = this._editToolbar) == null ? void 0 : _b2.show();
    (_c = __privateGet(this, _altText3)) == null ? void 0 : _c.toggleAltTextBadge(false);
  }
  unselect() {
    var _a3, _b2, _c, _d, _e;
    if (!this.isSelected) {
      return;
    }
    this.isSelected = false;
    (_a3 = __privateGet(this, _resizersDiv)) == null ? void 0 : _a3.classList.add("hidden");
    (_b2 = this.div) == null ? void 0 : _b2.classList.remove("selectedEditor");
    if ((_c = this.div) == null ? void 0 : _c.contains(document.activeElement)) {
      this._uiManager.currentLayer.div.focus({
        preventScroll: true
      });
    }
    (_d = this._editToolbar) == null ? void 0 : _d.hide();
    (_e = __privateGet(this, _altText3)) == null ? void 0 : _e.toggleAltTextBadge(true);
  }
  updateParams(type, value) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  get canChangeContent() {
    return false;
  }
  enterInEditMode() {
    if (!this.canChangeContent) {
      return;
    }
    this.enableEditMode();
    this.div.focus();
  }
  dblclick(event) {
    this.enterInEditMode();
    this.parent.updateToolbar({
      mode: this.constructor._editorType,
      editId: this.id
    });
  }
  getElementForAltText() {
    return this.div;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return __privateGet(this, _isEditing);
  }
  set isEditing(value) {
    __privateSet(this, _isEditing, value);
    if (!this.parent) {
      return;
    }
    if (value) {
      this.parent.setSelected(this);
      this.parent.setActiveEditor(this);
    } else {
      this.parent.setActiveEditor(null);
    }
  }
  setAspectRatio(width, height) {
    __privateSet(this, _keepAspectRatio, true);
    const aspectRatio = width / height;
    const {
      style
    } = this.div;
    style.aspectRatio = aspectRatio;
    style.height = "auto";
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return true;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(data, mustWait = false) {
    if (mustWait) {
      __privateGet(this, _telemetryTimeouts) || __privateSet(this, _telemetryTimeouts, /* @__PURE__ */ new Map());
      const {
        action
      } = data;
      let timeout = __privateGet(this, _telemetryTimeouts).get(action);
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        this._reportTelemetry(data);
        __privateGet(this, _telemetryTimeouts).delete(action);
        if (__privateGet(this, _telemetryTimeouts).size === 0) {
          __privateSet(this, _telemetryTimeouts, null);
        }
      }, _AnnotationEditor._telemetryTimeout);
      __privateGet(this, _telemetryTimeouts).set(action, timeout);
      return;
    }
    data.type || (data.type = this.editorType);
    this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data
      }
    });
  }
  show(visible = this._isVisible) {
    this.div.classList.toggle("hidden", !visible);
    this._isVisible = visible;
  }
  enable() {
    if (this.div) {
      this.div.tabIndex = 0;
    }
    __privateSet(this, _disabled, false);
  }
  disable() {
    if (this.div) {
      this.div.tabIndex = -1;
    }
    __privateSet(this, _disabled, true);
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    let content = annotation.container.querySelector(".annotationContent");
    if (!content) {
      content = document.createElement("div");
      content.classList.add("annotationContent", this.editorType);
      annotation.container.prepend(content);
    } else if (content.nodeName === "CANVAS") {
      const canvas = content;
      content = document.createElement("div");
      content.classList.add("annotationContent", this.editorType);
      canvas.before(content);
    }
    return content;
  }
  resetAnnotationElement(annotation) {
    const {
      firstChild
    } = annotation.container;
    if ((firstChild == null ? void 0 : firstChild.nodeName) === "DIV" && firstChild.classList.contains("annotationContent")) {
      firstChild.remove();
    }
  }
};
_accessibilityData = new WeakMap();
_allResizerDivs = new WeakMap();
_altText3 = new WeakMap();
_comment2 = new WeakMap();
_disabled = new WeakMap();
_dragPointerId = new WeakMap();
_dragPointerType = new WeakMap();
_keepAspectRatio = new WeakMap();
_resizersDiv = new WeakMap();
_lastPointerCoords = new WeakMap();
_savedDimensions = new WeakMap();
_focusAC = new WeakMap();
_focusedResizerName = new WeakMap();
_hasBeenClicked = new WeakMap();
_initialRect = new WeakMap();
_isEditing = new WeakMap();
_isInEditMode = new WeakMap();
_isResizerEnabledForKeyboard = new WeakMap();
_moveInDOMTimeout = new WeakMap();
_prevDragX = new WeakMap();
_prevDragY = new WeakMap();
_telemetryTimeouts = new WeakMap();
_touchManager = new WeakMap();
_isDraggable = new WeakMap();
_zIndex = new WeakMap();
_translate = new WeakSet();
translate_fn = function([width, height], x, y) {
  [x, y] = this.screenToPageTranslation(x, y);
  this.x += x / width;
  this.y += y / height;
  this._onTranslating(this.x, this.y);
  this.fixAndSetPosition();
};
_rotatePoint = new WeakSet();
rotatePoint_fn = function(x, y, angle) {
  switch (angle) {
    case 90:
      return [y, -x];
    case 180:
      return [-x, -y];
    case 270:
      return [-y, x];
    default:
      return [x, y];
  }
};
_getRotationMatrix = new WeakSet();
getRotationMatrix_fn = function(rotation) {
  switch (rotation) {
    case 90: {
      const [pageWidth, pageHeight] = this.pageDimensions;
      return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
    }
    case 180:
      return [-1, 0, 0, -1];
    case 270: {
      const [pageWidth, pageHeight] = this.pageDimensions;
      return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
    }
    default:
      return [1, 0, 0, 1];
  }
};
_createResizers = new WeakSet();
createResizers_fn = function() {
  if (__privateGet(this, _resizersDiv)) {
    return;
  }
  __privateSet(this, _resizersDiv, document.createElement("div"));
  __privateGet(this, _resizersDiv).classList.add("resizers");
  const classes = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"];
  const signal = this._uiManager._signal;
  for (const name of classes) {
    const div = document.createElement("div");
    __privateGet(this, _resizersDiv).append(div);
    div.classList.add("resizer", name);
    div.setAttribute("data-resizer-name", name);
    div.addEventListener("pointerdown", __privateMethod(this, _resizerPointerdown, resizerPointerdown_fn).bind(this, name), {
      signal
    });
    div.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    div.tabIndex = -1;
  }
  this.div.prepend(__privateGet(this, _resizersDiv));
};
_resizerPointerdown = new WeakSet();
resizerPointerdown_fn = function(name, event) {
  var _a3;
  event.preventDefault();
  const {
    isMac
  } = util_FeatureTest.platform;
  if (event.button !== 0 || event.ctrlKey && isMac) {
    return;
  }
  (_a3 = __privateGet(this, _altText3)) == null ? void 0 : _a3.toggle(false);
  const savedDraggable = this._isDraggable;
  this._isDraggable = false;
  __privateSet(this, _lastPointerCoords, [event.screenX, event.screenY]);
  const ac = new AbortController();
  const signal = this._uiManager.combinedSignal(ac);
  this.parent.togglePointerEvents(false);
  window.addEventListener("pointermove", __privateMethod(this, _resizerPointermove, resizerPointermove_fn).bind(this, name), {
    passive: true,
    capture: true,
    signal
  });
  window.addEventListener("touchmove", stopEvent, {
    passive: false,
    signal
  });
  window.addEventListener("contextmenu", noContextMenu, {
    signal
  });
  __privateSet(this, _savedDimensions, {
    savedX: this.x,
    savedY: this.y,
    savedWidth: this.width,
    savedHeight: this.height
  });
  const savedParentCursor = this.parent.div.style.cursor;
  const savedCursor = this.div.style.cursor;
  this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
  const pointerUpCallback = () => {
    var _a4;
    ac.abort();
    this.parent.togglePointerEvents(true);
    (_a4 = __privateGet(this, _altText3)) == null ? void 0 : _a4.toggle(true);
    this._isDraggable = savedDraggable;
    this.parent.div.style.cursor = savedParentCursor;
    this.div.style.cursor = savedCursor;
    __privateMethod(this, _addResizeToUndoStack, addResizeToUndoStack_fn).call(this);
  };
  window.addEventListener("pointerup", pointerUpCallback, {
    signal
  });
  window.addEventListener("blur", pointerUpCallback, {
    signal
  });
};
_resize = new WeakSet();
resize_fn = function(x, y, width, height) {
  this.width = width;
  this.height = height;
  this.x = x;
  this.y = y;
  const [parentWidth, parentHeight] = this.parentDimensions;
  this.setDims(parentWidth * width, parentHeight * height);
  this.fixAndSetPosition();
  this._onResized();
};
_addResizeToUndoStack = new WeakSet();
addResizeToUndoStack_fn = function() {
  if (!__privateGet(this, _savedDimensions)) {
    return;
  }
  const {
    savedX,
    savedY,
    savedWidth,
    savedHeight
  } = __privateGet(this, _savedDimensions);
  __privateSet(this, _savedDimensions, null);
  const newX = this.x;
  const newY = this.y;
  const newWidth = this.width;
  const newHeight = this.height;
  if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
    return;
  }
  this.addCommands({
    cmd: __privateMethod(this, _resize, resize_fn).bind(this, newX, newY, newWidth, newHeight),
    undo: __privateMethod(this, _resize, resize_fn).bind(this, savedX, savedY, savedWidth, savedHeight),
    mustExec: true
  });
};
_resizerPointermove = new WeakSet();
resizerPointermove_fn = function(name, event) {
  const [parentWidth, parentHeight] = this.parentDimensions;
  const savedX = this.x;
  const savedY = this.y;
  const savedWidth = this.width;
  const savedHeight = this.height;
  const minWidth = _AnnotationEditor.MIN_SIZE / parentWidth;
  const minHeight = _AnnotationEditor.MIN_SIZE / parentHeight;
  const rotationMatrix = __privateMethod(this, _getRotationMatrix, getRotationMatrix_fn).call(this, this.rotation);
  const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
  const invRotationMatrix = __privateMethod(this, _getRotationMatrix, getRotationMatrix_fn).call(this, 360 - this.rotation);
  const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];
  let getPoint;
  let getOpposite;
  let isDiagonal = false;
  let isHorizontal = false;
  switch (name) {
    case "topLeft":
      isDiagonal = true;
      getPoint = (w, h) => [0, 0];
      getOpposite = (w, h) => [w, h];
      break;
    case "topMiddle":
      getPoint = (w, h) => [w / 2, 0];
      getOpposite = (w, h) => [w / 2, h];
      break;
    case "topRight":
      isDiagonal = true;
      getPoint = (w, h) => [w, 0];
      getOpposite = (w, h) => [0, h];
      break;
    case "middleRight":
      isHorizontal = true;
      getPoint = (w, h) => [w, h / 2];
      getOpposite = (w, h) => [0, h / 2];
      break;
    case "bottomRight":
      isDiagonal = true;
      getPoint = (w, h) => [w, h];
      getOpposite = (w, h) => [0, 0];
      break;
    case "bottomMiddle":
      getPoint = (w, h) => [w / 2, h];
      getOpposite = (w, h) => [w / 2, 0];
      break;
    case "bottomLeft":
      isDiagonal = true;
      getPoint = (w, h) => [0, h];
      getOpposite = (w, h) => [w, 0];
      break;
    case "middleLeft":
      isHorizontal = true;
      getPoint = (w, h) => [0, h / 2];
      getOpposite = (w, h) => [w, h / 2];
      break;
  }
  const point = getPoint(savedWidth, savedHeight);
  const oppositePoint = getOpposite(savedWidth, savedHeight);
  let transfOppositePoint = transf(...oppositePoint);
  const oppositeX = _AnnotationEditor._round(savedX + transfOppositePoint[0]);
  const oppositeY = _AnnotationEditor._round(savedY + transfOppositePoint[1]);
  let ratioX = 1;
  let ratioY = 1;
  let deltaX, deltaY;
  if (!event.fromKeyboard) {
    const {
      screenX,
      screenY
    } = event;
    const [lastScreenX, lastScreenY] = __privateGet(this, _lastPointerCoords);
    [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);
    __privateGet(this, _lastPointerCoords)[0] = screenX;
    __privateGet(this, _lastPointerCoords)[1] = screenY;
  } else {
    ({
      deltaX,
      deltaY
    } = event);
  }
  [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
  if (isDiagonal) {
    const oldDiag = Math.hypot(savedWidth, savedHeight);
    ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
  } else if (isHorizontal) {
    ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;
  } else {
    ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;
  }
  const newWidth = _AnnotationEditor._round(savedWidth * ratioX);
  const newHeight = _AnnotationEditor._round(savedHeight * ratioY);
  transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
  const newX = oppositeX - transfOppositePoint[0];
  const newY = oppositeY - transfOppositePoint[1];
  __privateGet(this, _initialRect) || __privateSet(this, _initialRect, [this.x, this.y, this.width, this.height]);
  this.width = newWidth;
  this.height = newHeight;
  this.x = newX;
  this.y = newY;
  this.setDims(parentWidth * newWidth, parentHeight * newHeight);
  this.fixAndSetPosition();
  this._onResizing();
};
_touchPinchStartCallback = new WeakSet();
touchPinchStartCallback_fn = function() {
  var _a3;
  __privateSet(this, _savedDimensions, {
    savedX: this.x,
    savedY: this.y,
    savedWidth: this.width,
    savedHeight: this.height
  });
  (_a3 = __privateGet(this, _altText3)) == null ? void 0 : _a3.toggle(false);
  this.parent.togglePointerEvents(false);
};
_touchPinchCallback = new WeakSet();
touchPinchCallback_fn = function(_origin, prevDistance, distance) {
  const slowDownFactor = 0.7;
  let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;
  if (factor === 1) {
    return;
  }
  const rotationMatrix = __privateMethod(this, _getRotationMatrix, getRotationMatrix_fn).call(this, this.rotation);
  const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
  const [parentWidth, parentHeight] = this.parentDimensions;
  const savedX = this.x;
  const savedY = this.y;
  const savedWidth = this.width;
  const savedHeight = this.height;
  const minWidth = _AnnotationEditor.MIN_SIZE / parentWidth;
  const minHeight = _AnnotationEditor.MIN_SIZE / parentHeight;
  factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
  const newWidth = _AnnotationEditor._round(savedWidth * factor);
  const newHeight = _AnnotationEditor._round(savedHeight * factor);
  if (newWidth === savedWidth && newHeight === savedHeight) {
    return;
  }
  __privateGet(this, _initialRect) || __privateSet(this, _initialRect, [savedX, savedY, savedWidth, savedHeight]);
  const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);
  const centerX = _AnnotationEditor._round(savedX + transfCenterPoint[0]);
  const centerY = _AnnotationEditor._round(savedY + transfCenterPoint[1]);
  const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);
  this.x = centerX - newTransfCenterPoint[0];
  this.y = centerY - newTransfCenterPoint[1];
  this.width = newWidth;
  this.height = newHeight;
  this.setDims(parentWidth * newWidth, parentHeight * newHeight);
  this.fixAndSetPosition();
  this._onResizing();
};
_touchPinchEndCallback = new WeakSet();
touchPinchEndCallback_fn = function() {
  var _a3;
  (_a3 = __privateGet(this, _altText3)) == null ? void 0 : _a3.toggle(true);
  this.parent.togglePointerEvents(true);
  __privateMethod(this, _addResizeToUndoStack, addResizeToUndoStack_fn).call(this);
};
_selectOnPointerEvent = new WeakSet();
selectOnPointerEvent_fn = function(event) {
  const {
    isMac
  } = util_FeatureTest.platform;
  if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
    this.parent.toggleSelected(this);
  } else {
    this.parent.setSelected(this);
  }
};
_setUpDragSession = new WeakSet();
setUpDragSession_fn = function(event) {
  const {
    isSelected
  } = this;
  this._uiManager.setUpDragSession();
  let hasDraggingStarted = false;
  const ac = new AbortController();
  const signal = this._uiManager.combinedSignal(ac);
  const opts = {
    capture: true,
    passive: false,
    signal
  };
  const cancelDrag = (e) => {
    ac.abort();
    __privateSet(this, _dragPointerId, null);
    __privateSet(this, _hasBeenClicked, false);
    if (!this._uiManager.endDragSession()) {
      __privateMethod(this, _selectOnPointerEvent, selectOnPointerEvent_fn).call(this, e);
    }
    if (hasDraggingStarted) {
      this._onStopDragging();
    }
  };
  if (isSelected) {
    __privateSet(this, _prevDragX, event.clientX);
    __privateSet(this, _prevDragY, event.clientY);
    __privateSet(this, _dragPointerId, event.pointerId);
    __privateSet(this, _dragPointerType, event.pointerType);
    window.addEventListener("pointermove", (e) => {
      if (!hasDraggingStarted) {
        hasDraggingStarted = true;
        this._onStartDragging();
      }
      const {
        clientX: x,
        clientY: y,
        pointerId
      } = e;
      if (pointerId !== __privateGet(this, _dragPointerId)) {
        stopEvent(e);
        return;
      }
      const [tx, ty] = this.screenToPageTranslation(x - __privateGet(this, _prevDragX), y - __privateGet(this, _prevDragY));
      __privateSet(this, _prevDragX, x);
      __privateSet(this, _prevDragY, y);
      this._uiManager.dragSelectedEditors(tx, ty);
    }, opts);
    window.addEventListener("touchmove", stopEvent, opts);
    window.addEventListener("pointerdown", (e) => {
      if (e.pointerType === __privateGet(this, _dragPointerType)) {
        if (__privateGet(this, _touchManager) || e.isPrimary) {
          cancelDrag(e);
        }
      }
      stopEvent(e);
    }, opts);
  }
  const pointerUpCallback = (e) => {
    if (!__privateGet(this, _dragPointerId) || __privateGet(this, _dragPointerId) === e.pointerId) {
      cancelDrag(e);
      return;
    }
    stopEvent(e);
  };
  window.addEventListener("pointerup", pointerUpCallback, {
    signal
  });
  window.addEventListener("blur", pointerUpCallback, {
    signal
  });
};
_addFocusListeners = new WeakSet();
addFocusListeners_fn = function() {
  if (__privateGet(this, _focusAC) || !this.div) {
    return;
  }
  __privateSet(this, _focusAC, new AbortController());
  const signal = this._uiManager.combinedSignal(__privateGet(this, _focusAC));
  this.div.addEventListener("focusin", this.focusin.bind(this), {
    signal
  });
  this.div.addEventListener("focusout", this.focusout.bind(this), {
    signal
  });
};
_resizerKeydown = new WeakSet();
resizerKeydown_fn = function(event) {
  _AnnotationEditor._resizerKeyboardManager.exec(this, event);
};
_resizerBlur = new WeakSet();
resizerBlur_fn = function(event) {
  var _a3;
  if (__privateGet(this, _isResizerEnabledForKeyboard) && ((_a3 = event.relatedTarget) == null ? void 0 : _a3.parentNode) !== __privateGet(this, _resizersDiv)) {
    __privateMethod(this, _stopResizing, stopResizing_fn).call(this);
  }
};
_resizerFocus = new WeakSet();
resizerFocus_fn = function(name) {
  __privateSet(this, _focusedResizerName, __privateGet(this, _isResizerEnabledForKeyboard) ? name : "");
};
_setResizerTabIndex = new WeakSet();
setResizerTabIndex_fn = function(value) {
  if (!__privateGet(this, _allResizerDivs)) {
    return;
  }
  for (const div of __privateGet(this, _allResizerDivs)) {
    div.tabIndex = value;
  }
};
_stopResizing = new WeakSet();
stopResizing_fn = function() {
  __privateSet(this, _isResizerEnabledForKeyboard, false);
  __privateMethod(this, _setResizerTabIndex, setResizerTabIndex_fn).call(this, -1);
  __privateMethod(this, _addResizeToUndoStack, addResizeToUndoStack_fn).call(this);
};
__privateAdd(_AnnotationEditor, _rotatePoint);
__publicField(_AnnotationEditor, "_l10n", null);
__publicField(_AnnotationEditor, "_l10nResizer", null);
__publicField(_AnnotationEditor, "_borderLineWidth", -1);
__publicField(_AnnotationEditor, "_colorManager", new ColorManager());
__publicField(_AnnotationEditor, "_zIndex", 1);
__publicField(_AnnotationEditor, "_telemetryTimeout", 1e3);
var AnnotationEditor = _AnnotationEditor;
var FakeEditor = class extends AnnotationEditor {
  constructor(params) {
    super(params);
    this.annotationElementId = params.annotationElementId;
    this.deleted = true;
  }
  serialize() {
    return this.serializeDeleted();
  }
};
var SEED = 3285377520;
var MASK_HIGH = 4294901760;
var MASK_LOW = 65535;
var MurmurHash3_64 = class {
  constructor(seed) {
    this.h1 = seed ? seed & 4294967295 : SEED;
    this.h2 = seed ? seed & 4294967295 : SEED;
  }
  update(input) {
    let data, length;
    if (typeof input === "string") {
      data = new Uint8Array(input.length * 2);
      length = 0;
      for (let i = 0, ii = input.length; i < ii; i++) {
        const code = input.charCodeAt(i);
        if (code <= 255) {
          data[length++] = code;
        } else {
          data[length++] = code >>> 8;
          data[length++] = code & 255;
        }
      }
    } else if (ArrayBuffer.isView(input)) {
      data = input.slice();
      length = data.byteLength;
    } else {
      throw new Error("Invalid data format, must be a string or TypedArray.");
    }
    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
    let k1 = 0, k2 = 0;
    let h1 = this.h1, h2 = this.h2;
    const C1 = 3432918353, C2 = 461845907;
    const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
    for (let i = 0; i < blockCounts; i++) {
      if (i & 1) {
        k1 = dataUint32[i];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 3864292196;
      } else {
        k2 = dataUint32[i];
        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
        k2 = k2 << 15 | k2 >>> 17;
        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
        h2 ^= k2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = h2 * 5 + 3864292196;
      }
    }
    k1 = 0;
    switch (tailLength) {
      case 3:
        k1 ^= data[blockCounts * 4 + 2] << 16;
      case 2:
        k1 ^= data[blockCounts * 4 + 1] << 8;
      case 1:
        k1 ^= data[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h2 ^= k1;
        }
    }
    this.h1 = h1;
    this.h2 = h2;
  }
  hexdigest() {
    let h1 = this.h1, h2 = this.h2;
    h1 ^= h2 >>> 1;
    h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
    h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
    h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
  }
};
var SerializableEmpty = Object.freeze({
  map: null,
  hash: "",
  transfer: void 0
});
var _modified, _modifiedIds, _storage, _setModified, setModified_fn;
var AnnotationStorage = class {
  constructor() {
    __privateAdd(this, _setModified);
    __privateAdd(this, _modified, false);
    __privateAdd(this, _modifiedIds, null);
    __privateAdd(this, _storage, /* @__PURE__ */ new Map());
    this.onSetModified = null;
    this.onResetModified = null;
    this.onAnnotationEditor = null;
  }
  getValue(key, defaultValue) {
    const value = __privateGet(this, _storage).get(key);
    if (value === void 0) {
      return defaultValue;
    }
    return Object.assign(defaultValue, value);
  }
  getRawValue(key) {
    return __privateGet(this, _storage).get(key);
  }
  remove(key) {
    __privateGet(this, _storage).delete(key);
    if (__privateGet(this, _storage).size === 0) {
      this.resetModified();
    }
    if (typeof this.onAnnotationEditor === "function") {
      for (const value of __privateGet(this, _storage).values()) {
        if (value instanceof AnnotationEditor) {
          return;
        }
      }
      this.onAnnotationEditor(null);
    }
  }
  setValue(key, value) {
    const obj = __privateGet(this, _storage).get(key);
    let modified = false;
    if (obj !== void 0) {
      for (const [entry, val] of Object.entries(value)) {
        if (obj[entry] !== val) {
          modified = true;
          obj[entry] = val;
        }
      }
    } else {
      modified = true;
      __privateGet(this, _storage).set(key, value);
    }
    if (modified) {
      __privateMethod(this, _setModified, setModified_fn).call(this);
    }
    if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === "function") {
      this.onAnnotationEditor(value.constructor._type);
    }
  }
  has(key) {
    return __privateGet(this, _storage).has(key);
  }
  get size() {
    return __privateGet(this, _storage).size;
  }
  resetModified() {
    if (__privateGet(this, _modified)) {
      __privateSet(this, _modified, false);
      if (typeof this.onResetModified === "function") {
        this.onResetModified();
      }
    }
  }
  get print() {
    return new PrintAnnotationStorage(this);
  }
  get serializable() {
    if (__privateGet(this, _storage).size === 0) {
      return SerializableEmpty;
    }
    const map = /* @__PURE__ */ new Map(), hash = new MurmurHash3_64(), transfer = [];
    const context = /* @__PURE__ */ Object.create(null);
    let hasBitmap = false;
    for (const [key, val] of __privateGet(this, _storage)) {
      const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;
      if (serialized) {
        map.set(key, serialized);
        hash.update(`${key}:${JSON.stringify(serialized)}`);
        hasBitmap || (hasBitmap = !!serialized.bitmap);
      }
    }
    if (hasBitmap) {
      for (const value of map.values()) {
        if (value.bitmap) {
          transfer.push(value.bitmap);
        }
      }
    }
    return map.size > 0 ? {
      map,
      hash: hash.hexdigest(),
      transfer
    } : SerializableEmpty;
  }
  get editorStats() {
    var _a3;
    let stats = null;
    const typeToEditor = /* @__PURE__ */ new Map();
    for (const value of __privateGet(this, _storage).values()) {
      if (!(value instanceof AnnotationEditor)) {
        continue;
      }
      const editorStats = value.telemetryFinalData;
      if (!editorStats) {
        continue;
      }
      const {
        type
      } = editorStats;
      if (!typeToEditor.has(type)) {
        typeToEditor.set(type, Object.getPrototypeOf(value).constructor);
      }
      stats || (stats = /* @__PURE__ */ Object.create(null));
      const map = stats[type] || (stats[type] = /* @__PURE__ */ new Map());
      for (const [key, val] of Object.entries(editorStats)) {
        if (key === "type") {
          continue;
        }
        let counters = map.get(key);
        if (!counters) {
          counters = /* @__PURE__ */ new Map();
          map.set(key, counters);
        }
        const count = (_a3 = counters.get(val)) != null ? _a3 : 0;
        counters.set(val, count + 1);
      }
    }
    for (const [type, editor] of typeToEditor) {
      stats[type] = editor.computeTelemetryFinalData(stats[type]);
    }
    return stats;
  }
  resetModifiedIds() {
    __privateSet(this, _modifiedIds, null);
  }
  get modifiedIds() {
    if (__privateGet(this, _modifiedIds)) {
      return __privateGet(this, _modifiedIds);
    }
    const ids = [];
    for (const value of __privateGet(this, _storage).values()) {
      if (!(value instanceof AnnotationEditor) || !value.annotationElementId || !value.serialize()) {
        continue;
      }
      ids.push(value.annotationElementId);
    }
    return __privateSet(this, _modifiedIds, {
      ids: new Set(ids),
      hash: ids.join(",")
    });
  }
  [Symbol.iterator]() {
    return __privateGet(this, _storage).entries();
  }
};
_modified = new WeakMap();
_modifiedIds = new WeakMap();
_storage = new WeakMap();
_setModified = new WeakSet();
setModified_fn = function() {
  if (!__privateGet(this, _modified)) {
    __privateSet(this, _modified, true);
    if (typeof this.onSetModified === "function") {
      this.onSetModified();
    }
  }
};
var _serializable;
var PrintAnnotationStorage = class extends AnnotationStorage {
  constructor(parent) {
    super();
    __privateAdd(this, _serializable, void 0);
    const {
      map,
      hash,
      transfer
    } = parent.serializable;
    const clone = structuredClone(map, transfer ? {
      transfer
    } : null);
    __privateSet(this, _serializable, {
      map: clone,
      hash,
      transfer
    });
  }
  get print() {
    unreachable("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return __privateGet(this, _serializable);
  }
  get modifiedIds() {
    return shadow(this, "modifiedIds", {
      ids: /* @__PURE__ */ new Set(),
      hash: ""
    });
  }
};
_serializable = new WeakMap();
var _systemFonts;
var FontLoader = class {
  constructor({
    ownerDocument = globalThis.document,
    styleElement = null
  }) {
    __privateAdd(this, _systemFonts, /* @__PURE__ */ new Set());
    this._document = ownerDocument;
    this.nativeFontFaces = /* @__PURE__ */ new Set();
    this.styleElement = null;
    this.loadingRequests = [];
    this.loadTestFontId = 0;
  }
  addNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.add(nativeFontFace);
    this._document.fonts.add(nativeFontFace);
  }
  removeNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.delete(nativeFontFace);
    this._document.fonts.delete(nativeFontFace);
  }
  insertRule(rule) {
    if (!this.styleElement) {
      this.styleElement = this._document.createElement("style");
      this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
    }
    const styleSheet = this.styleElement.sheet;
    styleSheet.insertRule(rule, styleSheet.cssRules.length);
  }
  clear() {
    for (const nativeFontFace of this.nativeFontFaces) {
      this._document.fonts.delete(nativeFontFace);
    }
    this.nativeFontFaces.clear();
    __privateGet(this, _systemFonts).clear();
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }
  async loadSystemFont({
    systemFontInfo: info2,
    disableFontFace,
    _inspectFont
  }) {
    if (!info2 || __privateGet(this, _systemFonts).has(info2.loadedName)) {
      return;
    }
    assert(!disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
    if (this.isFontLoadingAPISupported) {
      const {
        loadedName,
        src,
        style
      } = info2;
      const fontFace = new FontFace(loadedName, src, style);
      this.addNativeFontFace(fontFace);
      try {
        await fontFace.load();
        __privateGet(this, _systemFonts).add(loadedName);
        _inspectFont == null ? void 0 : _inspectFont(info2);
      } catch (e) {
        warn(`Cannot load system font: ${info2.baseFontName}, installing it could help to improve PDF rendering.`);
        this.removeNativeFontFace(fontFace);
      }
      return;
    }
    unreachable("Not implemented: loadSystemFont without the Font Loading API.");
  }
  async bind(font) {
    if (font.attached || font.missingFile && !font.systemFontInfo) {
      return;
    }
    font.attached = true;
    if (font.systemFontInfo) {
      await this.loadSystemFont(font);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const nativeFontFace = font.createNativeFontFace();
      if (nativeFontFace) {
        this.addNativeFontFace(nativeFontFace);
        try {
          await nativeFontFace.loaded;
        } catch (ex) {
          warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
          font.disableFontFace = true;
          throw ex;
        }
      }
      return;
    }
    const rule = font.createFontFaceRule();
    if (rule) {
      this.insertRule(rule);
      if (this.isSyncFontLoadingSupported) {
        return;
      }
      await new Promise((resolve) => {
        const request = this._queueLoadingCallback(resolve);
        this._prepareFontLoadEvent(font, request);
      });
    }
  }
  get isFontLoadingAPISupported() {
    var _a3;
    const hasFonts = !!((_a3 = this._document) == null ? void 0 : _a3.fonts);
    return shadow(this, "isFontLoadingAPISupported", hasFonts);
  }
  get isSyncFontLoadingSupported() {
    return shadow(this, "isSyncFontLoadingSupported", isNodeJS || util_FeatureTest.platform.isFirefox);
  }
  _queueLoadingCallback(callback) {
    function completeRequest() {
      assert(!request.done, "completeRequest() cannot be called twice.");
      request.done = true;
      while (loadingRequests.length > 0 && loadingRequests[0].done) {
        const otherRequest = loadingRequests.shift();
        setTimeout(otherRequest.callback, 0);
      }
    }
    const {
      loadingRequests
    } = this;
    const request = {
      done: false,
      complete: completeRequest,
      callback
    };
    loadingRequests.push(request);
    return request;
  }
  get _loadTestFont() {
    const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return shadow(this, "_loadTestFont", testFont);
  }
  _prepareFontLoadEvent(font, request) {
    function int32(data2, offset) {
      return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
    }
    function spliceString(s, offset, remove, insert) {
      const chunk1 = s.substring(0, offset);
      const chunk2 = s.substring(offset + remove);
      return chunk1 + insert + chunk2;
    }
    let i, ii;
    const canvas = this._document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    let called = 0;
    function isFontReady(name, callback) {
      if (++called > 30) {
        warn("Load test font never loaded.");
        callback();
        return;
      }
      ctx.font = "30px " + name;
      ctx.fillText(".", 0, 20);
      const imageData = ctx.getImageData(0, 0, 1, 1);
      if (imageData.data[3] > 0) {
        callback();
        return;
      }
      setTimeout(isFontReady.bind(null, name, callback));
    }
    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
    let data = this._loadTestFont;
    const COMMENT_OFFSET = 976;
    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
    const CFF_CHECKSUM_OFFSET = 16;
    const XXXX_VALUE = 1482184792;
    let checksum = int32(data, CFF_CHECKSUM_OFFSET);
    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
    }
    if (i < loadTestFontId.length) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
    }
    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
    const url = `url(data:font/opentype;base64,${btoa(data)});`;
    const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
    this.insertRule(rule);
    const div = this._document.createElement("div");
    div.style.visibility = "hidden";
    div.style.width = div.style.height = "10px";
    div.style.position = "absolute";
    div.style.top = div.style.left = "0px";
    for (const name of [font.loadedName, loadTestFontId]) {
      const span = this._document.createElement("span");
      span.textContent = "Hi";
      span.style.fontFamily = name;
      div.append(span);
    }
    this._document.body.append(div);
    isFontReady(loadTestFontId, () => {
      div.remove();
      request.complete();
    });
  }
};
_systemFonts = new WeakMap();
var FontFaceObject = class {
  constructor(translatedData, inspectFont = null) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    for (const i in translatedData) {
      this[i] = translatedData[i];
    }
    this._inspectFont = inspectFont;
  }
  createNativeFontFace() {
    var _a3;
    if (!this.data || this.disableFontFace) {
      return null;
    }
    let nativeFontFace;
    if (!this.cssFontInfo) {
      nativeFontFace = new FontFace(this.loadedName, this.data, {});
    } else {
      const css = {
        weight: this.cssFontInfo.fontWeight
      };
      if (this.cssFontInfo.italicAngle) {
        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
      }
      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
    }
    (_a3 = this._inspectFont) == null ? void 0 : _a3.call(this, this);
    return nativeFontFace;
  }
  createFontFaceRule() {
    var _a3;
    if (!this.data || this.disableFontFace) {
      return null;
    }
    const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;
    let rule;
    if (!this.cssFontInfo) {
      rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
    } else {
      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
      if (this.cssFontInfo.italicAngle) {
        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
      }
      rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
    }
    (_a3 = this._inspectFont) == null ? void 0 : _a3.call(this, this, url);
    return rule;
  }
  getPathGenerator(objs, character) {
    if (this.compiledGlyphs[character] !== void 0) {
      return this.compiledGlyphs[character];
    }
    const objId = this.loadedName + "_path_" + character;
    let cmds;
    try {
      cmds = objs.get(objId);
    } catch (ex) {
      warn(`getPathGenerator - ignoring character: "${ex}".`);
    }
    const path2 = new Path2D(cmds || "");
    if (!this.fontExtraProperties) {
      objs.delete(objId);
    }
    return this.compiledGlyphs[character] = path2;
  }
};
function getUrlProp(val) {
  if (val instanceof URL) {
    return val.href;
  }
  if (typeof val === "string") {
    if (isNodeJS) {
      return val;
    }
    const url = URL.parse(val, window.location);
    if (url) {
      return url.href;
    }
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
function getDataProp(val) {
  if (isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  }
  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
    return val;
  }
  if (typeof val === "string") {
    return stringToBytes(val);
  }
  if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === "object" && !isNaN(val == null ? void 0 : val.length)) {
    return new Uint8Array(val);
  }
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
function getFactoryUrlProp(val) {
  if (typeof val !== "string") {
    return null;
  }
  if (val.endsWith("/")) {
    return val;
  }
  throw new Error(`Invalid factory url: "${val}" must include trailing slash.`);
}
var isRefProxy = (v) => typeof v === "object" && Number.isInteger(v == null ? void 0 : v.num) && v.num >= 0 && Number.isInteger(v == null ? void 0 : v.gen) && v.gen >= 0;
var isNameProxy = (v) => typeof v === "object" && typeof (v == null ? void 0 : v.name) === "string";
var isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);
var _listeners, _deferred;
var LoopbackPort = class {
  constructor() {
    __privateAdd(this, _listeners, /* @__PURE__ */ new Map());
    __privateAdd(this, _deferred, Promise.resolve());
  }
  postMessage(obj, transfer) {
    const event = {
      data: structuredClone(obj, transfer ? {
        transfer
      } : null)
    };
    __privateGet(this, _deferred).then(() => {
      for (const [listener] of __privateGet(this, _listeners)) {
        listener.call(this, event);
      }
    });
  }
  addEventListener(name, listener, options = null) {
    let rmAbort = null;
    if ((options == null ? void 0 : options.signal) instanceof AbortSignal) {
      const {
        signal
      } = options;
      if (signal.aborted) {
        warn("LoopbackPort - cannot use an `aborted` signal.");
        return;
      }
      const onAbort = () => this.removeEventListener(name, listener);
      rmAbort = () => signal.removeEventListener("abort", onAbort);
      signal.addEventListener("abort", onAbort);
    }
    __privateGet(this, _listeners).set(listener, rmAbort);
  }
  removeEventListener(name, listener) {
    const rmAbort = __privateGet(this, _listeners).get(listener);
    rmAbort == null ? void 0 : rmAbort();
    __privateGet(this, _listeners).delete(listener);
  }
  terminate() {
    for (const [, rmAbort] of __privateGet(this, _listeners)) {
      rmAbort == null ? void 0 : rmAbort();
    }
    __privateGet(this, _listeners).clear();
  }
};
_listeners = new WeakMap();
_deferred = new WeakMap();
var CallbackKind = {
  DATA: 1,
  ERROR: 2
};
var StreamKind = {
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function onFn() {
}
function wrapReason(ex) {
  if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {
    return ex;
  }
  if (!(ex instanceof Error || typeof ex === "object" && ex !== null)) {
    unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  }
  switch (ex.name) {
    case "AbortException":
      return new AbortException(ex.message);
    case "InvalidPDFException":
      return new InvalidPDFException(ex.message);
    case "PasswordException":
      return new PasswordException(ex.message, ex.code);
    case "ResponseException":
      return new ResponseException(ex.message, ex.status, ex.missing);
    case "UnknownErrorException":
      return new UnknownErrorException(ex.message, ex.details);
  }
  return new UnknownErrorException(ex.message, ex.toString());
}
var _messageAC, _onMessage, onMessage_fn, _createStreamSink, createStreamSink_fn, _processStreamMessage, processStreamMessage_fn, _deleteStreamController, deleteStreamController_fn;
var MessageHandler = class {
  constructor(sourceName, targetName, comObj) {
    __privateAdd(this, _onMessage);
    __privateAdd(this, _createStreamSink);
    __privateAdd(this, _processStreamMessage);
    __privateAdd(this, _deleteStreamController);
    __privateAdd(this, _messageAC, new AbortController());
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = /* @__PURE__ */ Object.create(null);
    this.streamControllers = /* @__PURE__ */ Object.create(null);
    this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
    this.actionHandler = /* @__PURE__ */ Object.create(null);
    comObj.addEventListener("message", __privateMethod(this, _onMessage, onMessage_fn).bind(this), {
      signal: __privateGet(this, _messageAC).signal
    });
  }
  on(actionName, handler) {
    const ah = this.actionHandler;
    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }
    ah[actionName] = handler;
  }
  send(actionName, data, transfers) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }
  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = Promise.withResolvers();
    this.callbackCapabilities[callbackId] = capability;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }
    return capability.promise;
  }
  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
    return new ReadableStream({
      start: (controller) => {
        const startCapability = Promise.withResolvers();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        comObj.postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      },
      pull: (controller) => {
        const pullCapability = Promise.withResolvers();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: (reason) => {
        assert(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = Promise.withResolvers();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }
  destroy() {
    var _a3;
    (_a3 = __privateGet(this, _messageAC)) == null ? void 0 : _a3.abort();
    __privateSet(this, _messageAC, null);
  }
};
_messageAC = new WeakMap();
_onMessage = new WeakSet();
onMessage_fn = function({
  data
}) {
  if (data.targetName !== this.sourceName) {
    return;
  }
  if (data.stream) {
    __privateMethod(this, _processStreamMessage, processStreamMessage_fn).call(this, data);
    return;
  }
  if (data.callback) {
    const callbackId = data.callbackId;
    const capability = this.callbackCapabilities[callbackId];
    if (!capability) {
      throw new Error(`Cannot resolve callback ${callbackId}`);
    }
    delete this.callbackCapabilities[callbackId];
    if (data.callback === CallbackKind.DATA) {
      capability.resolve(data.data);
    } else if (data.callback === CallbackKind.ERROR) {
      capability.reject(wrapReason(data.reason));
    } else {
      throw new Error("Unexpected callback case");
    }
    return;
  }
  const action = this.actionHandler[data.action];
  if (!action) {
    throw new Error(`Unknown action from worker: ${data.action}`);
  }
  if (data.callbackId) {
    const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
    Promise.try(action, data.data).then(function(result) {
      comObj.postMessage({
        sourceName,
        targetName,
        callback: CallbackKind.DATA,
        callbackId: data.callbackId,
        data: result
      });
    }, function(reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        callback: CallbackKind.ERROR,
        callbackId: data.callbackId,
        reason: wrapReason(reason)
      });
    });
    return;
  }
  if (data.streamId) {
    __privateMethod(this, _createStreamSink, createStreamSink_fn).call(this, data);
    return;
  }
  action(data.data);
};
_createStreamSink = new WeakSet();
createStreamSink_fn = function(data) {
  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
  const self = this, action = this.actionHandler[data.action];
  const streamSink = {
    enqueue(chunk, size = 1, transfers) {
      if (this.isCancelled) {
        return;
      }
      const lastDesiredSize = this.desiredSize;
      this.desiredSize -= size;
      if (lastDesiredSize > 0 && this.desiredSize <= 0) {
        this.sinkCapability = Promise.withResolvers();
        this.ready = this.sinkCapability.promise;
      }
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.ENQUEUE,
        streamId,
        chunk
      }, transfers);
    },
    close() {
      if (this.isCancelled) {
        return;
      }
      this.isCancelled = true;
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.CLOSE,
        streamId
      });
      delete self.streamSinks[streamId];
    },
    error(reason) {
      assert(reason instanceof Error, "error must have a valid reason");
      if (this.isCancelled) {
        return;
      }
      this.isCancelled = true;
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.ERROR,
        streamId,
        reason: wrapReason(reason)
      });
    },
    sinkCapability: Promise.withResolvers(),
    onPull: null,
    onCancel: null,
    isCancelled: false,
    desiredSize: data.desiredSize,
    ready: null
  };
  streamSink.sinkCapability.resolve();
  streamSink.ready = streamSink.sinkCapability.promise;
  this.streamSinks[streamId] = streamSink;
  Promise.try(action, data.data, streamSink).then(function() {
    comObj.postMessage({
      sourceName,
      targetName,
      stream: StreamKind.START_COMPLETE,
      streamId,
      success: true
    });
  }, function(reason) {
    comObj.postMessage({
      sourceName,
      targetName,
      stream: StreamKind.START_COMPLETE,
      streamId,
      reason: wrapReason(reason)
    });
  });
};
_processStreamMessage = new WeakSet();
processStreamMessage_fn = function(data) {
  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
  const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
  switch (data.stream) {
    case StreamKind.START_COMPLETE:
      if (data.success) {
        streamController.startCall.resolve();
      } else {
        streamController.startCall.reject(wrapReason(data.reason));
      }
      break;
    case StreamKind.PULL_COMPLETE:
      if (data.success) {
        streamController.pullCall.resolve();
      } else {
        streamController.pullCall.reject(wrapReason(data.reason));
      }
      break;
    case StreamKind.PULL:
      if (!streamSink) {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL_COMPLETE,
          streamId,
          success: true
        });
        break;
      }
      if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
        streamSink.sinkCapability.resolve();
      }
      streamSink.desiredSize = data.desiredSize;
      Promise.try(streamSink.onPull || onFn).then(function() {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL_COMPLETE,
          streamId,
          success: true
        });
      }, function(reason) {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL_COMPLETE,
          streamId,
          reason: wrapReason(reason)
        });
      });
      break;
    case StreamKind.ENQUEUE:
      assert(streamController, "enqueue should have stream controller");
      if (streamController.isClosed) {
        break;
      }
      streamController.controller.enqueue(data.chunk);
      break;
    case StreamKind.CLOSE:
      assert(streamController, "close should have stream controller");
      if (streamController.isClosed) {
        break;
      }
      streamController.isClosed = true;
      streamController.controller.close();
      __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
      break;
    case StreamKind.ERROR:
      assert(streamController, "error should have stream controller");
      streamController.controller.error(wrapReason(data.reason));
      __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
      break;
    case StreamKind.CANCEL_COMPLETE:
      if (data.success) {
        streamController.cancelCall.resolve();
      } else {
        streamController.cancelCall.reject(wrapReason(data.reason));
      }
      __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
      break;
    case StreamKind.CANCEL:
      if (!streamSink) {
        break;
      }
      const dataReason = wrapReason(data.reason);
      Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL_COMPLETE,
          streamId,
          success: true
        });
      }, function(reason) {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL_COMPLETE,
          streamId,
          reason: wrapReason(reason)
        });
      });
      streamSink.sinkCapability.reject(dataReason);
      streamSink.isCancelled = true;
      delete this.streamSinks[streamId];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
};
_deleteStreamController = new WeakSet();
deleteStreamController_fn = async function(streamController, streamId) {
  var _a3, _b2, _c;
  await Promise.allSettled([(_a3 = streamController.startCall) == null ? void 0 : _a3.promise, (_b2 = streamController.pullCall) == null ? void 0 : _b2.promise, (_c = streamController.cancelCall) == null ? void 0 : _c.promise]);
  delete this.streamControllers[streamId];
};
var _enableHWA;
var BaseCanvasFactory = class {
  constructor({
    enableHWA = false
  }) {
    __privateAdd(this, _enableHWA, false);
    __privateSet(this, _enableHWA, enableHWA);
  }
  create(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    const canvas = this._createCanvas(width, height);
    return {
      canvas,
      context: canvas.getContext("2d", {
        willReadFrequently: !__privateGet(this, _enableHWA)
      })
    };
  }
  reset(canvasAndContext, width, height) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    canvasAndContext.canvas.width = width;
    canvasAndContext.canvas.height = height;
  }
  destroy(canvasAndContext) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    canvasAndContext.canvas.width = 0;
    canvasAndContext.canvas.height = 0;
    canvasAndContext.canvas = null;
    canvasAndContext.context = null;
  }
  _createCanvas(width, height) {
    unreachable("Abstract method `_createCanvas` called.");
  }
};
_enableHWA = new WeakMap();
var DOMCanvasFactory = class extends BaseCanvasFactory {
  constructor({
    ownerDocument = globalThis.document,
    enableHWA = false
  }) {
    super({
      enableHWA
    });
    this._document = ownerDocument;
  }
  _createCanvas(width, height) {
    const canvas = this._document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
};
var BaseCMapReaderFactory = class {
  constructor({
    baseUrl = null,
    isCompressed = true
  }) {
    this.baseUrl = baseUrl;
    this.isCompressed = isCompressed;
  }
  async fetch({
    name
  }) {
    if (!this.baseUrl) {
      throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
    }
    if (!name) {
      throw new Error("CMap name must be specified.");
    }
    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
    return this._fetch(url).then((cMapData) => ({
      cMapData,
      isCompressed: this.isCompressed
    })).catch((reason) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
    });
  }
  async _fetch(url) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMCMapReaderFactory = class extends BaseCMapReaderFactory {
  async _fetch(url) {
    const data = await fetchData(url, this.isCompressed ? "arraybuffer" : "text");
    return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);
  }
};
var BaseFilterFactory = class {
  addFilter(maps) {
    return "none";
  }
  addHCMFilter(fgColor, bgColor) {
    return "none";
  }
  addAlphaFilter(map) {
    return "none";
  }
  addLuminosityFilter(map) {
    return "none";
  }
  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
    return "none";
  }
  destroy(keepHCM = false) {
  }
};
var _baseUrl, __cache, __defs, _docId, _document, __hcmCache, _id3, _cache2, cache_get, _hcmCache, hcmCache_get, _defs, defs_get, _createTables, createTables_fn, _createUrl, createUrl_fn, _addLuminosityConversion, addLuminosityConversion_fn, _addGrayConversion, addGrayConversion_fn, _createFilter, createFilter_fn, _appendFeFunc, appendFeFunc_fn, _addTransferMapConversion, addTransferMapConversion_fn, _addTransferMapAlphaConversion, addTransferMapAlphaConversion_fn, _getRGB, getRGB_fn;
var DOMFilterFactory = class extends BaseFilterFactory {
  constructor({
    docId,
    ownerDocument = globalThis.document
  }) {
    super();
    __privateAdd(this, _cache2);
    __privateAdd(this, _hcmCache);
    __privateAdd(this, _defs);
    __privateAdd(this, _createTables);
    __privateAdd(this, _createUrl);
    __privateAdd(this, _addLuminosityConversion);
    __privateAdd(this, _addGrayConversion);
    __privateAdd(this, _createFilter);
    __privateAdd(this, _appendFeFunc);
    __privateAdd(this, _addTransferMapConversion);
    __privateAdd(this, _addTransferMapAlphaConversion);
    __privateAdd(this, _getRGB);
    __privateAdd(this, _baseUrl, void 0);
    __privateAdd(this, __cache, void 0);
    __privateAdd(this, __defs, void 0);
    __privateAdd(this, _docId, void 0);
    __privateAdd(this, _document, void 0);
    __privateAdd(this, __hcmCache, void 0);
    __privateAdd(this, _id3, 0);
    __privateSet(this, _docId, docId);
    __privateSet(this, _document, ownerDocument);
  }
  addFilter(maps) {
    if (!maps) {
      return "none";
    }
    let value = __privateGet(this, _cache2, cache_get).get(maps);
    if (value) {
      return value;
    }
    const [tableR, tableG, tableB] = __privateMethod(this, _createTables, createTables_fn).call(this, maps);
    const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;
    value = __privateGet(this, _cache2, cache_get).get(key);
    if (value) {
      __privateGet(this, _cache2, cache_get).set(maps, value);
      return value;
    }
    const id = `g_${__privateGet(this, _docId)}_transfer_map_${__privateWrapper(this, _id3)._++}`;
    const url = __privateMethod(this, _createUrl, createUrl_fn).call(this, id);
    __privateGet(this, _cache2, cache_get).set(maps, url);
    __privateGet(this, _cache2, cache_get).set(key, url);
    const filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
    __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, tableR, tableG, tableB, filter);
    return url;
  }
  addHCMFilter(fgColor, bgColor) {
    var _a3;
    const key = `${fgColor}-${bgColor}`;
    const filterName = "base";
    let info2 = __privateGet(this, _hcmCache, hcmCache_get).get(filterName);
    if ((info2 == null ? void 0 : info2.key) === key) {
      return info2.url;
    }
    if (info2) {
      (_a3 = info2.filter) == null ? void 0 : _a3.remove();
      info2.key = key;
      info2.url = "none";
      info2.filter = null;
    } else {
      info2 = {
        key,
        url: "none",
        filter: null
      };
      __privateGet(this, _hcmCache, hcmCache_get).set(filterName, info2);
    }
    if (!fgColor || !bgColor) {
      return info2.url;
    }
    const fgRGB = __privateMethod(this, _getRGB, getRGB_fn).call(this, fgColor);
    fgColor = Util.makeHexColor(...fgRGB);
    const bgRGB = __privateMethod(this, _getRGB, getRGB_fn).call(this, bgColor);
    bgColor = Util.makeHexColor(...bgRGB);
    __privateGet(this, _defs, defs_get).style.color = "";
    if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
      return info2.url;
    }
    const map = new Array(256);
    for (let i = 0; i <= 255; i++) {
      const x = i / 255;
      map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
    }
    const table = map.join(",");
    const id = `g_${__privateGet(this, _docId)}_hcm_filter`;
    const filter = info2.filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
    __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, table, table, table, filter);
    __privateMethod(this, _addGrayConversion, addGrayConversion_fn).call(this, filter);
    const getSteps = (c, n) => {
      const start = fgRGB[c] / 255;
      const end = bgRGB[c] / 255;
      const arr = new Array(n + 1);
      for (let i = 0; i <= n; i++) {
        arr[i] = start + i / n * (end - start);
      }
      return arr.join(",");
    };
    __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
    info2.url = __privateMethod(this, _createUrl, createUrl_fn).call(this, id);
    return info2.url;
  }
  addAlphaFilter(map) {
    let value = __privateGet(this, _cache2, cache_get).get(map);
    if (value) {
      return value;
    }
    const [tableA] = __privateMethod(this, _createTables, createTables_fn).call(this, [map]);
    const key = `alpha_${tableA}`;
    value = __privateGet(this, _cache2, cache_get).get(key);
    if (value) {
      __privateGet(this, _cache2, cache_get).set(map, value);
      return value;
    }
    const id = `g_${__privateGet(this, _docId)}_alpha_map_${__privateWrapper(this, _id3)._++}`;
    const url = __privateMethod(this, _createUrl, createUrl_fn).call(this, id);
    __privateGet(this, _cache2, cache_get).set(map, url);
    __privateGet(this, _cache2, cache_get).set(key, url);
    const filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
    __privateMethod(this, _addTransferMapAlphaConversion, addTransferMapAlphaConversion_fn).call(this, tableA, filter);
    return url;
  }
  addLuminosityFilter(map) {
    let value = __privateGet(this, _cache2, cache_get).get(map || "luminosity");
    if (value) {
      return value;
    }
    let tableA, key;
    if (map) {
      [tableA] = __privateMethod(this, _createTables, createTables_fn).call(this, [map]);
      key = `luminosity_${tableA}`;
    } else {
      key = "luminosity";
    }
    value = __privateGet(this, _cache2, cache_get).get(key);
    if (value) {
      __privateGet(this, _cache2, cache_get).set(map, value);
      return value;
    }
    const id = `g_${__privateGet(this, _docId)}_luminosity_map_${__privateWrapper(this, _id3)._++}`;
    const url = __privateMethod(this, _createUrl, createUrl_fn).call(this, id);
    __privateGet(this, _cache2, cache_get).set(map, url);
    __privateGet(this, _cache2, cache_get).set(key, url);
    const filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
    __privateMethod(this, _addLuminosityConversion, addLuminosityConversion_fn).call(this, filter);
    if (map) {
      __privateMethod(this, _addTransferMapAlphaConversion, addTransferMapAlphaConversion_fn).call(this, tableA, filter);
    }
    return url;
  }
  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
    var _a3;
    const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
    let info2 = __privateGet(this, _hcmCache, hcmCache_get).get(filterName);
    if ((info2 == null ? void 0 : info2.key) === key) {
      return info2.url;
    }
    if (info2) {
      (_a3 = info2.filter) == null ? void 0 : _a3.remove();
      info2.key = key;
      info2.url = "none";
      info2.filter = null;
    } else {
      info2 = {
        key,
        url: "none",
        filter: null
      };
      __privateGet(this, _hcmCache, hcmCache_get).set(filterName, info2);
    }
    if (!fgColor || !bgColor) {
      return info2.url;
    }
    const [fgRGB, bgRGB] = [fgColor, bgColor].map(__privateMethod(this, _getRGB, getRGB_fn).bind(this));
    let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
    let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
    let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(__privateMethod(this, _getRGB, getRGB_fn).bind(this));
    if (bgGray < fgGray) {
      [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
    }
    __privateGet(this, _defs, defs_get).style.color = "";
    const getSteps = (fg, bg, n) => {
      const arr = new Array(256);
      const step = (bgGray - fgGray) / n;
      const newStart = fg / 255;
      const newStep = (bg - fg) / (255 * n);
      let prev = 0;
      for (let i = 0; i <= n; i++) {
        const k = Math.round(fgGray + i * step);
        const value = newStart + i * newStep;
        for (let j = prev; j <= k; j++) {
          arr[j] = value;
        }
        prev = k + 1;
      }
      for (let i = prev; i < 256; i++) {
        arr[i] = arr[prev - 1];
      }
      return arr.join(",");
    };
    const id = `g_${__privateGet(this, _docId)}_hcm_${filterName}_filter`;
    const filter = info2.filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
    __privateMethod(this, _addGrayConversion, addGrayConversion_fn).call(this, filter);
    __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
    info2.url = __privateMethod(this, _createUrl, createUrl_fn).call(this, id);
    return info2.url;
  }
  destroy(keepHCM = false) {
    var _a3, _b2, _c, _d;
    if (keepHCM && ((_a3 = __privateGet(this, __hcmCache)) == null ? void 0 : _a3.size)) {
      return;
    }
    (_b2 = __privateGet(this, __defs)) == null ? void 0 : _b2.parentNode.parentNode.remove();
    __privateSet(this, __defs, null);
    (_c = __privateGet(this, __cache)) == null ? void 0 : _c.clear();
    __privateSet(this, __cache, null);
    (_d = __privateGet(this, __hcmCache)) == null ? void 0 : _d.clear();
    __privateSet(this, __hcmCache, null);
    __privateSet(this, _id3, 0);
  }
};
_baseUrl = new WeakMap();
__cache = new WeakMap();
__defs = new WeakMap();
_docId = new WeakMap();
_document = new WeakMap();
__hcmCache = new WeakMap();
_id3 = new WeakMap();
_cache2 = new WeakSet();
cache_get = function() {
  return __privateGet(this, __cache) || __privateSet(this, __cache, /* @__PURE__ */ new Map());
};
_hcmCache = new WeakSet();
hcmCache_get = function() {
  return __privateGet(this, __hcmCache) || __privateSet(this, __hcmCache, /* @__PURE__ */ new Map());
};
_defs = new WeakSet();
defs_get = function() {
  if (!__privateGet(this, __defs)) {
    const div = __privateGet(this, _document).createElement("div");
    const {
      style
    } = div;
    style.visibility = "hidden";
    style.contain = "strict";
    style.width = style.height = 0;
    style.position = "absolute";
    style.top = style.left = 0;
    style.zIndex = -1;
    const svg = __privateGet(this, _document).createElementNS(SVG_NS, "svg");
    svg.setAttribute("width", 0);
    svg.setAttribute("height", 0);
    __privateSet(this, __defs, __privateGet(this, _document).createElementNS(SVG_NS, "defs"));
    div.append(svg);
    svg.append(__privateGet(this, __defs));
    __privateGet(this, _document).body.append(div);
  }
  return __privateGet(this, __defs);
};
_createTables = new WeakSet();
createTables_fn = function(maps) {
  if (maps.length === 1) {
    const mapR2 = maps[0];
    const buffer = new Array(256);
    for (let i = 0; i < 256; i++) {
      buffer[i] = mapR2[i] / 255;
    }
    const table = buffer.join(",");
    return [table, table, table];
  }
  const [mapR, mapG, mapB] = maps;
  const bufferR = new Array(256);
  const bufferG = new Array(256);
  const bufferB = new Array(256);
  for (let i = 0; i < 256; i++) {
    bufferR[i] = mapR[i] / 255;
    bufferG[i] = mapG[i] / 255;
    bufferB[i] = mapB[i] / 255;
  }
  return [bufferR.join(","), bufferG.join(","), bufferB.join(",")];
};
_createUrl = new WeakSet();
createUrl_fn = function(id) {
  if (__privateGet(this, _baseUrl) === void 0) {
    __privateSet(this, _baseUrl, "");
    const url = __privateGet(this, _document).URL;
    if (url !== __privateGet(this, _document).baseURI) {
      if (isDataScheme(url)) {
        warn('#createUrl: ignore "data:"-URL for performance reasons.');
      } else {
        __privateSet(this, _baseUrl, updateUrlHash(url, ""));
      }
    }
  }
  return `url(${__privateGet(this, _baseUrl)}#${id})`;
};
_addLuminosityConversion = new WeakSet();
addLuminosityConversion_fn = function(filter) {
  const feColorMatrix = __privateGet(this, _document).createElementNS(SVG_NS, "feColorMatrix");
  feColorMatrix.setAttribute("type", "matrix");
  feColorMatrix.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0");
  filter.append(feColorMatrix);
};
_addGrayConversion = new WeakSet();
addGrayConversion_fn = function(filter) {
  const feColorMatrix = __privateGet(this, _document).createElementNS(SVG_NS, "feColorMatrix");
  feColorMatrix.setAttribute("type", "matrix");
  feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
  filter.append(feColorMatrix);
};
_createFilter = new WeakSet();
createFilter_fn = function(id) {
  const filter = __privateGet(this, _document).createElementNS(SVG_NS, "filter");
  filter.setAttribute("color-interpolation-filters", "sRGB");
  filter.setAttribute("id", id);
  __privateGet(this, _defs, defs_get).append(filter);
  return filter;
};
_appendFeFunc = new WeakSet();
appendFeFunc_fn = function(feComponentTransfer, func, table) {
  const feFunc = __privateGet(this, _document).createElementNS(SVG_NS, func);
  feFunc.setAttribute("type", "discrete");
  feFunc.setAttribute("tableValues", table);
  feComponentTransfer.append(feFunc);
};
_addTransferMapConversion = new WeakSet();
addTransferMapConversion_fn = function(rTable, gTable, bTable, filter) {
  const feComponentTransfer = __privateGet(this, _document).createElementNS(SVG_NS, "feComponentTransfer");
  filter.append(feComponentTransfer);
  __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncR", rTable);
  __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncG", gTable);
  __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncB", bTable);
};
_addTransferMapAlphaConversion = new WeakSet();
addTransferMapAlphaConversion_fn = function(aTable, filter) {
  const feComponentTransfer = __privateGet(this, _document).createElementNS(SVG_NS, "feComponentTransfer");
  filter.append(feComponentTransfer);
  __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncA", aTable);
};
_getRGB = new WeakSet();
getRGB_fn = function(color) {
  __privateGet(this, _defs, defs_get).style.color = color;
  return getRGB(getComputedStyle(__privateGet(this, _defs, defs_get)).getPropertyValue("color"));
};
var BaseStandardFontDataFactory = class {
  constructor({
    baseUrl = null
  }) {
    this.baseUrl = baseUrl;
  }
  async fetch({
    filename
  }) {
    if (!this.baseUrl) {
      throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
    }
    if (!filename) {
      throw new Error("Font filename must be specified.");
    }
    const url = `${this.baseUrl}${filename}`;
    return this._fetch(url).catch((reason) => {
      throw new Error(`Unable to load font data at: ${url}`);
    });
  }
  async _fetch(url) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMStandardFontDataFactory = class extends BaseStandardFontDataFactory {
  async _fetch(url) {
    const data = await fetchData(url, "arraybuffer");
    return new Uint8Array(data);
  }
};
var BaseWasmFactory = class {
  constructor({
    baseUrl = null
  }) {
    this.baseUrl = baseUrl;
  }
  async fetch({
    filename
  }) {
    if (!this.baseUrl) {
      throw new Error("Ensure that the `wasmUrl` API parameter is provided.");
    }
    if (!filename) {
      throw new Error("Wasm filename must be specified.");
    }
    const url = `${this.baseUrl}${filename}`;
    return this._fetch(url).catch((reason) => {
      throw new Error(`Unable to load wasm data at: ${url}`);
    });
  }
  async _fetch(url) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMWasmFactory = class extends BaseWasmFactory {
  async _fetch(url) {
    const data = await fetchData(url, "arraybuffer");
    return new Uint8Array(data);
  }
};
if (isNodeJS) {
  warn("Please use the `legacy` build in Node.js environments.");
}
async function node_utils_fetchData(url) {
  const fs2 = process.getBuiltinModule("fs");
  const data = await fs2.promises.readFile(url);
  return new Uint8Array(data);
}
var NodeFilterFactory = class extends BaseFilterFactory {
};
var NodeCanvasFactory = class extends BaseCanvasFactory {
  _createCanvas(width, height) {
    const require2 = process.getBuiltinModule("module").createRequire(import_meta.url);
    const canvas = require2("@napi-rs/canvas");
    return canvas.createCanvas(width, height);
  }
};
var NodeCMapReaderFactory = class extends BaseCMapReaderFactory {
  async _fetch(url) {
    return node_utils_fetchData(url);
  }
};
var NodeStandardFontDataFactory = class extends BaseStandardFontDataFactory {
  async _fetch(url) {
    return node_utils_fetchData(url);
  }
};
var NodeWasmFactory = class extends BaseWasmFactory {
  async _fetch(url) {
    return node_utils_fetchData(url);
  }
};
var FORCED_DEPENDENCY_LABEL = "__forcedDependency";
var _simple, _incremental, _namedDependencies, _savesStack, _markedContentStack, _baseTransformStack, _clipBox, _pendingBBox, _pendingBBoxIdx, _pendingDependencies, _operations, _fontBBoxTrustworthy, _canvasWidth, _canvasHeight;
var CanvasDependencyTracker = class {
  constructor(canvas) {
    __privateAdd(this, _simple, {
      __proto__: null
    });
    __privateAdd(this, _incremental, {
      __proto__: null,
      transform: [],
      moveText: [],
      sameLineText: [],
      [FORCED_DEPENDENCY_LABEL]: []
    });
    __privateAdd(this, _namedDependencies, /* @__PURE__ */ new Map());
    __privateAdd(this, _savesStack, []);
    __privateAdd(this, _markedContentStack, []);
    __privateAdd(this, _baseTransformStack, [[1, 0, 0, 1, 0, 0]]);
    __privateAdd(this, _clipBox, [-Infinity, -Infinity, Infinity, Infinity]);
    __privateAdd(this, _pendingBBox, new Float64Array([Infinity, Infinity, -Infinity, -Infinity]));
    __privateAdd(this, _pendingBBoxIdx, -1);
    __privateAdd(this, _pendingDependencies, /* @__PURE__ */ new Set());
    __privateAdd(this, _operations, /* @__PURE__ */ new Map());
    __privateAdd(this, _fontBBoxTrustworthy, /* @__PURE__ */ new Map());
    __privateAdd(this, _canvasWidth, void 0);
    __privateAdd(this, _canvasHeight, void 0);
    __privateSet(this, _canvasWidth, canvas.width);
    __privateSet(this, _canvasHeight, canvas.height);
  }
  save(opIdx) {
    __privateSet(this, _simple, {
      __proto__: __privateGet(this, _simple)
    });
    __privateSet(this, _incremental, {
      __proto__: __privateGet(this, _incremental),
      transform: {
        __proto__: __privateGet(this, _incremental).transform
      },
      moveText: {
        __proto__: __privateGet(this, _incremental).moveText
      },
      sameLineText: {
        __proto__: __privateGet(this, _incremental).sameLineText
      },
      [FORCED_DEPENDENCY_LABEL]: {
        __proto__: __privateGet(this, _incremental)[FORCED_DEPENDENCY_LABEL]
      }
    });
    __privateSet(this, _clipBox, {
      __proto__: __privateGet(this, _clipBox)
    });
    __privateGet(this, _savesStack).push([opIdx, null]);
    return this;
  }
  restore(opIdx) {
    const previous = Object.getPrototypeOf(__privateGet(this, _simple));
    if (previous === null) {
      return this;
    }
    __privateSet(this, _simple, previous);
    __privateSet(this, _incremental, Object.getPrototypeOf(__privateGet(this, _incremental)));
    __privateSet(this, _clipBox, Object.getPrototypeOf(__privateGet(this, _clipBox)));
    const lastPair = __privateGet(this, _savesStack).pop();
    if (lastPair !== void 0) {
      lastPair[1] = opIdx;
    }
    return this;
  }
  recordOpenMarker(idx) {
    __privateGet(this, _savesStack).push([idx, null]);
    return this;
  }
  getOpenMarker() {
    if (__privateGet(this, _savesStack).length === 0) {
      return null;
    }
    return __privateGet(this, _savesStack).at(-1)[0];
  }
  recordCloseMarker(idx) {
    const lastPair = __privateGet(this, _savesStack).pop();
    if (lastPair !== void 0) {
      lastPair[1] = idx;
    }
    return this;
  }
  beginMarkedContent(opIdx) {
    __privateGet(this, _markedContentStack).push([opIdx, null]);
    return this;
  }
  endMarkedContent(opIdx) {
    const lastPair = __privateGet(this, _markedContentStack).pop();
    if (lastPair !== void 0) {
      lastPair[1] = opIdx;
    }
    return this;
  }
  pushBaseTransform(ctx) {
    __privateGet(this, _baseTransformStack).push(Util.multiplyByDOMMatrix(__privateGet(this, _baseTransformStack).at(-1), ctx.getTransform()));
    return this;
  }
  popBaseTransform() {
    if (__privateGet(this, _baseTransformStack).length > 1) {
      __privateGet(this, _baseTransformStack).pop();
    }
    return this;
  }
  recordSimpleData(name, idx) {
    __privateGet(this, _simple)[name] = idx;
    return this;
  }
  recordIncrementalData(name, idx) {
    __privateGet(this, _incremental)[name].push(idx);
    return this;
  }
  resetIncrementalData(name, idx) {
    __privateGet(this, _incremental)[name].length = 0;
    return this;
  }
  recordNamedData(name, idx) {
    __privateGet(this, _namedDependencies).set(name, idx);
    return this;
  }
  recordFutureForcedDependency(name, idx) {
    this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);
    return this;
  }
  inheritSimpleDataAsFutureForcedDependencies(names) {
    for (const name of names) {
      if (name in __privateGet(this, _simple)) {
        this.recordFutureForcedDependency(name, __privateGet(this, _simple)[name]);
      }
    }
    return this;
  }
  inheritPendingDependenciesAsFutureForcedDependencies() {
    for (const dep of __privateGet(this, _pendingDependencies)) {
      this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);
    }
    return this;
  }
  resetBBox(idx) {
    __privateSet(this, _pendingBBoxIdx, idx);
    __privateGet(this, _pendingBBox)[0] = Infinity;
    __privateGet(this, _pendingBBox)[1] = Infinity;
    __privateGet(this, _pendingBBox)[2] = -Infinity;
    __privateGet(this, _pendingBBox)[3] = -Infinity;
    return this;
  }
  get hasPendingBBox() {
    return __privateGet(this, _pendingBBoxIdx) !== -1;
  }
  recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
    const transform = Util.multiplyByDOMMatrix(__privateGet(this, _baseTransformStack).at(-1), ctx.getTransform());
    const clipBox = [Infinity, Infinity, -Infinity, -Infinity];
    Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, clipBox);
    const intersection = Util.intersect(__privateGet(this, _clipBox), clipBox);
    if (intersection) {
      __privateGet(this, _clipBox)[0] = intersection[0];
      __privateGet(this, _clipBox)[1] = intersection[1];
      __privateGet(this, _clipBox)[2] = intersection[2];
      __privateGet(this, _clipBox)[3] = intersection[3];
    } else {
      __privateGet(this, _clipBox)[0] = __privateGet(this, _clipBox)[1] = Infinity;
      __privateGet(this, _clipBox)[2] = __privateGet(this, _clipBox)[3] = -Infinity;
    }
    return this;
  }
  recordBBox(idx, ctx, minX, maxX, minY, maxY) {
    const clipBox = __privateGet(this, _clipBox);
    if (clipBox[0] === Infinity) {
      return this;
    }
    const transform = Util.multiplyByDOMMatrix(__privateGet(this, _baseTransformStack).at(-1), ctx.getTransform());
    if (clipBox[0] === -Infinity) {
      Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, __privateGet(this, _pendingBBox));
      return this;
    }
    const bbox = [Infinity, Infinity, -Infinity, -Infinity];
    Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, bbox);
    __privateGet(this, _pendingBBox)[0] = Math.min(__privateGet(this, _pendingBBox)[0], Math.max(bbox[0], clipBox[0]));
    __privateGet(this, _pendingBBox)[1] = Math.min(__privateGet(this, _pendingBBox)[1], Math.max(bbox[1], clipBox[1]));
    __privateGet(this, _pendingBBox)[2] = Math.max(__privateGet(this, _pendingBBox)[2], Math.min(bbox[2], clipBox[2]));
    __privateGet(this, _pendingBBox)[3] = Math.max(__privateGet(this, _pendingBBox)[3], Math.min(bbox[3], clipBox[3]));
    return this;
  }
  recordCharacterBBox(idx, ctx, font, scale = 1, x = 0, y = 0, getMeasure) {
    const fontBBox = font.bbox;
    let isBBoxTrustworthy;
    let computedBBox;
    if (fontBBox) {
      isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && __privateGet(this, _fontBBoxTrustworthy).get(font);
      if (isBBoxTrustworthy !== false) {
        computedBBox = [0, 0, 0, 0];
        Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);
        if (scale !== 1 || x !== 0 || y !== 0) {
          Util.scaleMinMax([scale, 0, 0, -scale, x, y], computedBBox);
        }
        if (isBBoxTrustworthy) {
          return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
        }
      }
    }
    if (!getMeasure) {
      return this.recordFullPageBBox(idx);
    }
    const measure = getMeasure();
    if (fontBBox && computedBBox && isBBoxTrustworthy === void 0) {
      isBBoxTrustworthy = computedBBox[0] <= x - measure.actualBoundingBoxLeft && computedBBox[2] >= x + measure.actualBoundingBoxRight && computedBBox[1] <= y - measure.actualBoundingBoxAscent && computedBBox[3] >= y + measure.actualBoundingBoxDescent;
      __privateGet(this, _fontBBoxTrustworthy).set(font, isBBoxTrustworthy);
      if (isBBoxTrustworthy) {
        return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
      }
    }
    return this.recordBBox(idx, ctx, x - measure.actualBoundingBoxLeft, x + measure.actualBoundingBoxRight, y - measure.actualBoundingBoxAscent, y + measure.actualBoundingBoxDescent);
  }
  recordFullPageBBox(idx) {
    __privateGet(this, _pendingBBox)[0] = Math.max(0, __privateGet(this, _clipBox)[0]);
    __privateGet(this, _pendingBBox)[1] = Math.max(0, __privateGet(this, _clipBox)[1]);
    __privateGet(this, _pendingBBox)[2] = Math.min(__privateGet(this, _canvasWidth), __privateGet(this, _clipBox)[2]);
    __privateGet(this, _pendingBBox)[3] = Math.min(__privateGet(this, _canvasHeight), __privateGet(this, _clipBox)[3]);
    return this;
  }
  getSimpleIndex(dependencyName) {
    return __privateGet(this, _simple)[dependencyName];
  }
  recordDependencies(idx, dependencyNames) {
    const pendingDependencies = __privateGet(this, _pendingDependencies);
    const simple = __privateGet(this, _simple);
    const incremental = __privateGet(this, _incremental);
    for (const name of dependencyNames) {
      if (name in __privateGet(this, _simple)) {
        pendingDependencies.add(simple[name]);
      } else if (name in incremental) {
        incremental[name].forEach(pendingDependencies.add, pendingDependencies);
      }
    }
    return this;
  }
  copyDependenciesFromIncrementalOperation(idx, name) {
    const operations = __privateGet(this, _operations);
    const pendingDependencies = __privateGet(this, _pendingDependencies);
    for (const depIdx of __privateGet(this, _incremental)[name]) {
      operations.get(depIdx).dependencies.forEach(pendingDependencies.add, pendingDependencies.add(depIdx));
    }
    return this;
  }
  recordNamedDependency(idx, name) {
    if (__privateGet(this, _namedDependencies).has(name)) {
      __privateGet(this, _pendingDependencies).add(__privateGet(this, _namedDependencies).get(name));
    }
    return this;
  }
  recordOperation(idx, preserveBbox = false) {
    this.recordDependencies(idx, [FORCED_DEPENDENCY_LABEL]);
    const dependencies = new Set(__privateGet(this, _pendingDependencies));
    const pairs = __privateGet(this, _savesStack).concat(__privateGet(this, _markedContentStack));
    const bbox = __privateGet(this, _pendingBBoxIdx) === idx ? {
      minX: __privateGet(this, _pendingBBox)[0],
      minY: __privateGet(this, _pendingBBox)[1],
      maxX: __privateGet(this, _pendingBBox)[2],
      maxY: __privateGet(this, _pendingBBox)[3]
    } : null;
    __privateGet(this, _operations).set(idx, {
      bbox,
      pairs,
      dependencies
    });
    if (!preserveBbox) {
      __privateSet(this, _pendingBBoxIdx, -1);
    }
    __privateGet(this, _pendingDependencies).clear();
    return this;
  }
  bboxToClipBoxDropOperation(idx) {
    if (__privateGet(this, _pendingBBoxIdx) !== -1) {
      __privateSet(this, _pendingBBoxIdx, -1);
      __privateGet(this, _clipBox)[0] = Math.max(__privateGet(this, _clipBox)[0], __privateGet(this, _pendingBBox)[0]);
      __privateGet(this, _clipBox)[1] = Math.max(__privateGet(this, _clipBox)[1], __privateGet(this, _pendingBBox)[1]);
      __privateGet(this, _clipBox)[2] = Math.min(__privateGet(this, _clipBox)[2], __privateGet(this, _pendingBBox)[2]);
      __privateGet(this, _clipBox)[3] = Math.min(__privateGet(this, _clipBox)[3], __privateGet(this, _pendingBBox)[3]);
    }
    __privateGet(this, _pendingDependencies).clear();
    return this;
  }
  _takePendingDependencies() {
    const pendingDependencies = __privateGet(this, _pendingDependencies);
    __privateSet(this, _pendingDependencies, /* @__PURE__ */ new Set());
    return pendingDependencies;
  }
  _extractOperation(idx) {
    const operation = __privateGet(this, _operations).get(idx);
    __privateGet(this, _operations).delete(idx);
    return operation;
  }
  _pushPendingDependencies(dependencies) {
    for (const dep of dependencies) {
      __privateGet(this, _pendingDependencies).add(dep);
    }
  }
  take() {
    __privateGet(this, _fontBBoxTrustworthy).clear();
    return Array.from(__privateGet(this, _operations), ([idx, {
      bbox,
      pairs,
      dependencies
    }]) => {
      var _a3, _b2, _c, _d;
      pairs.forEach((pair) => pair.forEach(dependencies.add, dependencies));
      dependencies.delete(idx);
      return {
        minX: ((_a3 = bbox == null ? void 0 : bbox.minX) != null ? _a3 : 0) / __privateGet(this, _canvasWidth),
        maxX: ((_b2 = bbox == null ? void 0 : bbox.maxX) != null ? _b2 : __privateGet(this, _canvasWidth)) / __privateGet(this, _canvasWidth),
        minY: ((_c = bbox == null ? void 0 : bbox.minY) != null ? _c : 0) / __privateGet(this, _canvasHeight),
        maxY: ((_d = bbox == null ? void 0 : bbox.maxY) != null ? _d : __privateGet(this, _canvasHeight)) / __privateGet(this, _canvasHeight),
        dependencies: Array.from(dependencies).sort((a, b) => a - b),
        idx
      };
    });
  }
};
_simple = new WeakMap();
_incremental = new WeakMap();
_namedDependencies = new WeakMap();
_savesStack = new WeakMap();
_markedContentStack = new WeakMap();
_baseTransformStack = new WeakMap();
_clipBox = new WeakMap();
_pendingBBox = new WeakMap();
_pendingBBoxIdx = new WeakMap();
_pendingDependencies = new WeakMap();
_operations = new WeakMap();
_fontBBoxTrustworthy = new WeakMap();
_canvasWidth = new WeakMap();
_canvasHeight = new WeakMap();
var _dependencyTracker, _opIdx, _nestingLevel, _outerDependencies, _savesLevel;
var _CanvasNestedDependencyTracker = class _CanvasNestedDependencyTracker {
  constructor(dependencyTracker, opIdx) {
    __privateAdd(this, _dependencyTracker, void 0);
    __privateAdd(this, _opIdx, void 0);
    __privateAdd(this, _nestingLevel, 0);
    __privateAdd(this, _outerDependencies, void 0);
    __privateAdd(this, _savesLevel, 0);
    if (dependencyTracker instanceof _CanvasNestedDependencyTracker) {
      return dependencyTracker;
    }
    __privateSet(this, _dependencyTracker, dependencyTracker);
    __privateSet(this, _outerDependencies, dependencyTracker._takePendingDependencies());
    __privateSet(this, _opIdx, opIdx);
  }
  save(opIdx) {
    __privateWrapper(this, _savesLevel)._++;
    __privateGet(this, _dependencyTracker).save(__privateGet(this, _opIdx));
    return this;
  }
  restore(opIdx) {
    if (__privateGet(this, _savesLevel) > 0) {
      __privateGet(this, _dependencyTracker).restore(__privateGet(this, _opIdx));
      __privateWrapper(this, _savesLevel)._--;
    }
    return this;
  }
  recordOpenMarker(idx) {
    __privateWrapper(this, _nestingLevel)._++;
    return this;
  }
  getOpenMarker() {
    return __privateGet(this, _nestingLevel) > 0 ? __privateGet(this, _opIdx) : __privateGet(this, _dependencyTracker).getOpenMarker();
  }
  recordCloseMarker(idx) {
    __privateWrapper(this, _nestingLevel)._--;
    return this;
  }
  beginMarkedContent(opIdx) {
    return this;
  }
  endMarkedContent(opIdx) {
    return this;
  }
  pushBaseTransform(ctx) {
    __privateGet(this, _dependencyTracker).pushBaseTransform(ctx);
    return this;
  }
  popBaseTransform() {
    __privateGet(this, _dependencyTracker).popBaseTransform();
    return this;
  }
  recordSimpleData(name, idx) {
    __privateGet(this, _dependencyTracker).recordSimpleData(name, __privateGet(this, _opIdx));
    return this;
  }
  recordIncrementalData(name, idx) {
    __privateGet(this, _dependencyTracker).recordIncrementalData(name, __privateGet(this, _opIdx));
    return this;
  }
  resetIncrementalData(name, idx) {
    __privateGet(this, _dependencyTracker).resetIncrementalData(name, __privateGet(this, _opIdx));
    return this;
  }
  recordNamedData(name, idx) {
    return this;
  }
  recordFutureForcedDependency(name, idx) {
    __privateGet(this, _dependencyTracker).recordFutureForcedDependency(name, __privateGet(this, _opIdx));
    return this;
  }
  inheritSimpleDataAsFutureForcedDependencies(names) {
    __privateGet(this, _dependencyTracker).inheritSimpleDataAsFutureForcedDependencies(names);
    return this;
  }
  inheritPendingDependenciesAsFutureForcedDependencies() {
    __privateGet(this, _dependencyTracker).inheritPendingDependenciesAsFutureForcedDependencies();
    return this;
  }
  resetBBox(idx) {
    if (!__privateGet(this, _dependencyTracker).hasPendingBBox) {
      __privateGet(this, _dependencyTracker).resetBBox(__privateGet(this, _opIdx));
    }
    return this;
  }
  get hasPendingBBox() {
    return __privateGet(this, _dependencyTracker).hasPendingBBox;
  }
  recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
    __privateGet(this, _dependencyTracker).recordClipBox(__privateGet(this, _opIdx), ctx, minX, maxX, minY, maxY);
    return this;
  }
  recordBBox(idx, ctx, minX, maxX, minY, maxY) {
    __privateGet(this, _dependencyTracker).recordBBox(__privateGet(this, _opIdx), ctx, minX, maxX, minY, maxY);
    return this;
  }
  recordCharacterBBox(idx, ctx, font, scale, x, y, getMeasure) {
    __privateGet(this, _dependencyTracker).recordCharacterBBox(__privateGet(this, _opIdx), ctx, font, scale, x, y, getMeasure);
    return this;
  }
  recordFullPageBBox(idx) {
    __privateGet(this, _dependencyTracker).recordFullPageBBox(__privateGet(this, _opIdx));
    return this;
  }
  getSimpleIndex(dependencyName) {
    return __privateGet(this, _dependencyTracker).getSimpleIndex(dependencyName);
  }
  recordDependencies(idx, dependencyNames) {
    __privateGet(this, _dependencyTracker).recordDependencies(__privateGet(this, _opIdx), dependencyNames);
    return this;
  }
  copyDependenciesFromIncrementalOperation(idx, name) {
    __privateGet(this, _dependencyTracker).copyDependenciesFromIncrementalOperation(__privateGet(this, _opIdx), name);
    return this;
  }
  recordNamedDependency(idx, name) {
    __privateGet(this, _dependencyTracker).recordNamedDependency(__privateGet(this, _opIdx), name);
    return this;
  }
  recordOperation(idx) {
    __privateGet(this, _dependencyTracker).recordOperation(__privateGet(this, _opIdx), true);
    const operation = __privateGet(this, _dependencyTracker)._extractOperation(__privateGet(this, _opIdx));
    for (const depIdx of operation.dependencies) {
      __privateGet(this, _outerDependencies).add(depIdx);
    }
    __privateGet(this, _outerDependencies).delete(__privateGet(this, _opIdx));
    __privateGet(this, _outerDependencies).delete(null);
    return this;
  }
  bboxToClipBoxDropOperation(idx) {
    __privateGet(this, _dependencyTracker).bboxToClipBoxDropOperation(__privateGet(this, _opIdx));
    return this;
  }
  recordNestedDependencies() {
    __privateGet(this, _dependencyTracker)._pushPendingDependencies(__privateGet(this, _outerDependencies));
  }
  take() {
    throw new Error("Unreachable");
  }
};
_dependencyTracker = new WeakMap();
_opIdx = new WeakMap();
_nestingLevel = new WeakMap();
_outerDependencies = new WeakMap();
_savesLevel = new WeakMap();
var CanvasNestedDependencyTracker = _CanvasNestedDependencyTracker;
var Dependencies = {
  stroke: ["path", "transform", "filter", "strokeColor", "strokeAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "dash"],
  fill: ["path", "transform", "filter", "fillColor", "fillAlpha", "globalCompositeOperation", "SMask"],
  imageXObject: ["transform", "SMask", "filter", "fillAlpha", "strokeAlpha", "globalCompositeOperation"],
  rawFillPath: ["filter", "fillColor", "fillAlpha"],
  showText: ["transform", "leading", "charSpacing", "wordSpacing", "hScale", "textRise", "moveText", "textMatrix", "font", "filter", "fillColor", "textRenderingMode", "SMask", "fillAlpha", "strokeAlpha", "globalCompositeOperation"],
  transform: ["transform"],
  transformAndFill: ["transform", "fillColor"]
};
var PathType = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function applyBoundingBox(ctx, bbox) {
  if (!bbox) {
    return;
  }
  const width = bbox[2] - bbox[0];
  const height = bbox[3] - bbox[1];
  const region = new Path2D();
  region.rect(bbox[0], bbox[1], width, height);
  ctx.clip(region);
}
var BaseShadingPattern = class {
  isModifyingCurrentTransform() {
    return false;
  }
  getPattern() {
    unreachable("Abstract method `getPattern` called.");
  }
};
var RadialAxialShadingPattern = class extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._type = IR[1];
    this._bbox = IR[2];
    this._colorStops = IR[3];
    this._p0 = IR[4];
    this._p1 = IR[5];
    this._r0 = IR[6];
    this._r1 = IR[7];
    this.matrix = null;
  }
  _createGradient(ctx) {
    let grad;
    if (this._type === "axial") {
      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
    } else if (this._type === "radial") {
      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
    }
    for (const colorStop of this._colorStops) {
      grad.addColorStop(colorStop[0], colorStop[1]);
    }
    return grad;
  }
  getPattern(ctx, owner, inverse, pathType) {
    let pattern;
    if (pathType === PathType.STROKE || pathType === PathType.FILL) {
      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [0, 0, 0, 0];
      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height);
      const tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.beginPath();
      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
      inverse = Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
      tmpCtx.transform(...owner.baseTransform);
      if (this.matrix) {
        tmpCtx.transform(...this.matrix);
      }
      applyBoundingBox(tmpCtx, this._bbox);
      tmpCtx.fillStyle = this._createGradient(tmpCtx);
      tmpCtx.fill();
      pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
      const domMatrix = new DOMMatrix(inverse);
      pattern.setTransform(domMatrix);
    } else {
      applyBoundingBox(ctx, this._bbox);
      pattern = this._createGradient(ctx);
    }
    return pattern;
  }
};
function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
  const coords = context.coords, colors = context.colors;
  const bytes = data.data, rowSize = data.width * 4;
  let tmp;
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  if (coords[p2 + 1] > coords[p3 + 1]) {
    tmp = p2;
    p2 = p3;
    p3 = tmp;
    tmp = c2;
    c2 = c3;
    c3 = tmp;
  }
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  const x1 = (coords[p1] + context.offsetX) * context.scaleX;
  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
  const x2 = (coords[p2] + context.offsetX) * context.scaleX;
  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
  const x3 = (coords[p3] + context.offsetX) * context.scaleX;
  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
  if (y1 >= y3) {
    return;
  }
  const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
  const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
  const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
  const minY = Math.round(y1), maxY = Math.round(y3);
  let xa, car, cag, cab;
  let xb, cbr, cbg, cbb;
  for (let y = minY; y <= maxY; y++) {
    if (y < y2) {
      const k2 = y < y1 ? 0 : (y1 - y) / (y1 - y2);
      xa = x1 - (x1 - x2) * k2;
      car = c1r - (c1r - c2r) * k2;
      cag = c1g - (c1g - c2g) * k2;
      cab = c1b - (c1b - c2b) * k2;
    } else {
      let k2;
      if (y > y3) {
        k2 = 1;
      } else if (y2 === y3) {
        k2 = 0;
      } else {
        k2 = (y2 - y) / (y2 - y3);
      }
      xa = x2 - (x2 - x3) * k2;
      car = c2r - (c2r - c3r) * k2;
      cag = c2g - (c2g - c3g) * k2;
      cab = c2b - (c2b - c3b) * k2;
    }
    let k;
    if (y < y1) {
      k = 0;
    } else if (y > y3) {
      k = 1;
    } else {
      k = (y1 - y) / (y1 - y3);
    }
    xb = x1 - (x1 - x3) * k;
    cbr = c1r - (c1r - c3r) * k;
    cbg = c1g - (c1g - c3g) * k;
    cbb = c1b - (c1b - c3b) * k;
    const x1_ = Math.round(Math.min(xa, xb));
    const x2_ = Math.round(Math.max(xa, xb));
    let j = rowSize * y + x1_ * 4;
    for (let x = x1_; x <= x2_; x++) {
      k = (xa - x) / (xa - xb);
      if (k < 0) {
        k = 0;
      } else if (k > 1) {
        k = 1;
      }
      bytes[j++] = car - (car - cbr) * k | 0;
      bytes[j++] = cag - (cag - cbg) * k | 0;
      bytes[j++] = cab - (cab - cbb) * k | 0;
      bytes[j++] = 255;
    }
  }
}
function drawFigure(data, figure, context) {
  const ps = figure.coords;
  const cs = figure.colors;
  let i, ii;
  switch (figure.type) {
    case "lattice":
      const verticesPerRow = figure.verticesPerRow;
      const rows = Math.floor(ps.length / verticesPerRow) - 1;
      const cols = verticesPerRow - 1;
      for (i = 0; i < rows; i++) {
        let q = i * verticesPerRow;
        for (let j = 0; j < cols; j++, q++) {
          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
        }
      }
      break;
    case "triangles":
      for (i = 0, ii = ps.length; i < ii; i += 3) {
        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
      }
      break;
    default:
      throw new Error("illegal figure");
  }
}
var MeshShadingPattern = class extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._coords = IR[2];
    this._colors = IR[3];
    this._figures = IR[4];
    this._bounds = IR[5];
    this._bbox = IR[6];
    this._background = IR[7];
    this.matrix = null;
  }
  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
    const EXPECTED_SCALE = 1.1;
    const MAX_PATTERN_SIZE = 3e3;
    const BORDER_SIZE = 2;
    const offsetX = Math.floor(this._bounds[0]);
    const offsetY = Math.floor(this._bounds[1]);
    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const scaleX = boundsWidth / width;
    const scaleY = boundsHeight / height;
    const context = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    const paddedWidth = width + BORDER_SIZE * 2;
    const paddedHeight = height + BORDER_SIZE * 2;
    const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight);
    const tmpCtx = tmpCanvas.context;
    const data = tmpCtx.createImageData(width, height);
    if (backgroundColor) {
      const bytes = data.data;
      for (let i = 0, ii = bytes.length; i < ii; i += 4) {
        bytes[i] = backgroundColor[0];
        bytes[i + 1] = backgroundColor[1];
        bytes[i + 2] = backgroundColor[2];
        bytes[i + 3] = 255;
      }
    }
    for (const figure of this._figures) {
      drawFigure(data, figure, context);
    }
    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
    const canvas = tmpCanvas.canvas;
    return {
      canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX,
      scaleY
    };
  }
  isModifyingCurrentTransform() {
    return true;
  }
  getPattern(ctx, owner, inverse, pathType) {
    applyBoundingBox(ctx, this._bbox);
    const scale = new Float32Array(2);
    if (pathType === PathType.SHADING) {
      Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);
    } else if (this.matrix) {
      Util.singularValueDecompose2dScale(this.matrix, scale);
      const [matrixScaleX, matrixScaleY] = scale;
      Util.singularValueDecompose2dScale(owner.baseTransform, scale);
      scale[0] *= matrixScaleX;
      scale[1] *= matrixScaleY;
    } else {
      Util.singularValueDecompose2dScale(owner.baseTransform, scale);
    }
    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
    if (pathType !== PathType.SHADING) {
      ctx.setTransform(...owner.baseTransform);
      if (this.matrix) {
        ctx.transform(...this.matrix);
      }
    }
    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
  }
};
var DummyShadingPattern = class extends BaseShadingPattern {
  getPattern() {
    return "hotpink";
  }
};
function getShadingPattern(IR) {
  switch (IR[0]) {
    case "RadialAxial":
      return new RadialAxialShadingPattern(IR);
    case "Mesh":
      return new MeshShadingPattern(IR);
    case "Dummy":
      return new DummyShadingPattern();
  }
  throw new Error(`Unknown IR type: ${IR[0]}`);
}
var PaintType = {
  COLORED: 1,
  UNCOLORED: 2
};
var _TilingPattern = class _TilingPattern {
  constructor(IR, ctx, canvasGraphicsFactory, baseTransform) {
    this.color = IR[1];
    this.operatorList = IR[2];
    this.matrix = IR[3];
    this.bbox = IR[4];
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.ctx = ctx;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
  }
  createPatternCanvas(owner) {
    var _a3, _b2, _c, _d;
    const {
      bbox,
      operatorList,
      paintType,
      tilingType,
      color,
      canvasGraphicsFactory
    } = this;
    let {
      xstep,
      ystep
    } = this;
    xstep = Math.abs(xstep);
    ystep = Math.abs(ystep);
    info("TilingType: " + tilingType);
    const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
    const width = x1 - x0;
    const height = y1 - y0;
    const scale = new Float32Array(2);
    Util.singularValueDecompose2dScale(this.matrix, scale);
    const [matrixScaleX, matrixScaleY] = scale;
    Util.singularValueDecompose2dScale(this.baseTransform, scale);
    const combinedScaleX = matrixScaleX * scale[0];
    const combinedScaleY = matrixScaleY * scale[1];
    let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;
    const xScaledStep = Math.ceil(xstep * combinedScaleX);
    const yScaledStep = Math.ceil(ystep * combinedScaleY);
    const xScaledWidth = Math.ceil(width * combinedScaleX);
    const yScaledHeight = Math.ceil(height * combinedScaleY);
    if (xScaledStep >= xScaledWidth) {
      canvasWidth = xstep;
    } else {
      redrawHorizontally = true;
    }
    if (yScaledStep >= yScaledHeight) {
      canvasHeight = ystep;
    } else {
      redrawVertically = true;
    }
    const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
    const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size);
    const tmpCtx = tmpCanvas.context;
    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
    graphics.groupLevel = owner.groupLevel;
    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
    tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);
    graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);
    tmpCtx.save();
    (_a3 = graphics.dependencyTracker) == null ? void 0 : _a3.save();
    this.clipBbox(graphics, x0, y0, x1, y1);
    graphics.baseTransform = getCurrentTransform(graphics.ctx);
    graphics.executeOperatorList(operatorList);
    graphics.endDrawing();
    (_d = (_b2 = graphics.dependencyTracker) == null ? void 0 : (_c = _b2.restore()).recordNestedDependencies) == null ? void 0 : _d.call(_c);
    tmpCtx.restore();
    if (redrawHorizontally || redrawVertically) {
      const image = tmpCanvas.canvas;
      if (redrawHorizontally) {
        canvasWidth = xstep;
      }
      if (redrawVertically) {
        canvasHeight = ystep;
      }
      const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
      const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
      const xSize = dimx2.size;
      const ySize = dimy2.size;
      const tmpCanvas2 = owner.cachedCanvases.getCanvas("pattern-workaround", xSize, ySize);
      const tmpCtx2 = tmpCanvas2.context;
      const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;
      const jj = redrawVertically ? Math.floor(height / ystep) : 0;
      for (let i = 0; i <= ii; i++) {
        for (let j = 0; j <= jj; j++) {
          tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);
        }
      }
      return {
        canvas: tmpCanvas2.canvas,
        scaleX: dimx2.scale,
        scaleY: dimy2.scale,
        offsetX: x0,
        offsetY: y0
      };
    }
    return {
      canvas: tmpCanvas.canvas,
      scaleX: dimx.scale,
      scaleY: dimy.scale,
      offsetX: x0,
      offsetY: y0
    };
  }
  getSizeAndScale(step, realOutputSize, scale) {
    const maxSize = Math.max(_TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
    let size = Math.ceil(step * scale);
    if (size >= maxSize) {
      size = maxSize;
    } else {
      scale = size / step;
    }
    return {
      scale,
      size
    };
  }
  clipBbox(graphics, x0, y0, x1, y1) {
    const bboxWidth = x1 - x0;
    const bboxHeight = y1 - y0;
    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
    Util.axialAlignedBoundingBox([x0, y0, x1, y1], getCurrentTransform(graphics.ctx), graphics.current.minMax);
    graphics.clip();
    graphics.endPath();
  }
  setFillAndStrokeStyleToContext(graphics, paintType, color) {
    const context = graphics.ctx, current = graphics.current;
    switch (paintType) {
      case PaintType.COLORED:
        const {
          fillStyle,
          strokeStyle
        } = this.ctx;
        context.fillStyle = current.fillColor = fillStyle;
        context.strokeStyle = current.strokeColor = strokeStyle;
        break;
      case PaintType.UNCOLORED:
        context.fillStyle = context.strokeStyle = color;
        current.fillColor = current.strokeColor = color;
        break;
      default:
        throw new FormatError(`Unsupported paint type: ${paintType}`);
    }
  }
  isModifyingCurrentTransform() {
    return false;
  }
  getPattern(ctx, owner, inverse, pathType) {
    let matrix = inverse;
    if (pathType !== PathType.SHADING) {
      matrix = Util.transform(matrix, owner.baseTransform);
      if (this.matrix) {
        matrix = Util.transform(matrix, this.matrix);
      }
    }
    const temporaryPatternCanvas = this.createPatternCanvas(owner);
    let domMatrix = new DOMMatrix(matrix);
    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
    pattern.setTransform(domMatrix);
    return pattern;
  }
};
__publicField(_TilingPattern, "MAX_PATTERN_SIZE", 3e3);
var TilingPattern = _TilingPattern;
function convertBlackAndWhiteToRGBA({
  src,
  srcPos = 0,
  dest,
  width,
  height,
  nonBlackColor = 4294967295,
  inverseDecode = false
}) {
  const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
  const widthInSource = width >> 3;
  const widthRemainder = width & 7;
  const srcLength = src.length;
  dest = new Uint32Array(dest.buffer);
  let destPos = 0;
  for (let i = 0; i < height; i++) {
    for (const max2 = srcPos + widthInSource; srcPos < max2; srcPos++) {
      const elem2 = srcPos < srcLength ? src[srcPos] : 255;
      dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
    }
    if (widthRemainder === 0) {
      continue;
    }
    const elem = srcPos < srcLength ? src[srcPos++] : 255;
    for (let j = 0; j < widthRemainder; j++) {
      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
    }
  }
  return {
    srcPos,
    destPos
  };
}
var MIN_FONT_SIZE = 16;
var MAX_FONT_SIZE = 100;
var EXECUTION_TIME = 15;
var EXECUTION_STEPS = 10;
var FULL_CHUNK_HEIGHT = 16;
var SCALE_MATRIX = new DOMMatrix();
var XY = new Float32Array(2);
var MIN_MAX_INIT = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
function mirrorContextOperations(ctx, destCtx) {
  if (ctx._removeMirroring) {
    throw new Error("Context is already forwarding operations.");
  }
  ctx.__originalSave = ctx.save;
  ctx.__originalRestore = ctx.restore;
  ctx.__originalRotate = ctx.rotate;
  ctx.__originalScale = ctx.scale;
  ctx.__originalTranslate = ctx.translate;
  ctx.__originalTransform = ctx.transform;
  ctx.__originalSetTransform = ctx.setTransform;
  ctx.__originalResetTransform = ctx.resetTransform;
  ctx.__originalClip = ctx.clip;
  ctx.__originalMoveTo = ctx.moveTo;
  ctx.__originalLineTo = ctx.lineTo;
  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
  ctx.__originalRect = ctx.rect;
  ctx.__originalClosePath = ctx.closePath;
  ctx.__originalBeginPath = ctx.beginPath;
  ctx._removeMirroring = () => {
    ctx.save = ctx.__originalSave;
    ctx.restore = ctx.__originalRestore;
    ctx.rotate = ctx.__originalRotate;
    ctx.scale = ctx.__originalScale;
    ctx.translate = ctx.__originalTranslate;
    ctx.transform = ctx.__originalTransform;
    ctx.setTransform = ctx.__originalSetTransform;
    ctx.resetTransform = ctx.__originalResetTransform;
    ctx.clip = ctx.__originalClip;
    ctx.moveTo = ctx.__originalMoveTo;
    ctx.lineTo = ctx.__originalLineTo;
    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
    ctx.rect = ctx.__originalRect;
    ctx.closePath = ctx.__originalClosePath;
    ctx.beginPath = ctx.__originalBeginPath;
    delete ctx._removeMirroring;
  };
  ctx.save = function() {
    destCtx.save();
    this.__originalSave();
  };
  ctx.restore = function() {
    destCtx.restore();
    this.__originalRestore();
  };
  ctx.translate = function(x, y) {
    destCtx.translate(x, y);
    this.__originalTranslate(x, y);
  };
  ctx.scale = function(x, y) {
    destCtx.scale(x, y);
    this.__originalScale(x, y);
  };
  ctx.transform = function(a, b, c, d, e, f) {
    destCtx.transform(a, b, c, d, e, f);
    this.__originalTransform(a, b, c, d, e, f);
  };
  ctx.setTransform = function(a, b, c, d, e, f) {
    destCtx.setTransform(a, b, c, d, e, f);
    this.__originalSetTransform(a, b, c, d, e, f);
  };
  ctx.resetTransform = function() {
    destCtx.resetTransform();
    this.__originalResetTransform();
  };
  ctx.rotate = function(angle) {
    destCtx.rotate(angle);
    this.__originalRotate(angle);
  };
  ctx.clip = function(rule) {
    destCtx.clip(rule);
    this.__originalClip(rule);
  };
  ctx.moveTo = function(x, y) {
    destCtx.moveTo(x, y);
    this.__originalMoveTo(x, y);
  };
  ctx.lineTo = function(x, y) {
    destCtx.lineTo(x, y);
    this.__originalLineTo(x, y);
  };
  ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  };
  ctx.rect = function(x, y, width, height) {
    destCtx.rect(x, y, width, height);
    this.__originalRect(x, y, width, height);
  };
  ctx.closePath = function() {
    destCtx.closePath();
    this.__originalClosePath();
  };
  ctx.beginPath = function() {
    destCtx.beginPath();
    this.__originalBeginPath();
  };
}
var CachedCanvases = class {
  constructor(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(id, width, height) {
    let canvasEntry;
    if (this.cache[id] !== void 0) {
      canvasEntry = this.cache[id];
      this.canvasFactory.reset(canvasEntry, width, height);
    } else {
      canvasEntry = this.canvasFactory.create(width, height);
      this.cache[id] = canvasEntry;
    }
    return canvasEntry;
  }
  delete(id) {
    delete this.cache[id];
  }
  clear() {
    for (const id in this.cache) {
      const canvasEntry = this.cache[id];
      this.canvasFactory.destroy(canvasEntry);
      delete this.cache[id];
    }
  }
};
function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
  const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
  if (b === 0 && c === 0) {
    const tlX = destX * a + tx;
    const rTlX = Math.round(tlX);
    const tlY = destY * d + ty;
    const rTlY = Math.round(tlY);
    const brX = (destX + destW) * a + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destY + destH) * d + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rWidth, rHeight];
  }
  if (a === 0 && d === 0) {
    const tlX = destY * c + tx;
    const rTlX = Math.round(tlX);
    const tlY = destX * b + ty;
    const rTlY = Math.round(tlY);
    const brX = (destY + destH) * c + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destX + destW) * b + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rHeight, rWidth];
  }
  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
  const scaleX = Math.hypot(a, b);
  const scaleY = Math.hypot(c, d);
  return [scaleX * destW, scaleY * destH];
}
var CanvasExtraState = class {
  constructor(width, height, preInit) {
    __publicField(this, "alphaIsShape", false);
    __publicField(this, "fontSize", 0);
    __publicField(this, "fontSizeScale", 1);
    __publicField(this, "textMatrix", null);
    __publicField(this, "textMatrixScale", 1);
    __publicField(this, "fontMatrix", FONT_IDENTITY_MATRIX);
    __publicField(this, "leading", 0);
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "lineX", 0);
    __publicField(this, "lineY", 0);
    __publicField(this, "charSpacing", 0);
    __publicField(this, "wordSpacing", 0);
    __publicField(this, "textHScale", 1);
    __publicField(this, "textRenderingMode", TextRenderingMode.FILL);
    __publicField(this, "textRise", 0);
    __publicField(this, "fillColor", "#000000");
    __publicField(this, "strokeColor", "#000000");
    __publicField(this, "patternFill", false);
    __publicField(this, "patternStroke", false);
    __publicField(this, "fillAlpha", 1);
    __publicField(this, "strokeAlpha", 1);
    __publicField(this, "lineWidth", 1);
    __publicField(this, "activeSMask", null);
    __publicField(this, "transferMaps", "none");
    preInit == null ? void 0 : preInit(this);
    this.clipBox = new Float32Array([0, 0, width, height]);
    this.minMax = MIN_MAX_INIT.slice();
  }
  clone() {
    const clone = Object.create(this);
    clone.clipBox = this.clipBox.slice();
    clone.minMax = this.minMax.slice();
    return clone;
  }
  getPathBoundingBox(pathType = PathType.FILL, transform = null) {
    const box = this.minMax.slice();
    if (pathType === PathType.STROKE) {
      if (!transform) {
        unreachable("Stroke bounding box must include transform.");
      }
      Util.singularValueDecompose2dScale(transform, XY);
      const xStrokePad = XY[0] * this.lineWidth / 2;
      const yStrokePad = XY[1] * this.lineWidth / 2;
      box[0] -= xStrokePad;
      box[1] -= yStrokePad;
      box[2] += xStrokePad;
      box[3] += yStrokePad;
    }
    return box;
  }
  updateClipFromPath() {
    const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minMax[0] === Infinity;
  }
  startNewPathAndClipBox(box) {
    this.clipBox.set(box, 0);
    this.minMax.set(MIN_MAX_INIT, 0);
  }
  getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
    return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
  }
};
function putBinaryImageData(ctx, imgData) {
  if (imgData instanceof ImageData) {
    ctx.putImageData(imgData, 0, 0);
    return;
  }
  const height = imgData.height, width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0, destPos;
  const src = imgData.data;
  const dest = chunkImgData.data;
  let i, j, thisChunkHeight, elemsInThisChunk;
  if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {
    const srcLength = src.byteLength;
    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
    const dest32DataLength = dest32.length;
    const fullSrcDiff = width + 7 >> 3;
    const white = 4294967295;
    const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
    for (i = 0; i < totalChunks; i++) {
      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      destPos = 0;
      for (j = 0; j < thisChunkHeight; j++) {
        const srcDiff = srcLength - srcPos;
        let k = 0;
        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
        const kEndUnrolled = kEnd & ~7;
        let mask = 0;
        let srcByte = 0;
        for (; k < kEndUnrolled; k += 8) {
          srcByte = src[srcPos++];
          dest32[destPos++] = srcByte & 128 ? white : black;
          dest32[destPos++] = srcByte & 64 ? white : black;
          dest32[destPos++] = srcByte & 32 ? white : black;
          dest32[destPos++] = srcByte & 16 ? white : black;
          dest32[destPos++] = srcByte & 8 ? white : black;
          dest32[destPos++] = srcByte & 4 ? white : black;
          dest32[destPos++] = srcByte & 2 ? white : black;
          dest32[destPos++] = srcByte & 1 ? white : black;
        }
        for (; k < kEnd; k++) {
          if (mask === 0) {
            srcByte = src[srcPos++];
            mask = 128;
          }
          dest32[destPos++] = srcByte & mask ? white : black;
          mask >>= 1;
        }
      }
      while (destPos < dest32DataLength) {
        dest32[destPos++] = 0;
      }
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {
    j = 0;
    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
    for (i = 0; i < fullChunks; i++) {
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      srcPos += elemsInThisChunk;
      ctx.putImageData(chunkImgData, 0, j);
      j += FULL_CHUNK_HEIGHT;
    }
    if (i < totalChunks) {
      elemsInThisChunk = width * partialChunkHeight * 4;
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      ctx.putImageData(chunkImgData, 0, j);
    }
  } else if (imgData.kind === util_ImageKind.RGB_24BPP) {
    thisChunkHeight = FULL_CHUNK_HEIGHT;
    elemsInThisChunk = width * thisChunkHeight;
    for (i = 0; i < totalChunks; i++) {
      if (i >= fullChunks) {
        thisChunkHeight = partialChunkHeight;
        elemsInThisChunk = width * thisChunkHeight;
      }
      destPos = 0;
      for (j = elemsInThisChunk; j--; ) {
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = 255;
      }
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else {
    throw new Error(`bad image kind: ${imgData.kind}`);
  }
}
function putBinaryImageMask(ctx, imgData) {
  if (imgData.bitmap) {
    ctx.drawImage(imgData.bitmap, 0, 0);
    return;
  }
  const height = imgData.height, width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0;
  const src = imgData.data;
  const dest = chunkImgData.data;
  for (let i = 0; i < totalChunks; i++) {
    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
    ({
      srcPos
    } = convertBlackAndWhiteToRGBA({
      src,
      srcPos,
      dest,
      width,
      height: thisChunkHeight,
      nonBlackColor: 0
    }));
    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
  }
}
function copyCtxState(sourceCtx, destCtx) {
  const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const property of properties) {
    if (sourceCtx[property] !== void 0) {
      destCtx[property] = sourceCtx[property];
    }
  }
  if (sourceCtx.setLineDash !== void 0) {
    destCtx.setLineDash(sourceCtx.getLineDash());
    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
  }
}
function resetCtxToDefault(ctx) {
  ctx.strokeStyle = ctx.fillStyle = "#000000";
  ctx.fillRule = "nonzero";
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.lineCap = "butt";
  ctx.lineJoin = "miter";
  ctx.miterLimit = 10;
  ctx.globalCompositeOperation = "source-over";
  ctx.font = "10px sans-serif";
  if (ctx.setLineDash !== void 0) {
    ctx.setLineDash([]);
    ctx.lineDashOffset = 0;
  }
  const {
    filter
  } = ctx;
  if (filter !== "none" && filter !== "") {
    ctx.filter = "none";
  }
}
function getImageSmoothingEnabled(transform, interpolate) {
  if (interpolate) {
    return true;
  }
  Util.singularValueDecompose2dScale(transform, XY);
  const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);
  return XY[0] <= actualScale && XY[1] <= actualScale;
}
var LINE_CAP_STYLES = ["butt", "round", "square"];
var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
var NORMAL_CLIP = {};
var EO_CLIP = {};
var _restoreInitialState, restoreInitialState_fn, _drawFilter, drawFilter_fn, _getScaledPath, getScaledPath_fn;
var _CanvasGraphics = class _CanvasGraphics {
  constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
    optionalContentConfig,
    markedContentStack = null
  }, annotationCanvasMap, pageColors, dependencyTracker) {
    __privateAdd(this, _restoreInitialState);
    __privateAdd(this, _drawFilter);
    __privateAdd(this, _getScaledPath);
    this.ctx = canvasCtx;
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this.groupStack = [];
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.suspendedCtx = null;
    this.contentVisible = true;
    this.markedContentStack = markedContentStack || [];
    this.optionalContentConfig = optionalContentConfig;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
    this.cachedPatterns = /* @__PURE__ */ new Map();
    this.annotationCanvasMap = annotationCanvasMap;
    this.viewportScale = 1;
    this.outputScaleX = 1;
    this.outputScaleY = 1;
    this.pageColors = pageColors;
    this._cachedScaleForStroking = [-1, 0];
    this._cachedGetSinglePixelWidth = null;
    this._cachedBitmapsMap = /* @__PURE__ */ new Map();
    this.dependencyTracker = dependencyTracker != null ? dependencyTracker : null;
  }
  getObject(opIdx, data, fallback = null) {
    var _a3;
    if (typeof data === "string") {
      (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordNamedDependency(opIdx, data);
      return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
    }
    return fallback;
  }
  beginDrawing({
    transform,
    viewport,
    transparency = false,
    background: background2 = null
  }) {
    const width = this.ctx.canvas.width;
    const height = this.ctx.canvas.height;
    const savedFillStyle = this.ctx.fillStyle;
    this.ctx.fillStyle = background2 || "#ffffff";
    this.ctx.fillRect(0, 0, width, height);
    this.ctx.fillStyle = savedFillStyle;
    if (transparency) {
      const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
      this.compositeCtx = this.ctx;
      this.transparentCanvas = transparentCanvas.canvas;
      this.ctx = transparentCanvas.context;
      this.ctx.save();
      this.ctx.transform(...getCurrentTransform(this.compositeCtx));
    }
    this.ctx.save();
    resetCtxToDefault(this.ctx);
    if (transform) {
      this.ctx.transform(...transform);
      this.outputScaleX = transform[0];
      this.outputScaleY = transform[0];
    }
    this.ctx.transform(...viewport.transform);
    this.viewportScale = viewport.scale;
    this.baseTransform = getCurrentTransform(this.ctx);
  }
  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, filteredOperationIndexes) {
    var _a3, _b2;
    const argsArray = operatorList.argsArray;
    const fnArray = operatorList.fnArray;
    let i = executionStartIdx || 0;
    const argsArrayLen = argsArray.length;
    if (argsArrayLen === i) {
      return i;
    }
    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
    let steps = 0;
    const commonObjs = this.commonObjs;
    const objs = this.objs;
    let fnId, fnArgs;
    while (true) {
      if (stepper !== void 0 && i === stepper.nextBreakPoint) {
        stepper.breakIt(i, continueCallback);
        return i;
      }
      if (!filteredOperationIndexes || filteredOperationIndexes.has(i)) {
        fnId = fnArray[i];
        fnArgs = (_a3 = argsArray[i]) != null ? _a3 : null;
        if (fnId !== OPS.dependency) {
          if (fnArgs === null) {
            this[fnId](i);
          } else {
            this[fnId](i, ...fnArgs);
          }
        } else {
          for (const depObjId of fnArgs) {
            (_b2 = this.dependencyTracker) == null ? void 0 : _b2.recordNamedData(depObjId, i);
            const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
            if (!objsPool.has(depObjId)) {
              objsPool.get(depObjId, continueCallback);
              return i;
            }
          }
        }
      }
      i++;
      if (i === argsArrayLen) {
        return i;
      }
      if (chunkOperations && ++steps > EXECUTION_STEPS) {
        if (Date.now() > endTime) {
          continueCallback();
          return i;
        }
        steps = 0;
      }
    }
  }
  endDrawing() {
    __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
    this.cachedCanvases.clear();
    this.cachedPatterns.clear();
    for (const cache of this._cachedBitmapsMap.values()) {
      for (const canvas of cache.values()) {
        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
          canvas.width = canvas.height = 0;
        }
      }
      cache.clear();
    }
    this._cachedBitmapsMap.clear();
    __privateMethod(this, _drawFilter, drawFilter_fn).call(this);
  }
  _scaleImage(img, inverseTransform) {
    var _a3, _b2;
    const width = (_a3 = img.width) != null ? _a3 : img.displayWidth;
    const height = (_b2 = img.height) != null ? _b2 : img.displayHeight;
    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
    let paintWidth = width, paintHeight = height;
    let tmpCanvasId = "prescale1";
    let tmpCanvas, tmpCtx;
    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
      let newWidth = paintWidth, newHeight = paintHeight;
      if (widthScale > 2 && paintWidth > 1) {
        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
        widthScale /= paintWidth / newWidth;
      }
      if (heightScale > 2 && paintHeight > 1) {
        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
        heightScale /= paintHeight / newHeight;
      }
      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
      tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, newWidth, newHeight);
      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
      img = tmpCanvas.canvas;
      paintWidth = newWidth;
      paintHeight = newHeight;
      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img,
      paintWidth,
      paintHeight
    };
  }
  _createMaskCanvas(opIdx, img) {
    var _a3, _b2;
    const ctx = this.ctx;
    const {
      width,
      height
    } = img;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    const currentTransform = getCurrentTransform(ctx);
    let cache, cacheKey, scaled, maskCanvas;
    if ((img.bitmap || img.data) && img.count > 1) {
      const mainKey = img.bitmap || img.data.buffer;
      cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
      cache = this._cachedBitmapsMap.get(mainKey);
      if (!cache) {
        cache = /* @__PURE__ */ new Map();
        this._cachedBitmapsMap.set(mainKey, cache);
      }
      const cachedImage = cache.get(cacheKey);
      if (cachedImage && !isPatternFill) {
        const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
        const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
        (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordDependencies(opIdx, Dependencies.transformAndFill);
        return {
          canvas: cachedImage,
          offsetX: offsetX2,
          offsetY: offsetY2
        };
      }
      scaled = cachedImage;
    }
    if (!scaled) {
      maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      putBinaryImageMask(maskCanvas.context, img);
    }
    let maskToCanvas = Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
    maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
    const minMax = MIN_MAX_INIT.slice();
    Util.axialAlignedBoundingBox([0, 0, width, height], maskToCanvas, minMax);
    const [minX, minY, maxX, maxY] = minMax;
    const drawnWidth = Math.round(maxX - minX) || 1;
    const drawnHeight = Math.round(maxY - minY) || 1;
    const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
    const fillCtx = fillCanvas.context;
    const offsetX = minX;
    const offsetY = minY;
    fillCtx.translate(-offsetX, -offsetY);
    fillCtx.transform(...maskToCanvas);
    if (!scaled) {
      scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));
      scaled = scaled.img;
      if (cache && isPatternFill) {
        cache.set(cacheKey, scaled);
      }
    }
    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);
    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
    fillCtx.globalCompositeOperation = "source-in";
    const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;
    fillCtx.fillRect(0, 0, width, height);
    if (cache && !isPatternFill) {
      this.cachedCanvases.delete("fillCanvas");
      cache.set(cacheKey, fillCanvas.canvas);
    }
    (_b2 = this.dependencyTracker) == null ? void 0 : _b2.recordDependencies(opIdx, Dependencies.transformAndFill);
    return {
      canvas: fillCanvas.canvas,
      offsetX: Math.round(offsetX),
      offsetY: Math.round(offsetY)
    };
  }
  setLineWidth(opIdx, width) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("lineWidth", opIdx);
    if (width !== this.current.lineWidth) {
      this._cachedScaleForStroking[0] = -1;
    }
    this.current.lineWidth = width;
    this.ctx.lineWidth = width;
  }
  setLineCap(opIdx, style) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("lineCap", opIdx);
    this.ctx.lineCap = LINE_CAP_STYLES[style];
  }
  setLineJoin(opIdx, style) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("lineJoin", opIdx);
    this.ctx.lineJoin = LINE_JOIN_STYLES[style];
  }
  setMiterLimit(opIdx, limit) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("miterLimit", opIdx);
    this.ctx.miterLimit = limit;
  }
  setDash(opIdx, dashArray, dashPhase) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("dash", opIdx);
    const ctx = this.ctx;
    if (ctx.setLineDash !== void 0) {
      ctx.setLineDash(dashArray);
      ctx.lineDashOffset = dashPhase;
    }
  }
  setRenderingIntent(opIdx, intent) {
  }
  setFlatness(opIdx, flatness) {
  }
  setGState(opIdx, states) {
    var _a3, _b2, _c, _d, _e;
    for (const [key, value] of states) {
      switch (key) {
        case "LW":
          this.setLineWidth(opIdx, value);
          break;
        case "LC":
          this.setLineCap(opIdx, value);
          break;
        case "LJ":
          this.setLineJoin(opIdx, value);
          break;
        case "ML":
          this.setMiterLimit(opIdx, value);
          break;
        case "D":
          this.setDash(opIdx, value[0], value[1]);
          break;
        case "RI":
          this.setRenderingIntent(opIdx, value);
          break;
        case "FL":
          this.setFlatness(opIdx, value);
          break;
        case "Font":
          this.setFont(opIdx, value[0], value[1]);
          break;
        case "CA":
          (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("strokeAlpha", opIdx);
          this.current.strokeAlpha = value;
          break;
        case "ca":
          (_b2 = this.dependencyTracker) == null ? void 0 : _b2.recordSimpleData("fillAlpha", opIdx);
          this.ctx.globalAlpha = this.current.fillAlpha = value;
          break;
        case "BM":
          (_c = this.dependencyTracker) == null ? void 0 : _c.recordSimpleData("globalCompositeOperation", opIdx);
          this.ctx.globalCompositeOperation = value;
          break;
        case "SMask":
          (_d = this.dependencyTracker) == null ? void 0 : _d.recordSimpleData("SMask", opIdx);
          this.current.activeSMask = value ? this.tempSMask : null;
          this.tempSMask = null;
          this.checkSMaskState();
          break;
        case "TR":
          (_e = this.dependencyTracker) == null ? void 0 : _e.recordSimpleData("filter", opIdx);
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
          break;
      }
    }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const inSMaskMode = this.inSMaskMode;
    if (this.current.activeSMask && !inSMaskMode) {
      this.beginSMaskMode();
    } else if (!this.current.activeSMask && inSMaskMode) {
      this.endSMaskMode();
    }
  }
  beginSMaskMode(opIdx) {
    if (this.inSMaskMode) {
      throw new Error("beginSMaskMode called while already in smask mode");
    }
    const drawnWidth = this.ctx.canvas.width;
    const drawnHeight = this.ctx.canvas.height;
    const cacheId = "smaskGroupAt" + this.groupLevel;
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    this.suspendedCtx = this.ctx;
    const ctx = this.ctx = scratchCanvas.context;
    ctx.setTransform(this.suspendedCtx.getTransform());
    copyCtxState(this.suspendedCtx, ctx);
    mirrorContextOperations(ctx, this.suspendedCtx);
    this.setGState(opIdx, [["BM", "source-over"]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode) {
      throw new Error("endSMaskMode called while not in smask mode");
    }
    this.ctx._removeMirroring();
    copyCtxState(this.ctx, this.suspendedCtx);
    this.ctx = this.suspendedCtx;
    this.suspendedCtx = null;
  }
  compose(dirtyBox) {
    if (!this.current.activeSMask) {
      return;
    }
    if (!dirtyBox) {
      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    } else {
      dirtyBox[0] = Math.floor(dirtyBox[0]);
      dirtyBox[1] = Math.floor(dirtyBox[1]);
      dirtyBox[2] = Math.ceil(dirtyBox[2]);
      dirtyBox[3] = Math.ceil(dirtyBox[3]);
    }
    const smask = this.current.activeSMask;
    const suspendedCtx = this.suspendedCtx;
    this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore();
  }
  composeSMask(ctx, smask, layerCtx, layerBox) {
    const layerOffsetX = layerBox[0];
    const layerOffsetY = layerBox[1];
    const layerWidth = layerBox[2] - layerOffsetX;
    const layerHeight = layerBox[3] - layerOffsetY;
    if (layerWidth === 0 || layerHeight === 0) {
      return;
    }
    this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(layerCtx.canvas, 0, 0);
    ctx.restore();
  }
  genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
    let maskCanvas = maskCtx.canvas;
    let maskX = layerOffsetX - maskOffsetX;
    let maskY = layerOffsetY - maskOffsetY;
    if (backdrop) {
      if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {
        const canvas = this.cachedCanvases.getCanvas("maskExtension", width, height);
        const ctx = canvas.context;
        ctx.drawImage(maskCanvas, -maskX, -maskY);
        ctx.globalCompositeOperation = "destination-atop";
        ctx.fillStyle = backdrop;
        ctx.fillRect(0, 0, width, height);
        ctx.globalCompositeOperation = "source-over";
        maskCanvas = canvas.canvas;
        maskX = maskY = 0;
      } else {
        maskCtx.save();
        maskCtx.globalAlpha = 1;
        maskCtx.setTransform(1, 0, 0, 1, 0, 0);
        const clip2 = new Path2D();
        clip2.rect(maskX, maskY, width, height);
        maskCtx.clip(clip2);
        maskCtx.globalCompositeOperation = "destination-atop";
        maskCtx.fillStyle = backdrop;
        maskCtx.fillRect(maskX, maskY, width, height);
        maskCtx.restore();
      }
    }
    layerCtx.save();
    layerCtx.globalAlpha = 1;
    layerCtx.setTransform(1, 0, 0, 1, 0, 0);
    if (subtype === "Alpha" && transferMap) {
      layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
    } else if (subtype === "Luminosity") {
      layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
    }
    const clip = new Path2D();
    clip.rect(layerOffsetX, layerOffsetY, width, height);
    layerCtx.clip(clip);
    layerCtx.globalCompositeOperation = "destination-in";
    layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);
    layerCtx.restore();
  }
  save(opIdx) {
    var _a3;
    if (this.inSMaskMode) {
      copyCtxState(this.ctx, this.suspendedCtx);
    }
    this.ctx.save();
    const old = this.current;
    this.stateStack.push(old);
    this.current = old.clone();
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.save(opIdx);
  }
  restore(opIdx) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.restore(opIdx);
    if (this.stateStack.length === 0) {
      if (this.inSMaskMode) {
        this.endSMaskMode();
      }
      return;
    }
    this.current = this.stateStack.pop();
    this.ctx.restore();
    if (this.inSMaskMode) {
      copyCtxState(this.suspendedCtx, this.ctx);
    }
    this.checkSMaskState();
    this.pendingClip = null;
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
  }
  transform(opIdx, a, b, c, d, e, f) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordIncrementalData("transform", opIdx);
    this.ctx.transform(a, b, c, d, e, f);
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
  }
  constructPath(opIdx, op, data, minMax) {
    let [path2] = data;
    if (!minMax) {
      path2 || (path2 = data[0] = new Path2D());
      this[op](opIdx, path2);
      return;
    }
    if (this.dependencyTracker !== null) {
      const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;
      this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, ["transform"]);
    }
    if (!(path2 instanceof Path2D)) {
      const path2d = data[0] = new Path2D();
      for (let i = 0, ii = path2.length; i < ii; ) {
        switch (path2[i++]) {
          case DrawOPS.moveTo:
            path2d.moveTo(path2[i++], path2[i++]);
            break;
          case DrawOPS.lineTo:
            path2d.lineTo(path2[i++], path2[i++]);
            break;
          case DrawOPS.curveTo:
            path2d.bezierCurveTo(path2[i++], path2[i++], path2[i++], path2[i++], path2[i++], path2[i++]);
            break;
          case DrawOPS.closePath:
            path2d.closePath();
            break;
          default:
            warn(`Unrecognized drawing path operator: ${path2[i - 1]}`);
            break;
        }
      }
      path2 = path2d;
    }
    Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);
    this[op](opIdx, path2);
    this._pathStartIdx = opIdx;
  }
  closePath(opIdx) {
    this.ctx.closePath();
  }
  stroke(opIdx, path2, consumePath = true) {
    var _a3;
    const ctx = this.ctx;
    const strokeColor = this.current.strokeColor;
    ctx.globalAlpha = this.current.strokeAlpha;
    if (this.contentVisible) {
      if (typeof strokeColor === "object" && (strokeColor == null ? void 0 : strokeColor.getPattern)) {
        const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
        ctx.save();
        ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);
        if (baseTransform) {
          const newPath = new Path2D();
          newPath.addPath(path2, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
          path2 = newPath;
        }
        this.rescaleAndStroke(path2, false);
        ctx.restore();
      } else {
        this.rescaleAndStroke(path2, true);
      }
    }
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordDependencies(opIdx, Dependencies.stroke);
    if (consumePath) {
      this.consumePath(opIdx, path2, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));
    }
    ctx.globalAlpha = this.current.fillAlpha;
  }
  closeStroke(opIdx, path2) {
    this.stroke(opIdx, path2);
  }
  fill(opIdx, path2, consumePath = true) {
    var _a3, _b2, _c;
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    let needRestore = false;
    if (isPatternFill) {
      const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
      (_a3 = this.dependencyTracker) == null ? void 0 : _a3.save(opIdx);
      ctx.save();
      ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);
      if (baseTransform) {
        const newPath = new Path2D();
        newPath.addPath(path2, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
        path2 = newPath;
      }
      needRestore = true;
    }
    const intersect = this.current.getClippedPathBoundingBox();
    if (this.contentVisible && intersect !== null) {
      if (this.pendingEOFill) {
        ctx.fill(path2, "evenodd");
        this.pendingEOFill = false;
      } else {
        ctx.fill(path2);
      }
    }
    (_b2 = this.dependencyTracker) == null ? void 0 : _b2.recordDependencies(opIdx, Dependencies.fill);
    if (needRestore) {
      ctx.restore();
      (_c = this.dependencyTracker) == null ? void 0 : _c.restore(opIdx);
    }
    if (consumePath) {
      this.consumePath(opIdx, path2, intersect);
    }
  }
  eoFill(opIdx, path2) {
    this.pendingEOFill = true;
    this.fill(opIdx, path2);
  }
  fillStroke(opIdx, path2) {
    this.fill(opIdx, path2, false);
    this.stroke(opIdx, path2, false);
    this.consumePath(opIdx, path2);
  }
  eoFillStroke(opIdx, path2) {
    this.pendingEOFill = true;
    this.fillStroke(opIdx, path2);
  }
  closeFillStroke(opIdx, path2) {
    this.fillStroke(opIdx, path2);
  }
  closeEOFillStroke(opIdx, path2) {
    this.pendingEOFill = true;
    this.fillStroke(opIdx, path2);
  }
  endPath(opIdx, path2) {
    this.consumePath(opIdx, path2);
  }
  rawFillPath(opIdx, path2) {
    var _a3;
    this.ctx.fill(path2);
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);
  }
  clip(opIdx) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordFutureForcedDependency("clipMode", opIdx);
    this.pendingClip = NORMAL_CLIP;
  }
  eoClip(opIdx) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordFutureForcedDependency("clipMode", opIdx);
    this.pendingClip = EO_CLIP;
  }
  beginText(opIdx) {
    var _a3;
    this.current.textMatrix = null;
    this.current.textMatrixScale = 1;
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordOpenMarker(opIdx).resetIncrementalData("sameLineText").resetIncrementalData("moveText", opIdx);
  }
  endText(opIdx) {
    const paths = this.pendingTextPaths;
    const ctx = this.ctx;
    if (this.dependencyTracker) {
      const {
        dependencyTracker
      } = this;
      if (paths !== void 0) {
        dependencyTracker.recordFutureForcedDependency("textClip", dependencyTracker.getOpenMarker()).recordFutureForcedDependency("textClip", opIdx);
      }
      dependencyTracker.recordCloseMarker(opIdx);
    }
    if (paths !== void 0) {
      const newPath = new Path2D();
      const invTransf = ctx.getTransform().invertSelf();
      for (const {
        transform,
        x,
        y,
        fontSize,
        path: path2
      } of paths) {
        if (!path2) {
          continue;
        }
        newPath.addPath(path2, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));
      }
      ctx.clip(newPath);
    }
    delete this.pendingTextPaths;
  }
  setCharSpacing(opIdx, spacing) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("charSpacing", opIdx);
    this.current.charSpacing = spacing;
  }
  setWordSpacing(opIdx, spacing) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("wordSpacing", opIdx);
    this.current.wordSpacing = spacing;
  }
  setHScale(opIdx, scale) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("hScale", opIdx);
    this.current.textHScale = scale / 100;
  }
  setLeading(opIdx, leading) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("leading", opIdx);
    this.current.leading = -leading;
  }
  setFont(opIdx, fontRefName, size) {
    var _a3, _b2;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("font", opIdx).recordNamedDependency(opIdx, fontRefName);
    const fontObj = this.commonObjs.get(fontRefName);
    const current = this.current;
    if (!fontObj) {
      throw new Error(`Can't find font for ${fontRefName}`);
    }
    current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
      warn("Invalid font matrix for font " + fontRefName);
    }
    if (size < 0) {
      size = -size;
      current.fontDirection = -1;
    } else {
      current.fontDirection = 1;
    }
    this.current.font = fontObj;
    this.current.fontSize = size;
    if (fontObj.isType3Font) {
      return;
    }
    const name = fontObj.loadedName || "sans-serif";
    const typeface = ((_b2 = fontObj.systemFontInfo) == null ? void 0 : _b2.css) || `"${name}", ${fontObj.fallbackName}`;
    let bold = "normal";
    if (fontObj.black) {
      bold = "900";
    } else if (fontObj.bold) {
      bold = "bold";
    }
    const italic = fontObj.italic ? "italic" : "normal";
    let browserFontSize = size;
    if (size < MIN_FONT_SIZE) {
      browserFontSize = MIN_FONT_SIZE;
    } else if (size > MAX_FONT_SIZE) {
      browserFontSize = MAX_FONT_SIZE;
    }
    this.current.fontSizeScale = size / browserFontSize;
    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
  }
  setTextRenderingMode(opIdx, mode) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("textRenderingMode", opIdx);
    this.current.textRenderingMode = mode;
  }
  setTextRise(opIdx, rise) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("textRise", opIdx);
    this.current.textRise = rise;
  }
  moveText(opIdx, x, y) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.resetIncrementalData("sameLineText").recordIncrementalData("moveText", opIdx);
    this.current.x = this.current.lineX += x;
    this.current.y = this.current.lineY += y;
  }
  setLeadingMoveText(opIdx, x, y) {
    this.setLeading(opIdx, -y);
    this.moveText(opIdx, x, y);
  }
  setTextMatrix(opIdx, matrix) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("textMatrix", opIdx);
    const {
      current
    } = this;
    current.textMatrix = matrix;
    current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);
    current.x = current.lineX = 0;
    current.y = current.lineY = 0;
  }
  nextLine(opIdx) {
    var _a3, _b2;
    this.moveText(opIdx, 0, this.current.leading);
    (_b2 = this.dependencyTracker) == null ? void 0 : _b2.recordIncrementalData("moveText", (_a3 = this.dependencyTracker.getSimpleIndex("leading")) != null ? _a3 : opIdx);
  }
  paintChar(opIdx, character, x, y, patternFillTransform, patternStrokeTransform) {
    var _a3, _b2, _c, _d;
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const textRenderingMode = current.textRenderingMode;
    const fontSize = current.fontSize / current.fontSizeScale;
    const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
    const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
    const patternFill = current.patternFill && !font.missingFile;
    const patternStroke = current.patternStroke && !font.missingFile;
    let path2;
    if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {
      path2 = font.getPathGenerator(this.commonObjs, character);
    }
    if (path2 && (font.disableFontFace || patternFill || patternStroke)) {
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(fontSize, -fontSize);
      (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordCharacterBBox(opIdx, ctx, font);
      let currentTransform;
      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        if (patternFillTransform) {
          currentTransform = ctx.getTransform();
          ctx.setTransform(...patternFillTransform);
          const scaledPath = __privateMethod(this, _getScaledPath, getScaledPath_fn).call(this, path2, currentTransform, patternFillTransform);
          ctx.fill(scaledPath);
        } else {
          ctx.fill(path2);
        }
      }
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        if (patternStrokeTransform) {
          currentTransform || (currentTransform = ctx.getTransform());
          ctx.setTransform(...patternStrokeTransform);
          const {
            a,
            b,
            c,
            d
          } = currentTransform;
          const invPatternTransform = Util.inverseTransform(patternStrokeTransform);
          const transf = Util.transform([a, b, c, d, 0, 0], invPatternTransform);
          Util.singularValueDecompose2dScale(transf, XY);
          ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;
          ctx.stroke(__privateMethod(this, _getScaledPath, getScaledPath_fn).call(this, path2, currentTransform, patternStrokeTransform));
        } else {
          ctx.lineWidth /= fontSize;
          ctx.stroke(path2);
        }
      }
      ctx.restore();
    } else {
      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        ctx.fillText(character, x, y);
        (_b2 = this.dependencyTracker) == null ? void 0 : _b2.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character));
      }
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        if (this.dependencyTracker) {
          (_c = this.dependencyTracker) == null ? void 0 : _c.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);
        }
        ctx.strokeText(character, x, y);
      }
    }
    if (isAddToPathSet) {
      const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
      paths.push({
        transform: getCurrentTransform(ctx),
        x,
        y,
        fontSize,
        path: path2
      });
      (_d = this.dependencyTracker) == null ? void 0 : _d.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y);
    }
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: ctx
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    ctx.scale(1.5, 1);
    ctx.fillText("I", 0, 10);
    const data = ctx.getImageData(0, 0, 10, 10).data;
    let enabled = false;
    for (let i = 3; i < data.length; i += 4) {
      if (data[i] > 0 && data[i] < 255) {
        enabled = true;
        break;
      }
    }
    return shadow(this, "isFontSubpixelAAEnabled", enabled);
  }
  showText(opIdx, glyphs) {
    var _a3, _b2, _c, _d;
    if (this.dependencyTracker) {
      this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).copyDependenciesFromIncrementalOperation(opIdx, "sameLineText").resetBBox(opIdx);
      if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {
        this.dependencyTracker.recordFutureForcedDependency("textClip", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();
      }
    }
    const current = this.current;
    const font = current.font;
    if (font.isType3Font) {
      this.showType3Text(opIdx, glyphs);
      (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordOperation(opIdx).recordIncrementalData("sameLineText", opIdx);
      return void 0;
    }
    const fontSize = current.fontSize;
    if (fontSize === 0) {
      (_b2 = this.dependencyTracker) == null ? void 0 : _b2.recordOperation(opIdx);
      return void 0;
    }
    const ctx = this.ctx;
    const fontSizeScale = current.fontSizeScale;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const fontDirection = current.fontDirection;
    const textHScale = current.textHScale * fontDirection;
    const glyphsLength = glyphs.length;
    const vertical = font.vertical;
    const spacingDir = vertical ? 1 : -1;
    const defaultVMetrics = font.defaultVMetrics;
    const widthAdvanceScale = fontSize * current.fontMatrix[0];
    const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
    ctx.save();
    if (current.textMatrix) {
      ctx.transform(...current.textMatrix);
    }
    ctx.translate(current.x, current.y + current.textRise);
    if (fontDirection > 0) {
      ctx.scale(textHScale, -1);
    } else {
      ctx.scale(textHScale, 1);
    }
    let patternFillTransform, patternStrokeTransform;
    if (current.patternFill) {
      ctx.save();
      const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);
      patternFillTransform = getCurrentTransform(ctx);
      ctx.restore();
      ctx.fillStyle = pattern;
    }
    if (current.patternStroke) {
      ctx.save();
      const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);
      patternStrokeTransform = getCurrentTransform(ctx);
      ctx.restore();
      ctx.strokeStyle = pattern;
    }
    let lineWidth = current.lineWidth;
    const scale = current.textMatrixScale;
    if (scale === 0 || lineWidth === 0) {
      const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        lineWidth = this.getSinglePixelWidth();
      }
    } else {
      lineWidth /= scale;
    }
    if (fontSizeScale !== 1) {
      ctx.scale(fontSizeScale, fontSizeScale);
      lineWidth /= fontSizeScale;
    }
    ctx.lineWidth = lineWidth;
    if (font.isInvalidPDFjsFont) {
      const chars = [];
      let width = 0;
      for (const glyph of glyphs) {
        chars.push(glyph.unicode);
        width += glyph.width;
      }
      const joinedChars = chars.join("");
      ctx.fillText(joinedChars, 0, 0);
      if (this.dependencyTracker !== null) {
        const measure = ctx.measureText(joinedChars);
        this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordOperation(opIdx).recordIncrementalData("sameLineText", opIdx);
      }
      current.x += width * widthAdvanceScale * textHScale;
      ctx.restore();
      this.compose();
      return void 0;
    }
    let x = 0, i;
    for (i = 0; i < glyphsLength; ++i) {
      const glyph = glyphs[i];
      if (typeof glyph === "number") {
        x += spacingDir * glyph * fontSize / 1e3;
        continue;
      }
      let restoreNeeded = false;
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const character = glyph.fontChar;
      const accent = glyph.accent;
      let scaledX, scaledY;
      let width = glyph.width;
      if (vertical) {
        const vmetric = glyph.vmetric || defaultVMetrics;
        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
        const vy = vmetric[2] * widthAdvanceScale;
        width = vmetric ? -vmetric[0] : width;
        scaledX = vx / fontSizeScale;
        scaledY = (x + vy) / fontSizeScale;
      } else {
        scaledX = x / fontSizeScale;
        scaledY = 0;
      }
      let measure;
      if (font.remeasure && width > 0) {
        measure = ctx.measureText(character);
        const measuredWidth = measure.width * 1e3 / fontSize * fontSizeScale;
        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
          const characterScaleX = width / measuredWidth;
          restoreNeeded = true;
          ctx.save();
          ctx.scale(characterScaleX, 1);
          scaledX /= characterScaleX;
        } else if (width !== measuredWidth) {
          scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
        }
      }
      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
        if (simpleFillText && !accent) {
          ctx.fillText(character, scaledX, scaledY);
          (_c = this.dependencyTracker) == null ? void 0 : _c.recordCharacterBBox(opIdx, ctx, measure ? {
            bbox: null
          } : font, fontSize / fontSizeScale, scaledX, scaledY, () => measure != null ? measure : ctx.measureText(character));
        } else {
          this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);
          if (accent) {
            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
            this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);
          }
        }
      }
      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
      x += charWidth;
      if (restoreNeeded) {
        ctx.restore();
      }
    }
    if (vertical) {
      current.y -= x;
    } else {
      current.x += x * textHScale;
    }
    ctx.restore();
    this.compose();
    (_d = this.dependencyTracker) == null ? void 0 : _d.recordOperation(opIdx).recordIncrementalData("sameLineText", opIdx);
    return void 0;
  }
  showType3Text(opIdx, glyphs) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const fontSize = current.fontSize;
    const fontDirection = current.fontDirection;
    const spacingDir = font.vertical ? 1 : -1;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const textHScale = current.textHScale * fontDirection;
    const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
    const glyphsLength = glyphs.length;
    const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;
    let i, glyph, width, spacingLength;
    if (isTextInvisible || fontSize === 0) {
      return;
    }
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
    ctx.save();
    if (current.textMatrix) {
      ctx.transform(...current.textMatrix);
    }
    ctx.translate(current.x, current.y + current.textRise);
    ctx.scale(textHScale, fontDirection);
    const dependencyTracker = this.dependencyTracker;
    this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;
    for (i = 0; i < glyphsLength; ++i) {
      glyph = glyphs[i];
      if (typeof glyph === "number") {
        spacingLength = spacingDir * glyph * fontSize / 1e3;
        this.ctx.translate(spacingLength, 0);
        current.x += spacingLength * textHScale;
        continue;
      }
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const operatorList = font.charProcOperatorList[glyph.operatorListId];
      if (!operatorList) {
        warn(`Type3 character "${glyph.operatorListId}" is not available.`);
      } else if (this.contentVisible) {
        this.save();
        ctx.scale(fontSize, fontSize);
        ctx.transform(...fontMatrix);
        this.executeOperatorList(operatorList);
        this.restore();
      }
      const p = [glyph.width, 0];
      Util.applyTransform(p, fontMatrix);
      width = p[0] * fontSize + spacing;
      ctx.translate(width, 0);
      current.x += width * textHScale;
    }
    ctx.restore();
    if (dependencyTracker) {
      this.dependencyTracker.recordNestedDependencies();
      this.dependencyTracker = dependencyTracker;
    }
  }
  setCharWidth(opIdx, xWidth, yWidth) {
  }
  setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {
    var _a3;
    const clip = new Path2D();
    clip.rect(llx, lly, urx - llx, ury - lly);
    this.ctx.clip(clip);
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);
    this.endPath(opIdx);
  }
  getColorN_Pattern(opIdx, IR) {
    let pattern;
    if (IR[0] === "TilingPattern") {
      const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
      const canvasGraphicsFactory = {
        createCanvasGraphics: (ctx) => new _CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        }, void 0, void 0, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, opIdx) : null)
      };
      pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);
    } else {
      pattern = this._getPattern(opIdx, IR[1], IR[2]);
    }
    return pattern;
  }
  setStrokeColorN(opIdx, ...args) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("strokeColor", opIdx);
    this.current.strokeColor = this.getColorN_Pattern(opIdx, args);
    this.current.patternStroke = true;
  }
  setFillColorN(opIdx, ...args) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("fillColor", opIdx);
    this.current.fillColor = this.getColorN_Pattern(opIdx, args);
    this.current.patternFill = true;
  }
  setStrokeRGBColor(opIdx, color) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("strokeColor", opIdx);
    this.ctx.strokeStyle = this.current.strokeColor = color;
    this.current.patternStroke = false;
  }
  setStrokeTransparent(opIdx) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("strokeColor", opIdx);
    this.ctx.strokeStyle = this.current.strokeColor = "transparent";
    this.current.patternStroke = false;
  }
  setFillRGBColor(opIdx, color) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("fillColor", opIdx);
    this.ctx.fillStyle = this.current.fillColor = color;
    this.current.patternFill = false;
  }
  setFillTransparent(opIdx) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordSimpleData("fillColor", opIdx);
    this.ctx.fillStyle = this.current.fillColor = "transparent";
    this.current.patternFill = false;
  }
  _getPattern(opIdx, objId, matrix = null) {
    let pattern;
    if (this.cachedPatterns.has(objId)) {
      pattern = this.cachedPatterns.get(objId);
    } else {
      pattern = getShadingPattern(this.getObject(opIdx, objId));
      this.cachedPatterns.set(objId, pattern);
    }
    if (matrix) {
      pattern.matrix = matrix;
    }
    return pattern;
  }
  shadingFill(opIdx, objId) {
    var _a3;
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    this.save(opIdx);
    const pattern = this._getPattern(opIdx, objId);
    ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);
    const inv = getCurrentTransformInverse(ctx);
    if (inv) {
      const {
        width,
        height
      } = ctx.canvas;
      const minMax = MIN_MAX_INIT.slice();
      Util.axialAlignedBoundingBox([0, 0, width, height], inv, minMax);
      const [x0, y0, x1, y1] = minMax;
      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
    } else {
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    }
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
    this.compose(this.current.getClippedPathBoundingBox());
    this.restore(opIdx);
  }
  beginInlineImage() {
    unreachable("Should not call beginInlineImage");
  }
  beginImageData() {
    unreachable("Should not call beginImageData");
  }
  paintFormXObjectBegin(opIdx, matrix, bbox) {
    var _a3;
    if (!this.contentVisible) {
      return;
    }
    this.save(opIdx);
    this.baseTransformStack.push(this.baseTransform);
    if (matrix) {
      this.transform(opIdx, ...matrix);
    }
    this.baseTransform = getCurrentTransform(this.ctx);
    if (bbox) {
      Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);
      const [x0, y0, x1, y1] = bbox;
      const clip = new Path2D();
      clip.rect(x0, y0, x1 - x0, y1 - y0);
      this.ctx.clip(clip);
      (_a3 = this.dependencyTracker) == null ? void 0 : _a3.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);
      this.endPath(opIdx);
    }
  }
  paintFormXObjectEnd(opIdx) {
    if (!this.contentVisible) {
      return;
    }
    this.restore(opIdx);
    this.baseTransform = this.baseTransformStack.pop();
  }
  beginGroup(opIdx, group) {
    var _a3;
    if (!this.contentVisible) {
      return;
    }
    this.save(opIdx);
    if (this.inSMaskMode) {
      this.endSMaskMode();
      this.current.activeSMask = null;
    }
    const currentCtx = this.ctx;
    if (!group.isolated) {
      info("TODO: Support non-isolated groups.");
    }
    if (group.knockout) {
      warn("Knockout groups not supported.");
    }
    const currentTransform = getCurrentTransform(currentCtx);
    if (group.matrix) {
      currentCtx.transform(...group.matrix);
    }
    if (!group.bbox) {
      throw new Error("Bounding box is required.");
    }
    let bounds = MIN_MAX_INIT.slice();
    Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);
    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
    bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
    const offsetX = Math.floor(bounds[0]);
    const offsetY = Math.floor(bounds[1]);
    const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
    const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
    let cacheId = "groupAt" + this.groupLevel;
    if (group.smask) {
      cacheId += "_smask_" + this.smaskCounter++ % 2;
    }
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    const groupCtx = scratchCanvas.context;
    groupCtx.translate(-offsetX, -offsetY);
    groupCtx.transform(...currentTransform);
    let clip = new Path2D();
    const [x0, y0, x1, y1] = group.bbox;
    clip.rect(x0, y0, x1 - x0, y1 - y0);
    if (group.matrix) {
      const path2 = new Path2D();
      path2.addPath(clip, new DOMMatrix(group.matrix));
      clip = path2;
    }
    groupCtx.clip(clip);
    if (group.smask) {
      this.smaskStack.push({
        canvas: scratchCanvas.canvas,
        context: groupCtx,
        offsetX,
        offsetY,
        subtype: group.smask.subtype,
        backdrop: group.smask.backdrop,
        transferMap: group.smask.transferMap || null,
        startTransformInverse: null
      });
    }
    if (!group.smask || this.dependencyTracker) {
      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
      currentCtx.translate(offsetX, offsetY);
      currentCtx.save();
    }
    copyCtxState(currentCtx, groupCtx);
    this.ctx = groupCtx;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.inheritSimpleDataAsFutureForcedDependencies(["fillAlpha", "strokeAlpha", "globalCompositeOperation"]).pushBaseTransform(currentCtx);
    this.setGState(opIdx, [["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    this.groupStack.push(currentCtx);
    this.groupLevel++;
  }
  endGroup(opIdx, group) {
    var _a3;
    if (!this.contentVisible) {
      return;
    }
    this.groupLevel--;
    const groupCtx = this.ctx;
    const ctx = this.groupStack.pop();
    this.ctx = ctx;
    this.ctx.imageSmoothingEnabled = false;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.popBaseTransform();
    if (group.smask) {
      this.tempSMask = this.smaskStack.pop();
      this.restore(opIdx);
      if (this.dependencyTracker) {
        this.ctx.restore();
      }
    } else {
      this.ctx.restore();
      const currentMtx = getCurrentTransform(this.ctx);
      this.restore(opIdx);
      this.ctx.save();
      this.ctx.setTransform(...currentMtx);
      const dirtyBox = MIN_MAX_INIT.slice();
      Util.axialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx, dirtyBox);
      this.ctx.drawImage(groupCtx.canvas, 0, 0);
      this.ctx.restore();
      this.compose(dirtyBox);
    }
  }
  beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {
    __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
    resetCtxToDefault(this.ctx);
    this.ctx.save();
    this.save(opIdx);
    if (this.baseTransform) {
      this.ctx.setTransform(...this.baseTransform);
    }
    if (rect) {
      const width = rect[2] - rect[0];
      const height = rect[3] - rect[1];
      if (hasOwnCanvas && this.annotationCanvasMap) {
        transform = transform.slice();
        transform[4] -= rect[0];
        transform[5] -= rect[1];
        rect = rect.slice();
        rect[0] = rect[1] = 0;
        rect[2] = width;
        rect[3] = height;
        Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);
        const {
          viewportScale
        } = this;
        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
        const {
          canvas,
          context
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(id, canvas);
        this.annotationCanvas.savedCtx = this.ctx;
        this.ctx = context;
        this.ctx.save();
        this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);
        resetCtxToDefault(this.ctx);
      } else {
        resetCtxToDefault(this.ctx);
        this.endPath(opIdx);
        const clip = new Path2D();
        clip.rect(rect[0], rect[1], width, height);
        this.ctx.clip(clip);
      }
    }
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.transform(opIdx, ...transform);
    this.transform(opIdx, ...matrix);
  }
  endAnnotation(opIdx) {
    if (this.annotationCanvas) {
      this.ctx.restore();
      __privateMethod(this, _drawFilter, drawFilter_fn).call(this);
      this.ctx = this.annotationCanvas.savedCtx;
      delete this.annotationCanvas.savedCtx;
      delete this.annotationCanvas;
    }
  }
  paintImageMaskXObject(opIdx, img) {
    var _a3;
    if (!this.contentVisible) {
      return;
    }
    const count = img.count;
    img = this.getObject(opIdx, img.data, img);
    img.count = count;
    const ctx = this.ctx;
    const mask = this._createMaskCanvas(opIdx, img);
    const maskCanvas = mask.canvas;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);
    ctx.restore();
    this.compose();
  }
  paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
    var _a3, _b2, _c;
    if (!this.contentVisible) {
      return;
    }
    img = this.getObject(opIdx, img.data, img);
    const ctx = this.ctx;
    ctx.save();
    const currentTransform = getCurrentTransform(ctx);
    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
    const mask = this._createMaskCanvas(opIdx, img);
    ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.resetBBox(opIdx);
    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      const trans = Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
      ctx.drawImage(mask.canvas, trans[4], trans[5]);
      (_b2 = this.dependencyTracker) == null ? void 0 : _b2.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);
    }
    ctx.restore();
    this.compose();
    (_c = this.dependencyTracker) == null ? void 0 : _c.recordOperation(opIdx);
  }
  paintImageMaskXObjectGroup(opIdx, images) {
    var _a3, _b2, _c;
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);
    for (const image of images) {
      const {
        data,
        width,
        height,
        transform
      } = image;
      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      const maskCtx = maskCanvas.context;
      maskCtx.save();
      const img = this.getObject(opIdx, data, image);
      putBinaryImageMask(maskCtx, img);
      maskCtx.globalCompositeOperation = "source-in";
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      ctx.save();
      ctx.transform(...transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
      (_b2 = this.dependencyTracker) == null ? void 0 : _b2.recordBBox(opIdx, ctx, 0, width, 0, height);
      ctx.restore();
    }
    this.compose();
    (_c = this.dependencyTracker) == null ? void 0 : _c.recordOperation(opIdx);
  }
  paintImageXObject(opIdx, objId) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(opIdx, objId);
    if (!imgData) {
      warn("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(opIdx, imgData);
  }
  paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(opIdx, objId);
    if (!imgData) {
      warn("Dependent image isn't ready yet");
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const map = [];
    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      map.push({
        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
        x: 0,
        y: 0,
        w: width,
        h: height
      });
    }
    this.paintInlineImageXObjectGroup(opIdx, imgData, map);
  }
  applyTransferMapsToCanvas(ctx) {
    if (this.current.transferMaps !== "none") {
      ctx.filter = this.current.transferMaps;
      ctx.drawImage(ctx.canvas, 0, 0);
      ctx.filter = "none";
    }
    return ctx.canvas;
  }
  applyTransferMapsToBitmap(imgData) {
    if (this.current.transferMaps === "none") {
      return imgData.bitmap;
    }
    const {
      bitmap,
      width,
      height
    } = imgData;
    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
    const tmpCtx = tmpCanvas.context;
    tmpCtx.filter = this.current.transferMaps;
    tmpCtx.drawImage(bitmap, 0, 0);
    tmpCtx.filter = "none";
    return tmpCanvas.canvas;
  }
  paintInlineImageXObject(opIdx, imgData) {
    var _a3;
    if (!this.contentVisible) {
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const ctx = this.ctx;
    this.save(opIdx);
    const {
      filter
    } = ctx;
    if (filter !== "none" && filter !== "") {
      ctx.filter = "none";
    }
    ctx.scale(1 / width, -1 / height);
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = this.applyTransferMapsToBitmap(imgData);
    } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
      imgToPaint = imgData;
    } else {
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));
    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);
    drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
    this.compose();
    this.restore(opIdx);
  }
  paintInlineImageXObjectGroup(opIdx, imgData, map) {
    var _a3, _b2, _c;
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = imgData.bitmap;
    } else {
      const w = imgData.width;
      const h = imgData.height;
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.resetBBox(opIdx);
    for (const entry of map) {
      ctx.save();
      ctx.transform(...entry.transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
      (_b2 = this.dependencyTracker) == null ? void 0 : _b2.recordBBox(opIdx, ctx, 0, 1, -1, 0);
      ctx.restore();
    }
    (_c = this.dependencyTracker) == null ? void 0 : _c.recordOperation(opIdx);
    this.compose();
  }
  paintSolidColorImageMask(opIdx) {
    var _a3;
    if (!this.contentVisible) {
      return;
    }
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
    this.ctx.fillRect(0, 0, 1, 1);
    this.compose();
  }
  markPoint(opIdx, tag) {
  }
  markPointProps(opIdx, tag, properties) {
  }
  beginMarkedContent(opIdx, tag) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.beginMarkedContent(opIdx);
    this.markedContentStack.push({
      visible: true
    });
  }
  beginMarkedContentProps(opIdx, tag, properties) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.beginMarkedContent(opIdx);
    if (tag === "OC") {
      this.markedContentStack.push({
        visible: this.optionalContentConfig.isVisible(properties)
      });
    } else {
      this.markedContentStack.push({
        visible: true
      });
    }
    this.contentVisible = this.isContentVisible();
  }
  endMarkedContent(opIdx) {
    var _a3;
    (_a3 = this.dependencyTracker) == null ? void 0 : _a3.endMarkedContent(opIdx);
    this.markedContentStack.pop();
    this.contentVisible = this.isContentVisible();
  }
  beginCompat(opIdx) {
  }
  endCompat(opIdx) {
  }
  consumePath(opIdx, path2, clipBox) {
    var _a3, _b2;
    const isEmpty = this.current.isEmptyClip();
    if (this.pendingClip) {
      this.current.updateClipFromPath();
    }
    if (!this.pendingClip) {
      this.compose(clipBox);
    }
    const ctx = this.ctx;
    if (this.pendingClip) {
      if (!isEmpty) {
        if (this.pendingClip === EO_CLIP) {
          ctx.clip(path2, "evenodd");
        } else {
          ctx.clip(path2);
        }
      }
      this.pendingClip = null;
      (_a3 = this.dependencyTracker) == null ? void 0 : _a3.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency("clipPath", opIdx);
    } else {
      (_b2 = this.dependencyTracker) == null ? void 0 : _b2.recordOperation(opIdx);
    }
    this.current.startNewPathAndClipBox(this.current.clipBox);
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const m = getCurrentTransform(this.ctx);
      if (m[1] === 0 && m[2] === 0) {
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
      } else {
        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
        const normX = Math.hypot(m[0], m[2]);
        const normY = Math.hypot(m[1], m[3]);
        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth
      } = this.current;
      const {
        a,
        b,
        c,
        d
      } = this.ctx.getTransform();
      let scaleX, scaleY;
      if (b === 0 && c === 0) {
        const normX = Math.abs(a);
        const normY = Math.abs(d);
        if (normX === normY) {
          if (lineWidth === 0) {
            scaleX = scaleY = 1 / normX;
          } else {
            const scaledLineWidth = normX * lineWidth;
            scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
          }
        } else if (lineWidth === 0) {
          scaleX = 1 / normX;
          scaleY = 1 / normY;
        } else {
          const scaledXLineWidth = normX * lineWidth;
          const scaledYLineWidth = normY * lineWidth;
          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
        }
      } else {
        const absDet = Math.abs(a * d - b * c);
        const normX = Math.hypot(a, b);
        const normY = Math.hypot(c, d);
        if (lineWidth === 0) {
          scaleX = normY / absDet;
          scaleY = normX / absDet;
        } else {
          const baseArea = lineWidth * absDet;
          scaleX = normY > baseArea ? normY / baseArea : 1;
          scaleY = normX > baseArea ? normX / baseArea : 1;
        }
      }
      this._cachedScaleForStroking[0] = scaleX;
      this._cachedScaleForStroking[1] = scaleY;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(path2, saveRestore) {
    const {
      ctx,
      current: {
        lineWidth
      }
    } = this;
    const [scaleX, scaleY] = this.getScaleForStroking();
    if (scaleX === scaleY) {
      ctx.lineWidth = (lineWidth || 1) * scaleX;
      ctx.stroke(path2);
      return;
    }
    const dashes = ctx.getLineDash();
    if (saveRestore) {
      ctx.save();
    }
    ctx.scale(scaleX, scaleY);
    SCALE_MATRIX.a = 1 / scaleX;
    SCALE_MATRIX.d = 1 / scaleY;
    const newPath = new Path2D();
    newPath.addPath(path2, SCALE_MATRIX);
    if (dashes.length > 0) {
      const scale = Math.max(scaleX, scaleY);
      ctx.setLineDash(dashes.map((x) => x / scale));
      ctx.lineDashOffset /= scale;
    }
    ctx.lineWidth = lineWidth || 1;
    ctx.stroke(newPath);
    if (saveRestore) {
      ctx.restore();
    }
  }
  isContentVisible() {
    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
      if (!this.markedContentStack[i].visible) {
        return false;
      }
    }
    return true;
  }
};
_restoreInitialState = new WeakSet();
restoreInitialState_fn = function() {
  while (this.stateStack.length || this.inSMaskMode) {
    this.restore();
  }
  this.current.activeSMask = null;
  this.ctx.restore();
  if (this.transparentCanvas) {
    this.ctx = this.compositeCtx;
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.drawImage(this.transparentCanvas, 0, 0);
    this.ctx.restore();
    this.transparentCanvas = null;
  }
};
_drawFilter = new WeakSet();
drawFilter_fn = function() {
  if (this.pageColors) {
    const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
    if (hcmFilterId !== "none") {
      const savedFilter = this.ctx.filter;
      this.ctx.filter = hcmFilterId;
      this.ctx.drawImage(this.ctx.canvas, 0, 0);
      this.ctx.filter = savedFilter;
    }
  }
};
_getScaledPath = new WeakSet();
getScaledPath_fn = function(path2, currentTransform, transform) {
  const newPath = new Path2D();
  newPath.addPath(path2, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));
  return newPath;
};
var CanvasGraphics = _CanvasGraphics;
for (const op in OPS) {
  if (CanvasGraphics.prototype[op] !== void 0) {
    CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
  }
}
var _port, _src;
var GlobalWorkerOptions = class {
  static get workerPort() {
    return __privateGet(this, _port);
  }
  static set workerPort(val) {
    if (!(typeof Worker !== "undefined" && val instanceof Worker) && val !== null) {
      throw new Error("Invalid `workerPort` type.");
    }
    __privateSet(this, _port, val);
  }
  static get workerSrc() {
    return __privateGet(this, _src);
  }
  static set workerSrc(val) {
    if (typeof val !== "string") {
      throw new Error("Invalid `workerSrc` type.");
    }
    __privateSet(this, _src, val);
  }
};
_port = new WeakMap();
_src = new WeakMap();
__privateAdd(GlobalWorkerOptions, _port, null);
__privateAdd(GlobalWorkerOptions, _src, "");
var _map, _data;
var Metadata = class {
  constructor({
    parsedData,
    rawData
  }) {
    __privateAdd(this, _map, void 0);
    __privateAdd(this, _data, void 0);
    __privateSet(this, _map, parsedData);
    __privateSet(this, _data, rawData);
  }
  getRaw() {
    return __privateGet(this, _data);
  }
  get(name) {
    var _a3;
    return (_a3 = __privateGet(this, _map).get(name)) != null ? _a3 : null;
  }
  [Symbol.iterator]() {
    return __privateGet(this, _map).entries();
  }
};
_map = new WeakMap();
_data = new WeakMap();
var INTERNAL = Symbol("INTERNAL");
var _isDisplay, _isPrint, _userSet, _visible;
var OptionalContentGroup = class {
  constructor(renderingIntent, {
    name,
    intent,
    usage,
    rbGroups
  }) {
    __privateAdd(this, _isDisplay, false);
    __privateAdd(this, _isPrint, false);
    __privateAdd(this, _userSet, false);
    __privateAdd(this, _visible, true);
    __privateSet(this, _isDisplay, !!(renderingIntent & RenderingIntentFlag.DISPLAY));
    __privateSet(this, _isPrint, !!(renderingIntent & RenderingIntentFlag.PRINT));
    this.name = name;
    this.intent = intent;
    this.usage = usage;
    this.rbGroups = rbGroups;
  }
  get visible() {
    if (__privateGet(this, _userSet)) {
      return __privateGet(this, _visible);
    }
    if (!__privateGet(this, _visible)) {
      return false;
    }
    const {
      print,
      view
    } = this.usage;
    if (__privateGet(this, _isDisplay)) {
      return (view == null ? void 0 : view.viewState) !== "OFF";
    } else if (__privateGet(this, _isPrint)) {
      return (print == null ? void 0 : print.printState) !== "OFF";
    }
    return true;
  }
  _setVisible(internal, visible, userSet = false) {
    if (internal !== INTERNAL) {
      unreachable("Internal method `_setVisible` called.");
    }
    __privateSet(this, _userSet, userSet);
    __privateSet(this, _visible, visible);
  }
};
_isDisplay = new WeakMap();
_isPrint = new WeakMap();
_userSet = new WeakMap();
_visible = new WeakMap();
var _cachedGetHash, _groups, _initialHash, _order, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn;
var OptionalContentConfig = class {
  constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY) {
    __privateAdd(this, _evaluateVisibilityExpression);
    __privateAdd(this, _cachedGetHash, null);
    __privateAdd(this, _groups, /* @__PURE__ */ new Map());
    __privateAdd(this, _initialHash, null);
    __privateAdd(this, _order, null);
    this.renderingIntent = renderingIntent;
    this.name = null;
    this.creator = null;
    if (data === null) {
      return;
    }
    this.name = data.name;
    this.creator = data.creator;
    __privateSet(this, _order, data.order);
    for (const group of data.groups) {
      __privateGet(this, _groups).set(group.id, new OptionalContentGroup(renderingIntent, group));
    }
    if (data.baseState === "OFF") {
      for (const group of __privateGet(this, _groups).values()) {
        group._setVisible(INTERNAL, false);
      }
    }
    for (const on of data.on) {
      __privateGet(this, _groups).get(on)._setVisible(INTERNAL, true);
    }
    for (const off of data.off) {
      __privateGet(this, _groups).get(off)._setVisible(INTERNAL, false);
    }
    __privateSet(this, _initialHash, this.getHash());
  }
  isVisible(group) {
    if (__privateGet(this, _groups).size === 0) {
      return true;
    }
    if (!group) {
      info("Optional content group not defined.");
      return true;
    }
    if (group.type === "OCG") {
      if (!__privateGet(this, _groups).has(group.id)) {
        warn(`Optional content group not found: ${group.id}`);
        return true;
      }
      return __privateGet(this, _groups).get(group.id).visible;
    } else if (group.type === "OCMD") {
      if (group.expression) {
        return __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, group.expression);
      }
      if (!group.policy || group.policy === "AnyOn") {
        for (const id of group.ids) {
          if (!__privateGet(this, _groups).has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (__privateGet(this, _groups).get(id).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOn") {
        for (const id of group.ids) {
          if (!__privateGet(this, _groups).has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (!__privateGet(this, _groups).get(id).visible) {
            return false;
          }
        }
        return true;
      } else if (group.policy === "AnyOff") {
        for (const id of group.ids) {
          if (!__privateGet(this, _groups).has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (!__privateGet(this, _groups).get(id).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOff") {
        for (const id of group.ids) {
          if (!__privateGet(this, _groups).has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (__privateGet(this, _groups).get(id).visible) {
            return false;
          }
        }
        return true;
      }
      warn(`Unknown optional content policy ${group.policy}.`);
      return true;
    }
    warn(`Unknown group type ${group.type}.`);
    return true;
  }
  setVisibility(id, visible = true, preserveRB = true) {
    var _a3;
    const group = __privateGet(this, _groups).get(id);
    if (!group) {
      warn(`Optional content group not found: ${id}`);
      return;
    }
    if (preserveRB && visible && group.rbGroups.length) {
      for (const rbGroup of group.rbGroups) {
        for (const otherId of rbGroup) {
          if (otherId !== id) {
            (_a3 = __privateGet(this, _groups).get(otherId)) == null ? void 0 : _a3._setVisible(INTERNAL, false, true);
          }
        }
      }
    }
    group._setVisible(INTERNAL, !!visible, true);
    __privateSet(this, _cachedGetHash, null);
  }
  setOCGState({
    state,
    preserveRB
  }) {
    let operator;
    for (const elem of state) {
      switch (elem) {
        case "ON":
        case "OFF":
        case "Toggle":
          operator = elem;
          continue;
      }
      const group = __privateGet(this, _groups).get(elem);
      if (!group) {
        continue;
      }
      switch (operator) {
        case "ON":
          this.setVisibility(elem, true, preserveRB);
          break;
        case "OFF":
          this.setVisibility(elem, false, preserveRB);
          break;
        case "Toggle":
          this.setVisibility(elem, !group.visible, preserveRB);
          break;
      }
    }
    __privateSet(this, _cachedGetHash, null);
  }
  get hasInitialVisibility() {
    return __privateGet(this, _initialHash) === null || this.getHash() === __privateGet(this, _initialHash);
  }
  getOrder() {
    if (!__privateGet(this, _groups).size) {
      return null;
    }
    if (__privateGet(this, _order)) {
      return __privateGet(this, _order).slice();
    }
    return [...__privateGet(this, _groups).keys()];
  }
  getGroup(id) {
    return __privateGet(this, _groups).get(id) || null;
  }
  getHash() {
    if (__privateGet(this, _cachedGetHash) !== null) {
      return __privateGet(this, _cachedGetHash);
    }
    const hash = new MurmurHash3_64();
    for (const [id, group] of __privateGet(this, _groups)) {
      hash.update(`${id}:${group.visible}`);
    }
    return __privateSet(this, _cachedGetHash, hash.hexdigest());
  }
  [Symbol.iterator]() {
    return __privateGet(this, _groups).entries();
  }
};
_cachedGetHash = new WeakMap();
_groups = new WeakMap();
_initialHash = new WeakMap();
_order = new WeakMap();
_evaluateVisibilityExpression = new WeakSet();
evaluateVisibilityExpression_fn = function(array) {
  const length = array.length;
  if (length < 2) {
    return true;
  }
  const operator = array[0];
  for (let i = 1; i < length; i++) {
    const element = array[i];
    let state;
    if (Array.isArray(element)) {
      state = __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, element);
    } else if (__privateGet(this, _groups).has(element)) {
      state = __privateGet(this, _groups).get(element).visible;
    } else {
      warn(`Optional content group not found: ${element}`);
      return true;
    }
    switch (operator) {
      case "And":
        if (!state) {
          return false;
        }
        break;
      case "Or":
        if (state) {
          return true;
        }
        break;
      case "Not":
        return !state;
      default:
        return true;
    }
  }
  return operator === "And";
};
var PDFDataTransportStream = class {
  constructor(pdfDataRangeTransport, {
    disableRange = false,
    disableStream = false
  }) {
    assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length,
      initialData,
      progressiveDone,
      contentDispositionFilename
    } = pdfDataRangeTransport;
    this._queuedChunks = [];
    this._progressiveDone = progressiveDone;
    this._contentDispositionFilename = contentDispositionFilename;
    if ((initialData == null ? void 0 : initialData.length) > 0) {
      const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
      this._queuedChunks.push(buffer);
    }
    this._pdfDataRangeTransport = pdfDataRangeTransport;
    this._isStreamingSupported = !disableStream;
    this._isRangeSupported = !disableRange;
    this._contentLength = length;
    this._fullRequestReader = null;
    this._rangeReaders = [];
    pdfDataRangeTransport.addRangeListener((begin, chunk) => {
      this._onReceiveData({
        begin,
        chunk
      });
    });
    pdfDataRangeTransport.addProgressListener((loaded, total) => {
      this._onProgress({
        loaded,
        total
      });
    });
    pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
      this._onReceiveData({
        chunk
      });
    });
    pdfDataRangeTransport.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    });
    pdfDataRangeTransport.transportReady();
  }
  _onReceiveData({
    begin,
    chunk
  }) {
    const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
    if (begin === void 0) {
      if (this._fullRequestReader) {
        this._fullRequestReader._enqueue(buffer);
      } else {
        this._queuedChunks.push(buffer);
      }
    } else {
      const found = this._rangeReaders.some(function(rangeReader) {
        if (rangeReader._begin !== begin) {
          return false;
        }
        rangeReader._enqueue(buffer);
        return true;
      });
      assert(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    var _a3, _b2;
    return (_b2 = (_a3 = this._fullRequestReader) == null ? void 0 : _a3._loaded) != null ? _b2 : 0;
  }
  _onProgress(evt) {
    var _a3, _b2, _c, _d;
    if (evt.total === void 0) {
      (_b2 = (_a3 = this._rangeReaders[0]) == null ? void 0 : _a3.onProgress) == null ? void 0 : _b2.call(_a3, {
        loaded: evt.loaded
      });
    } else {
      (_d = (_c = this._fullRequestReader) == null ? void 0 : _c.onProgress) == null ? void 0 : _d.call(_c, {
        loaded: evt.loaded,
        total: evt.total
      });
    }
  }
  _onProgressiveDone() {
    var _a3;
    (_a3 = this._fullRequestReader) == null ? void 0 : _a3.progressiveDone();
    this._progressiveDone = true;
  }
  _removeRangeReader(reader) {
    const i = this._rangeReaders.indexOf(reader);
    if (i >= 0) {
      this._rangeReaders.splice(i, 1);
    }
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const queuedChunks = this._queuedChunks;
    this._queuedChunks = null;
    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
    this._pdfDataRangeTransport.requestDataRange(begin, end);
    this._rangeReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    var _a3;
    (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
    for (const reader of this._rangeReaders.slice(0)) {
      reader.cancel(reason);
    }
    this._pdfDataRangeTransport.abort();
  }
};
var PDFDataTransportStreamReader = class {
  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
    this._stream = stream;
    this._done = progressiveDone || false;
    this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;
    this._queuedChunks = queuedChunks || [];
    this._loaded = 0;
    for (const chunk of this._queuedChunks) {
      this._loaded += chunk.byteLength;
    }
    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunks.push(chunk);
    }
    this._loaded += chunk.byteLength;
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0) {
      const chunk = this._queuedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
  }
  progressiveDone() {
    if (this._done) {
      return;
    }
    this._done = true;
  }
};
var PDFDataTransportStreamRangeReader = class {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length === 0) {
      this._queuedChunk = chunk;
    } else {
      const requestsCapability = this._requests.shift();
      requestsCapability.resolve({
        value: chunk,
        done: false
      });
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: void 0,
          done: true
        });
      }
      this._requests.length = 0;
    }
    this._done = true;
    this._stream._removeRangeReader(this);
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._queuedChunk) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    this._stream._removeRangeReader(this);
  }
};
function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  tmp = rfc2231getparam(contentDisposition);
  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }
  tmp = toParamRegExp("filename", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
  }
  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(value);
        value = decoder.decode(buffer);
        needsEncodingFixup = false;
      } catch (e) {
      }
    }
    return value;
  }
  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);
      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }
    return value;
  }
  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    while ((match = iter.exec(contentDispositionStr)) !== null) {
      let [, n, quot, part] = match;
      n = parseInt(n, 10);
      if (n in matches) {
        if (n === 0) {
          break;
        }
        continue;
      }
      matches[n] = [quot, part];
    }
    const parts = [];
    for (let n = 0; n < matches.length; ++n) {
      if (!(n in matches)) {
        break;
      }
      let [quot, part] = matches[n];
      part = rfc2616unquote(part);
      if (quot) {
        part = unescape(part);
        if (n === 0) {
          part = rfc5987decode(part);
        }
      }
      parts.push(part);
    }
    return parts.join("");
  }
  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');
      for (let i = 0; i < parts.length; ++i) {
        const quotindex = parts[i].indexOf('"');
        if (quotindex !== -1) {
          parts[i] = parts[i].slice(0, quotindex);
          parts.length = i + 1;
        }
        parts[i] = parts[i].replaceAll(/\\(.)/g, "$1");
      }
      value = parts.join('"');
    }
    return value;
  }
  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");
    if (encodingend === -1) {
      return extvalue;
    }
    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }
  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }
    return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replaceAll("_", " ");
        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }
      try {
        text = atob(text);
      } catch (e) {
      }
      return textdecode(charset, text);
    });
  }
  return "";
}
function createHeaders(isHttp, httpHeaders) {
  const headers = new Headers();
  if (!isHttp || !httpHeaders || typeof httpHeaders !== "object") {
    return headers;
  }
  for (const key in httpHeaders) {
    const val = httpHeaders[key];
    if (val !== void 0) {
      headers.append(key, val);
    }
  }
  return headers;
}
function getResponseOrigin(url) {
  var _a3, _b2;
  return (_b2 = (_a3 = URL.parse(url)) == null ? void 0 : _a3.origin) != null ? _b2 : null;
}
function validateRangeRequestCapabilities({
  responseHeaders,
  isHttp,
  rangeChunkSize,
  disableRange
}) {
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: void 0
  };
  const length = parseInt(responseHeaders.get("Content-Length"), 10);
  if (!Number.isInteger(length)) {
    return returnValues;
  }
  returnValues.suggestedLength = length;
  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }
  if (disableRange || !isHttp) {
    return returnValues;
  }
  if (responseHeaders.get("Accept-Ranges") !== "bytes") {
    return returnValues;
  }
  const contentEncoding = responseHeaders.get("Content-Encoding") || "identity";
  if (contentEncoding !== "identity") {
    return returnValues;
  }
  returnValues.allowRangeRequests = true;
  return returnValues;
}
function extractFilenameFromHeader(responseHeaders) {
  const contentDisposition = responseHeaders.get("Content-Disposition");
  if (contentDisposition) {
    let filename = getFilenameFromContentDispositionHeader(contentDisposition);
    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch (e) {
      }
    }
    if (isPdfFile(filename)) {
      return filename;
    }
  }
  return null;
}
function createResponseError(status, url) {
  return new ResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status, status === 404 || status === 0 && url.startsWith("file:"));
}
function validateResponseStatus(status) {
  return status === 200 || status === 206;
}
function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: "GET",
    headers,
    signal: abortController.signal,
    mode: "cors",
    credentials: withCredentials ? "include" : "same-origin",
    redirect: "follow"
  };
}
function getArrayBuffer(val) {
  if (val instanceof Uint8Array) {
    return val.buffer;
  }
  if (val instanceof ArrayBuffer) {
    return val;
  }
  warn(`getArrayBuffer - unexpected data format: ${val}`);
  return new Uint8Array(val).buffer;
}
var PDFFetchStream = class {
  constructor(source) {
    __publicField(this, "_responseOrigin", null);
    this.source = source;
    this.isHttp = /^https?:/i.test(source.url);
    this.headers = createHeaders(this.isHttp, source.httpHeaders);
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var _a3, _b2;
    return (_b2 = (_a3 = this._fullRequestReader) == null ? void 0 : _a3._loaded) != null ? _b2 : 0;
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFFetchStreamReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFFetchStreamRangeReader(this, begin, end);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    var _a3;
    (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
};
var PDFFetchStreamReader = class {
  constructor(stream) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._contentLength = source.length;
    this._headersCapability = Promise.withResolvers();
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._abortController = new AbortController();
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    const headers = new Headers(stream.headers);
    const url = source.url;
    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response) => {
      stream._responseOrigin = getResponseOrigin(response.url);
      if (!validateResponseStatus(response.status)) {
        throw createResponseError(response.status, url);
      }
      this._reader = response.body.getReader();
      this._headersCapability.resolve();
      const responseHeaders = response.headers;
      const {
        allowRangeRequests,
        suggestedLength
      } = validateRangeRequestCapabilities({
        responseHeaders,
        isHttp: stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = extractFilenameFromHeader(responseHeaders);
      if (!this._isStreamingSupported && this._isRangeSupported) {
        this.cancel(new AbortException("Streaming is disabled."));
      }
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a3;
    await this._headersCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    var _a3;
    (_a3 = this._reader) == null ? void 0 : _a3.cancel(reason);
    this._abortController.abort();
  }
};
var PDFFetchStreamRangeReader = class {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._readCapability = Promise.withResolvers();
    this._isStreamingSupported = !source.disableStream;
    this._abortController = new AbortController();
    const headers = new Headers(stream.headers);
    headers.append("Range", `bytes=${begin}-${end - 1}`);
    const url = source.url;
    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response) => {
      const responseOrigin = getResponseOrigin(response.url);
      if (responseOrigin !== stream._responseOrigin) {
        throw new Error(`Expected range response-origin "${responseOrigin}" to match "${stream._responseOrigin}".`);
      }
      if (!validateResponseStatus(response.status)) {
        throw createResponseError(response.status, url);
      }
      this._readCapability.resolve();
      this._reader = response.body.getReader();
    }).catch(this._readCapability.reject);
    this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a3;
    await this._readCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
      loaded: this._loaded
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    var _a3;
    (_a3 = this._reader) == null ? void 0 : _a3.cancel(reason);
    this._abortController.abort();
  }
};
var OK_RESPONSE = 200;
var PARTIAL_CONTENT_RESPONSE = 206;
function network_getArrayBuffer(xhr) {
  const data = xhr.response;
  if (typeof data !== "string") {
    return data;
  }
  return stringToBytes(data).buffer;
}
var NetworkManager = class {
  constructor({
    url,
    httpHeaders,
    withCredentials
  }) {
    __publicField(this, "_responseOrigin", null);
    this.url = url;
    this.isHttp = /^https?:/i.test(url);
    this.headers = createHeaders(this.isHttp, httpHeaders);
    this.withCredentials = withCredentials || false;
    this.currXhrId = 0;
    this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  request(args) {
    const xhr = new XMLHttpRequest();
    const xhrId = this.currXhrId++;
    const pendingRequest = this.pendingRequests[xhrId] = {
      xhr
    };
    xhr.open("GET", this.url);
    xhr.withCredentials = this.withCredentials;
    for (const [key, val] of this.headers) {
      xhr.setRequestHeader(key, val);
    }
    if (this.isHttp && "begin" in args && "end" in args) {
      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
    } else {
      pendingRequest.expectedStatus = OK_RESPONSE;
    }
    xhr.responseType = "arraybuffer";
    assert(args.onError, "Expected `onError` callback to be provided.");
    xhr.onerror = () => {
      args.onError(xhr.status);
    };
    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  }
  onProgress(xhrId, evt) {
    var _a3;
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    (_a3 = pendingRequest.onProgress) == null ? void 0 : _a3.call(pendingRequest, evt);
  }
  onStateChange(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    const xhr = pendingRequest.xhr;
    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }
    if (xhr.readyState !== 4) {
      return;
    }
    if (!(xhrId in this.pendingRequests)) {
      return;
    }
    delete this.pendingRequests[xhrId];
    if (xhr.status === 0 && this.isHttp) {
      pendingRequest.onError(xhr.status);
      return;
    }
    const xhrStatus = xhr.status || OK_RESPONSE;
    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      pendingRequest.onError(xhr.status);
      return;
    }
    const chunk = network_getArrayBuffer(xhr);
    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      const rangeHeader = xhr.getResponseHeader("Content-Range");
      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      if (matches) {
        pendingRequest.onDone({
          begin: parseInt(matches[1], 10),
          chunk
        });
      } else {
        warn(`Missing or invalid "Content-Range" header.`);
        pendingRequest.onError(0);
      }
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk
      });
    } else {
      pendingRequest.onError(xhr.status);
    }
  }
  getRequestXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  }
  isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  }
  abortRequest(xhrId) {
    const xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }
};
var PDFNetworkStream = class {
  constructor(source) {
    this._source = source;
    this._manager = new NetworkManager(source);
    this._rangeChunkSize = source.rangeChunkSize;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(reader) {
    const i = this._rangeRequestReaders.indexOf(reader);
    if (i >= 0) {
      this._rangeRequestReaders.splice(i, 1);
    }
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    var _a3;
    (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
};
var PDFNetworkStreamFullRequestReader = class {
  constructor(manager, source) {
    this._manager = manager;
    this._url = source.url;
    this._fullRequestId = manager.request({
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    });
    this._headersCapability = Promise.withResolvers();
    this._disableRange = source.disableRange || false;
    this._contentLength = source.length;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this._cachedChunks = [];
    this._requests = [];
    this._done = false;
    this._storedError = void 0;
    this._filename = null;
    this.onProgress = null;
  }
  _onHeadersReceived() {
    const fullRequestXhrId = this._fullRequestId;
    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
    this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);
    const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();
    const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((x) => {
      const [key, ...val] = x.split(": ");
      return [key, val.join(": ")];
    }) : []);
    const {
      allowRangeRequests,
      suggestedLength
    } = validateRangeRequestCapabilities({
      responseHeaders,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    if (allowRangeRequests) {
      this._isRangeSupported = true;
    }
    this._contentLength = suggestedLength || this._contentLength;
    this._filename = extractFilenameFromHeader(responseHeaders);
    if (this._isRangeSupported) {
      this._manager.abortRequest(fullRequestXhrId);
    }
    this._headersCapability.resolve();
  }
  _onDone(data) {
    if (data) {
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();
        requestCapability.resolve({
          value: data.chunk,
          done: false
        });
      } else {
        this._cachedChunks.push(data.chunk);
      }
    }
    this._done = true;
    if (this._cachedChunks.length > 0) {
      return;
    }
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
  }
  _onError(status) {
    this._storedError = createResponseError(status, this._url);
    this._headersCapability.reject(this._storedError);
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._cachedChunks.length = 0;
  }
  _onProgress(evt) {
    var _a3;
    (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
      loaded: evt.loaded,
      total: evt.lengthComputable ? evt.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  async read() {
    await this._headersCapability.promise;
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._cachedChunks.length > 0) {
      const chunk = this._cachedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    this._headersCapability.reject(reason);
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }
    this._fullRequestReader = null;
  }
};
var PDFNetworkStreamRangeRequestReader = class {
  constructor(manager, begin, end) {
    this._manager = manager;
    this._url = manager.url;
    this._requestId = manager.request({
      begin,
      end,
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    });
    this._requests = [];
    this._queuedChunk = null;
    this._done = false;
    this._storedError = void 0;
    this.onProgress = null;
    this.onClosed = null;
  }
  _onHeadersReceived() {
    var _a3;
    const responseOrigin = getResponseOrigin((_a3 = this._manager.getRequestXhr(this._requestId)) == null ? void 0 : _a3.responseURL);
    if (responseOrigin !== this._manager._responseOrigin) {
      this._storedError = new Error(`Expected range response-origin "${responseOrigin}" to match "${this._manager._responseOrigin}".`);
      this._onError(0);
    }
  }
  _close() {
    var _a3;
    (_a3 = this.onClosed) == null ? void 0 : _a3.call(this, this);
  }
  _onDone(data) {
    const chunk = data.chunk;
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    this._close();
  }
  _onError(status) {
    var _a3;
    (_a3 = this._storedError) != null ? _a3 : this._storedError = createResponseError(status, this._url);
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._queuedChunk = null;
  }
  _onProgress(evt) {
    var _a3;
    if (!this.isStreamingSupported) {
      (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
        loaded: evt.loaded
      });
    }
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._queuedChunk !== null) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }
    this._close();
  }
};
var urlRegex = /^[a-z][a-z0-9\-+.]+:/i;
function parseUrlOrPath(sourceUrl) {
  if (urlRegex.test(sourceUrl)) {
    return new URL(sourceUrl);
  }
  const url = process.getBuiltinModule("url");
  return new URL(url.pathToFileURL(sourceUrl));
}
var PDFNodeStream = class {
  constructor(source) {
    this.source = source;
    this.url = parseUrlOrPath(source.url);
    assert(this.url.protocol === "file:", "PDFNodeStream only supports file:// URLs.");
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var _a3, _b2;
    return (_b2 = (_a3 = this._fullRequestReader) == null ? void 0 : _a3._loaded) != null ? _b2 : 0;
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNodeStreamFsFullReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(start, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);
    this._rangeRequestReaders.push(rangeReader);
    return rangeReader;
  }
  cancelAllRequests(reason) {
    var _a3;
    (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
};
var PDFNodeStreamFsFullReader = class {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    const source = stream.source;
    this._contentLength = source.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    this._headersCapability = Promise.withResolvers();
    const fs2 = process.getBuiltinModule("fs");
    fs2.promises.lstat(this._url).then((stat) => {
      this._contentLength = stat.size;
      this._setReadableStream(fs2.createReadStream(this._url));
      this._headersCapability.resolve();
    }, (error) => {
      if (error.code === "ENOENT") {
        error = createResponseError(0, this._url.href);
      }
      this._storedError = error;
      this._headersCapability.reject(error);
    });
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a3;
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += chunk.length;
    (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", (reason) => {
      this._error(reason);
    });
    if (!this._isStreamingSupported && this._isRangeSupported) {
      this._error(new AbortException("streaming is disabled"));
    }
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
};
var PDFNodeStreamFsRangeReader = class {
  constructor(stream, start, end) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    const source = stream.source;
    this._isStreamingSupported = !source.disableStream;
    const fs2 = process.getBuiltinModule("fs");
    this._setReadableStream(fs2.createReadStream(this._url, {
      start,
      end: end - 1
    }));
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a3;
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += chunk.length;
    (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
      loaded: this._loaded
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", (reason) => {
      this._error(reason);
    });
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
};
var INITIAL_DATA = Symbol("INITIAL_DATA");
var _objs, _ensureObj, ensureObj_fn;
var PDFObjects = class {
  constructor() {
    __privateAdd(this, _ensureObj);
    __privateAdd(this, _objs, /* @__PURE__ */ Object.create(null));
  }
  get(objId, callback = null) {
    if (callback) {
      const obj2 = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
      obj2.promise.then(() => callback(obj2.data));
      return null;
    }
    const obj = __privateGet(this, _objs)[objId];
    if (!obj || obj.data === INITIAL_DATA) {
      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
    }
    return obj.data;
  }
  has(objId) {
    const obj = __privateGet(this, _objs)[objId];
    return !!obj && obj.data !== INITIAL_DATA;
  }
  delete(objId) {
    const obj = __privateGet(this, _objs)[objId];
    if (!obj || obj.data === INITIAL_DATA) {
      return false;
    }
    delete __privateGet(this, _objs)[objId];
    return true;
  }
  resolve(objId, data = null) {
    const obj = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
    obj.data = data;
    obj.resolve();
  }
  clear() {
    var _a3;
    for (const objId in __privateGet(this, _objs)) {
      const {
        data
      } = __privateGet(this, _objs)[objId];
      (_a3 = data == null ? void 0 : data.bitmap) == null ? void 0 : _a3.close();
    }
    __privateSet(this, _objs, /* @__PURE__ */ Object.create(null));
  }
  *[Symbol.iterator]() {
    for (const objId in __privateGet(this, _objs)) {
      const {
        data
      } = __privateGet(this, _objs)[objId];
      if (data === INITIAL_DATA) {
        continue;
      }
      yield [objId, data];
    }
  }
};
_objs = new WeakMap();
_ensureObj = new WeakSet();
ensureObj_fn = function(objId) {
  var _a3;
  return (_a3 = __privateGet(this, _objs))[objId] || (_a3[objId] = {
    ...Promise.withResolvers(),
    data: INITIAL_DATA
  });
};
var MAX_TEXT_DIVS_TO_RENDER = 1e5;
var DEFAULT_FONT_SIZE = 30;
var _a, _capability, _container3, _disableProcessItems, _fontInspectorEnabled, _lang, _layoutTextParams, _pageHeight, _pageWidth, _reader, _rootContainer, _rotation, _scale, _styleCache, _textContentItemsStr, _textContentSource, _textDivs, _textDivProperties, _transform, _ascentCache, _canvasContexts, _canvasCtxFonts, _minFontSize, _pendingTextLayers, _processItems, processItems_fn, _appendText, appendText_fn, _layout, layout_fn, _getCtx, getCtx_fn, _ensureCtxFont, ensureCtxFont_fn, _ensureMinFontSizeComputed, ensureMinFontSizeComputed_fn, _getAscent, getAscent_fn;
var _TextLayer = class _TextLayer {
  constructor({
    textContentSource,
    container,
    viewport
  }) {
    __privateAdd(this, _processItems);
    __privateAdd(this, _appendText);
    __privateAdd(this, _layout);
    __privateAdd(this, _capability, Promise.withResolvers());
    __privateAdd(this, _container3, null);
    __privateAdd(this, _disableProcessItems, false);
    __privateAdd(this, _fontInspectorEnabled, !!((_a = globalThis.FontInspector) == null ? void 0 : _a.enabled));
    __privateAdd(this, _lang, null);
    __privateAdd(this, _layoutTextParams, null);
    __privateAdd(this, _pageHeight, 0);
    __privateAdd(this, _pageWidth, 0);
    __privateAdd(this, _reader, null);
    __privateAdd(this, _rootContainer, null);
    __privateAdd(this, _rotation, 0);
    __privateAdd(this, _scale, 0);
    __privateAdd(this, _styleCache, /* @__PURE__ */ Object.create(null));
    __privateAdd(this, _textContentItemsStr, []);
    __privateAdd(this, _textContentSource, null);
    __privateAdd(this, _textDivs, []);
    __privateAdd(this, _textDivProperties, /* @__PURE__ */ new WeakMap());
    __privateAdd(this, _transform, null);
    var _a3;
    if (textContentSource instanceof ReadableStream) {
      __privateSet(this, _textContentSource, textContentSource);
    } else if (typeof textContentSource === "object") {
      __privateSet(this, _textContentSource, new ReadableStream({
        start(controller) {
          controller.enqueue(textContentSource);
          controller.close();
        }
      }));
    } else {
      throw new Error('No "textContentSource" parameter specified.');
    }
    __privateSet(this, _container3, __privateSet(this, _rootContainer, container));
    __privateSet(this, _scale, viewport.scale * OutputScale.pixelRatio);
    __privateSet(this, _rotation, viewport.rotation);
    __privateSet(this, _layoutTextParams, {
      div: null,
      properties: null,
      ctx: null
    });
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    __privateSet(this, _transform, [1, 0, 0, -1, -pageX, pageY + pageHeight]);
    __privateSet(this, _pageWidth, pageWidth);
    __privateSet(this, _pageHeight, pageHeight);
    __privateMethod(_a3 = _TextLayer, _ensureMinFontSizeComputed, ensureMinFontSizeComputed_fn).call(_a3);
    setLayerDimensions(container, viewport);
    __privateGet(this, _capability).promise.finally(() => {
      __privateGet(_TextLayer, _pendingTextLayers).delete(this);
      __privateSet(this, _layoutTextParams, null);
      __privateSet(this, _styleCache, null);
    }).catch(() => {
    });
  }
  static get fontFamilyMap() {
    const {
      isWindows,
      isFirefox
    } = util_FeatureTest.platform;
    return shadow(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", `${isWindows && isFirefox ? "Calibri, " : ""}sans-serif`], ["monospace", `${isWindows && isFirefox ? "Lucida Console, " : ""}monospace`]]));
  }
  render() {
    const pump = () => {
      __privateGet(this, _reader).read().then(({
        value,
        done
      }) => {
        var _a3;
        if (done) {
          __privateGet(this, _capability).resolve();
          return;
        }
        (_a3 = __privateGet(this, _lang)) != null ? _a3 : __privateSet(this, _lang, value.lang);
        Object.assign(__privateGet(this, _styleCache), value.styles);
        __privateMethod(this, _processItems, processItems_fn).call(this, value.items);
        pump();
      }, __privateGet(this, _capability).reject);
    };
    __privateSet(this, _reader, __privateGet(this, _textContentSource).getReader());
    __privateGet(_TextLayer, _pendingTextLayers).add(this);
    pump();
    return __privateGet(this, _capability).promise;
  }
  update({
    viewport,
    onBefore = null
  }) {
    var _a3;
    const scale = viewport.scale * OutputScale.pixelRatio;
    const rotation = viewport.rotation;
    if (rotation !== __privateGet(this, _rotation)) {
      onBefore == null ? void 0 : onBefore();
      __privateSet(this, _rotation, rotation);
      setLayerDimensions(__privateGet(this, _rootContainer), {
        rotation
      });
    }
    if (scale !== __privateGet(this, _scale)) {
      onBefore == null ? void 0 : onBefore();
      __privateSet(this, _scale, scale);
      const params = {
        div: null,
        properties: null,
        ctx: __privateMethod(_a3 = _TextLayer, _getCtx, getCtx_fn).call(_a3, __privateGet(this, _lang))
      };
      for (const div of __privateGet(this, _textDivs)) {
        params.properties = __privateGet(this, _textDivProperties).get(div);
        params.div = div;
        __privateMethod(this, _layout, layout_fn).call(this, params);
      }
    }
  }
  cancel() {
    var _a3;
    const abortEx = new AbortException("TextLayer task cancelled.");
    (_a3 = __privateGet(this, _reader)) == null ? void 0 : _a3.cancel(abortEx).catch(() => {
    });
    __privateSet(this, _reader, null);
    __privateGet(this, _capability).reject(abortEx);
  }
  get textDivs() {
    return __privateGet(this, _textDivs);
  }
  get textContentItemsStr() {
    return __privateGet(this, _textContentItemsStr);
  }
  static cleanup() {
    if (__privateGet(this, _pendingTextLayers).size > 0) {
      return;
    }
    __privateGet(this, _ascentCache).clear();
    for (const {
      canvas
    } of __privateGet(this, _canvasContexts).values()) {
      canvas.remove();
    }
    __privateGet(this, _canvasContexts).clear();
  }
};
_capability = new WeakMap();
_container3 = new WeakMap();
_disableProcessItems = new WeakMap();
_fontInspectorEnabled = new WeakMap();
_lang = new WeakMap();
_layoutTextParams = new WeakMap();
_pageHeight = new WeakMap();
_pageWidth = new WeakMap();
_reader = new WeakMap();
_rootContainer = new WeakMap();
_rotation = new WeakMap();
_scale = new WeakMap();
_styleCache = new WeakMap();
_textContentItemsStr = new WeakMap();
_textContentSource = new WeakMap();
_textDivs = new WeakMap();
_textDivProperties = new WeakMap();
_transform = new WeakMap();
_ascentCache = new WeakMap();
_canvasContexts = new WeakMap();
_canvasCtxFonts = new WeakMap();
_minFontSize = new WeakMap();
_pendingTextLayers = new WeakMap();
_processItems = new WeakSet();
processItems_fn = function(items) {
  var _a3, _b2, _c;
  if (__privateGet(this, _disableProcessItems)) {
    return;
  }
  (_c = (_b2 = __privateGet(this, _layoutTextParams)).ctx) != null ? _c : _b2.ctx = __privateMethod(_a3 = _TextLayer, _getCtx, getCtx_fn).call(_a3, __privateGet(this, _lang));
  const textDivs = __privateGet(this, _textDivs), textContentItemsStr = __privateGet(this, _textContentItemsStr);
  for (const item of items) {
    if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {
      warn("Ignoring additional textDivs for performance reasons.");
      __privateSet(this, _disableProcessItems, true);
      return;
    }
    if (item.str === void 0) {
      if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
        const parent = __privateGet(this, _container3);
        __privateSet(this, _container3, document.createElement("span"));
        __privateGet(this, _container3).classList.add("markedContent");
        if (item.id) {
          __privateGet(this, _container3).setAttribute("id", `${item.id}`);
        }
        parent.append(__privateGet(this, _container3));
      } else if (item.type === "endMarkedContent") {
        __privateSet(this, _container3, __privateGet(this, _container3).parentNode);
      }
      continue;
    }
    textContentItemsStr.push(item.str);
    __privateMethod(this, _appendText, appendText_fn).call(this, item);
  }
};
_appendText = new WeakSet();
appendText_fn = function(geom) {
  var _a3;
  const textDiv = document.createElement("span");
  const textDivProperties = {
    angle: 0,
    canvasWidth: 0,
    hasText: geom.str !== "",
    hasEOL: geom.hasEOL,
    fontSize: 0
  };
  __privateGet(this, _textDivs).push(textDiv);
  const tx = Util.transform(__privateGet(this, _transform), geom.transform);
  let angle = Math.atan2(tx[1], tx[0]);
  const style = __privateGet(this, _styleCache)[geom.fontName];
  if (style.vertical) {
    angle += Math.PI / 2;
  }
  let fontFamily = __privateGet(this, _fontInspectorEnabled) && style.fontSubstitution || style.fontFamily;
  fontFamily = _TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;
  const fontHeight = Math.hypot(tx[2], tx[3]);
  const fontAscent = fontHeight * __privateMethod(_a3 = _TextLayer, _getAscent, getAscent_fn).call(_a3, fontFamily, style, __privateGet(this, _lang));
  let left, top;
  if (angle === 0) {
    left = tx[4];
    top = tx[5] - fontAscent;
  } else {
    left = tx[4] + fontAscent * Math.sin(angle);
    top = tx[5] - fontAscent * Math.cos(angle);
  }
  const scaleFactorStr = "calc(var(--total-scale-factor) *";
  const divStyle = textDiv.style;
  if (__privateGet(this, _container3) === __privateGet(this, _rootContainer)) {
    divStyle.left = `${(100 * left / __privateGet(this, _pageWidth)).toFixed(2)}%`;
    divStyle.top = `${(100 * top / __privateGet(this, _pageHeight)).toFixed(2)}%`;
  } else {
    divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
    divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
  }
  divStyle.fontSize = `${scaleFactorStr}${(__privateGet(_TextLayer, _minFontSize) * fontHeight).toFixed(2)}px)`;
  divStyle.fontFamily = fontFamily;
  textDivProperties.fontSize = fontHeight;
  textDiv.setAttribute("role", "presentation");
  textDiv.textContent = geom.str;
  textDiv.dir = geom.dir;
  if (__privateGet(this, _fontInspectorEnabled)) {
    textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;
  }
  if (angle !== 0) {
    textDivProperties.angle = angle * (180 / Math.PI);
  }
  let shouldScaleText = false;
  if (geom.str.length > 1) {
    shouldScaleText = true;
  } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
    const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
      shouldScaleText = true;
    }
  }
  if (shouldScaleText) {
    textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
  }
  __privateGet(this, _textDivProperties).set(textDiv, textDivProperties);
  __privateGet(this, _layoutTextParams).div = textDiv;
  __privateGet(this, _layoutTextParams).properties = textDivProperties;
  __privateMethod(this, _layout, layout_fn).call(this, __privateGet(this, _layoutTextParams));
  if (textDivProperties.hasText) {
    __privateGet(this, _container3).append(textDiv);
  }
  if (textDivProperties.hasEOL) {
    const br = document.createElement("br");
    br.setAttribute("role", "presentation");
    __privateGet(this, _container3).append(br);
  }
};
_layout = new WeakSet();
layout_fn = function(params) {
  var _a3;
  const {
    div,
    properties,
    ctx
  } = params;
  const {
    style
  } = div;
  let transform = "";
  if (__privateGet(_TextLayer, _minFontSize) > 1) {
    transform = `scale(${1 / __privateGet(_TextLayer, _minFontSize)})`;
  }
  if (properties.canvasWidth !== 0 && properties.hasText) {
    const {
      fontFamily
    } = style;
    const {
      canvasWidth,
      fontSize
    } = properties;
    __privateMethod(_a3 = _TextLayer, _ensureCtxFont, ensureCtxFont_fn).call(_a3, ctx, fontSize * __privateGet(this, _scale), fontFamily);
    const {
      width
    } = ctx.measureText(div.textContent);
    if (width > 0) {
      transform = `scaleX(${canvasWidth * __privateGet(this, _scale) / width}) ${transform}`;
    }
  }
  if (properties.angle !== 0) {
    transform = `rotate(${properties.angle}deg) ${transform}`;
  }
  if (transform.length > 0) {
    style.transform = transform;
  }
};
_getCtx = new WeakSet();
getCtx_fn = function(lang = null) {
  let ctx = __privateGet(this, _canvasContexts).get(lang || (lang = ""));
  if (!ctx) {
    const canvas = document.createElement("canvas");
    canvas.className = "hiddenCanvasElement";
    canvas.lang = lang;
    document.body.append(canvas);
    ctx = canvas.getContext("2d", {
      alpha: false,
      willReadFrequently: true
    });
    __privateGet(this, _canvasContexts).set(lang, ctx);
    __privateGet(this, _canvasCtxFonts).set(ctx, {
      size: 0,
      family: ""
    });
  }
  return ctx;
};
_ensureCtxFont = new WeakSet();
ensureCtxFont_fn = function(ctx, size, family) {
  const cached = __privateGet(this, _canvasCtxFonts).get(ctx);
  if (size === cached.size && family === cached.family) {
    return;
  }
  ctx.font = `${size}px ${family}`;
  cached.size = size;
  cached.family = family;
};
_ensureMinFontSizeComputed = new WeakSet();
ensureMinFontSizeComputed_fn = function() {
  if (__privateGet(this, _minFontSize) !== null) {
    return;
  }
  const div = document.createElement("div");
  div.style.opacity = 0;
  div.style.lineHeight = 1;
  div.style.fontSize = "1px";
  div.style.position = "absolute";
  div.textContent = "X";
  document.body.append(div);
  __privateSet(this, _minFontSize, div.getBoundingClientRect().height);
  div.remove();
};
_getAscent = new WeakSet();
getAscent_fn = function(fontFamily, style, lang) {
  const cachedAscent = __privateGet(this, _ascentCache).get(fontFamily);
  if (cachedAscent) {
    return cachedAscent;
  }
  const ctx = __privateMethod(this, _getCtx, getCtx_fn).call(this, lang);
  ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;
  __privateMethod(this, _ensureCtxFont, ensureCtxFont_fn).call(this, ctx, DEFAULT_FONT_SIZE, fontFamily);
  const metrics = ctx.measureText("");
  const ascent = metrics.fontBoundingBoxAscent;
  const descent = Math.abs(metrics.fontBoundingBoxDescent);
  ctx.canvas.width = ctx.canvas.height = 0;
  let ratio = 0.8;
  if (ascent) {
    ratio = ascent / (ascent + descent);
  } else {
    if (util_FeatureTest.platform.isFirefox) {
      warn("Enable the `dom.textMetrics.fontBoundingBox.enabled` preference in `about:config` to improve TextLayer rendering.");
    }
    if (style.ascent) {
      ratio = style.ascent;
    } else if (style.descent) {
      ratio = 1 + style.descent;
    }
  }
  __privateGet(this, _ascentCache).set(fontFamily, ratio);
  return ratio;
};
__privateAdd(_TextLayer, _getCtx);
__privateAdd(_TextLayer, _ensureCtxFont);
__privateAdd(_TextLayer, _ensureMinFontSizeComputed);
__privateAdd(_TextLayer, _getAscent);
__privateAdd(_TextLayer, _ascentCache, /* @__PURE__ */ new Map());
__privateAdd(_TextLayer, _canvasContexts, /* @__PURE__ */ new Map());
__privateAdd(_TextLayer, _canvasCtxFonts, /* @__PURE__ */ new WeakMap());
__privateAdd(_TextLayer, _minFontSize, null);
__privateAdd(_TextLayer, _pendingTextLayers, /* @__PURE__ */ new Set());
var TextLayer = _TextLayer;
var XfaText = class _XfaText {
  static textContent(xfa) {
    const items = [];
    const output = {
      items,
      styles: /* @__PURE__ */ Object.create(null)
    };
    function walk(node) {
      var _a3;
      if (!node) {
        return;
      }
      let str = null;
      const name = node.name;
      if (name === "#text") {
        str = node.value;
      } else if (!_XfaText.shouldBuildText(name)) {
        return;
      } else if ((_a3 = node == null ? void 0 : node.attributes) == null ? void 0 : _a3.textContent) {
        str = node.attributes.textContent;
      } else if (node.value) {
        str = node.value;
      }
      if (str !== null) {
        items.push({
          str
        });
      }
      if (!node.children) {
        return;
      }
      for (const child of node.children) {
        walk(child);
      }
    }
    walk(xfa);
    return output;
  }
  static shouldBuildText(name) {
    return !(name === "textarea" || name === "input" || name === "option" || name === "select");
  }
};
var RENDERING_CANCELLED_TIMEOUT = 100;
function getDocument(src = {}) {
  var _a3, _b2;
  if (typeof src === "string" || src instanceof URL) {
    src = {
      url: src
    };
  } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {
    src = {
      data: src
    };
  }
  const task = new PDFDocumentLoadingTask();
  const {
    docId
  } = task;
  const url = src.url ? getUrlProp(src.url) : null;
  const data = src.data ? getDataProp(src.data) : null;
  const httpHeaders = src.httpHeaders || null;
  const withCredentials = src.withCredentials === true;
  const password = (_a3 = src.password) != null ? _a3 : null;
  const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;
  let worker = src.worker instanceof PDFWorker ? src.worker : null;
  const verbosity2 = src.verbosity;
  const docBaseUrl = typeof src.docBaseUrl === "string" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;
  const cMapUrl = getFactoryUrlProp(src.cMapUrl);
  const cMapPacked = src.cMapPacked !== false;
  const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);
  const iccUrl = getFactoryUrlProp(src.iccUrl);
  const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);
  const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);
  const wasmUrl = getFactoryUrlProp(src.wasmUrl);
  const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);
  const ignoreErrors = src.stopAtErrors !== true;
  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
  const isEvalSupported2 = src.isEvalSupported !== false;
  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !isNodeJS;
  const isImageDecoderSupported = typeof src.isImageDecoderSupported === "boolean" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);
  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
  const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : isNodeJS;
  const fontExtraProperties = src.fontExtraProperties === true;
  const enableXfa = src.enableXfa === true;
  const ownerDocument = src.ownerDocument || globalThis.document;
  const disableRange = src.disableRange === true;
  const disableStream = src.disableStream === true;
  const disableAutoFetch = src.disableAutoFetch === true;
  const pdfBug = src.pdfBug === true;
  const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);
  const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);
  const enableHWA = src.enableHWA === true;
  const useWasm = src.useWasm !== false;
  const length = rangeTransport ? rangeTransport.length : (_b2 = src.length) != null ? _b2 : NaN;
  const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !isNodeJS && !disableFontFace;
  const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));
  const styleElement = null;
  setVerbosityLevel(verbosity2);
  const transportFactory = {
    canvasFactory: new CanvasFactory({
      ownerDocument,
      enableHWA
    }),
    filterFactory: new FilterFactory({
      docId,
      ownerDocument
    }),
    cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({
      baseUrl: cMapUrl,
      isCompressed: cMapPacked
    }),
    standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({
      baseUrl: standardFontDataUrl
    }),
    wasmFactory: useWorkerFetch ? null : new WasmFactory({
      baseUrl: wasmUrl
    })
  };
  if (!worker) {
    worker = PDFWorker.create({
      verbosity: verbosity2,
      port: GlobalWorkerOptions.workerPort
    });
    task._worker = worker;
  }
  const docParams = {
    docId,
    apiVersion: "5.4.149",
    data,
    password,
    disableAutoFetch,
    rangeChunkSize,
    length,
    docBaseUrl,
    enableXfa,
    evaluatorOptions: {
      maxImageSize,
      disableFontFace,
      ignoreErrors,
      isEvalSupported: isEvalSupported2,
      isOffscreenCanvasSupported,
      isImageDecoderSupported,
      canvasMaxAreaInBytes,
      fontExtraProperties,
      useSystemFonts,
      useWasm,
      useWorkerFetch,
      cMapUrl,
      iccUrl,
      standardFontDataUrl,
      wasmUrl
    }
  };
  const transportParams = {
    ownerDocument,
    pdfBug,
    styleElement,
    loadingParams: {
      disableAutoFetch,
      enableXfa
    }
  };
  worker.promise.then(function() {
    if (task.destroyed) {
      throw new Error("Loading aborted");
    }
    if (worker.destroyed) {
      throw new Error("Worker was destroyed");
    }
    const workerIdPromise = worker.messageHandler.sendWithPromise("GetDocRequest", docParams, data ? [data.buffer] : null);
    let networkStream;
    if (rangeTransport) {
      networkStream = new PDFDataTransportStream(rangeTransport, {
        disableRange,
        disableStream
      });
    } else if (!data) {
      if (!url) {
        throw new Error("getDocument - no `url` parameter provided.");
      }
      const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;
      networkStream = new NetworkStream({
        url,
        length,
        httpHeaders,
        withCredentials,
        rangeChunkSize,
        disableRange,
        disableStream
      });
    }
    return workerIdPromise.then((workerId) => {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }
      if (worker.destroyed) {
        throw new Error("Worker was destroyed");
      }
      const messageHandler = new MessageHandler(docId, workerId, worker.port);
      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);
      task._transport = transport;
      messageHandler.send("Ready", null);
    });
  }).catch(task._capability.reject);
  return task;
}
var _docId2;
var _PDFDocumentLoadingTask = class _PDFDocumentLoadingTask {
  constructor() {
    __publicField(this, "_capability", Promise.withResolvers());
    __publicField(this, "_transport", null);
    __publicField(this, "_worker", null);
    __publicField(this, "docId", `d${__privateWrapper(_PDFDocumentLoadingTask, _docId2)._++}`);
    __publicField(this, "destroyed", false);
    __publicField(this, "onPassword", null);
    __publicField(this, "onProgress", null);
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    var _a3, _b2, _c, _d;
    this.destroyed = true;
    try {
      if ((_a3 = this._worker) == null ? void 0 : _a3.port) {
        this._worker._pendingDestroy = true;
      }
      await ((_b2 = this._transport) == null ? void 0 : _b2.destroy());
    } catch (ex) {
      if ((_c = this._worker) == null ? void 0 : _c.port) {
        delete this._worker._pendingDestroy;
      }
      throw ex;
    }
    this._transport = null;
    (_d = this._worker) == null ? void 0 : _d.destroy();
    this._worker = null;
  }
  async getData() {
    return this._transport.getData();
  }
};
_docId2 = new WeakMap();
__privateAdd(_PDFDocumentLoadingTask, _docId2, 0);
var PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
var _capability2, _progressiveDoneListeners, _progressiveReadListeners, _progressListeners, _rangeListeners;
var PDFDataRangeTransport = class {
  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
    __privateAdd(this, _capability2, Promise.withResolvers());
    __privateAdd(this, _progressiveDoneListeners, []);
    __privateAdd(this, _progressiveReadListeners, []);
    __privateAdd(this, _progressListeners, []);
    __privateAdd(this, _rangeListeners, []);
    this.length = length;
    this.initialData = initialData;
    this.progressiveDone = progressiveDone;
    this.contentDispositionFilename = contentDispositionFilename;
  }
  addRangeListener(listener) {
    __privateGet(this, _rangeListeners).push(listener);
  }
  addProgressListener(listener) {
    __privateGet(this, _progressListeners).push(listener);
  }
  addProgressiveReadListener(listener) {
    __privateGet(this, _progressiveReadListeners).push(listener);
  }
  addProgressiveDoneListener(listener) {
    __privateGet(this, _progressiveDoneListeners).push(listener);
  }
  onDataRange(begin, chunk) {
    for (const listener of __privateGet(this, _rangeListeners)) {
      listener(begin, chunk);
    }
  }
  onDataProgress(loaded, total) {
    __privateGet(this, _capability2).promise.then(() => {
      for (const listener of __privateGet(this, _progressListeners)) {
        listener(loaded, total);
      }
    });
  }
  onDataProgressiveRead(chunk) {
    __privateGet(this, _capability2).promise.then(() => {
      for (const listener of __privateGet(this, _progressiveReadListeners)) {
        listener(chunk);
      }
    });
  }
  onDataProgressiveDone() {
    __privateGet(this, _capability2).promise.then(() => {
      for (const listener of __privateGet(this, _progressiveDoneListeners)) {
        listener();
      }
    });
  }
  transportReady() {
    __privateGet(this, _capability2).resolve();
  }
  requestDataRange(begin, end) {
    unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
};
_capability2 = new WeakMap();
_progressiveDoneListeners = new WeakMap();
_progressiveReadListeners = new WeakMap();
_progressListeners = new WeakMap();
_rangeListeners = new WeakMap();
var PDFDocumentProxy = class {
  constructor(pdfInfo, transport) {
    this._pdfInfo = pdfInfo;
    this._transport = transport;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get canvasFactory() {
    return this._transport.canvasFactory;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(pageNumber) {
    return this._transport.getPage(pageNumber);
  }
  getPageIndex(ref) {
    return this._transport.getPageIndex(ref);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(id) {
    return this._transport.getDestination(id);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getAnnotationsByType(types, pageIndexesToSkip) {
    return this._transport.getAnnotationsByType(types, pageIndexesToSkip);
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent = "display"
  } = {}) {
    const {
      renderingIntent
    } = this._transport.getRenderingIntent(intent);
    return this._transport.getOptionalContentConfig(renderingIntent);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(keepLoadedFonts = false) {
    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(ref) {
    return this._transport.cachedPageNumber(ref);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
};
var _pendingCleanup, _tryCleanup, tryCleanup_fn;
var PDFPageProxy = class {
  constructor(pageIndex, pageInfo, transport, pdfBug = false) {
    __privateAdd(this, _tryCleanup);
    __privateAdd(this, _pendingCleanup, false);
    this._pageIndex = pageIndex;
    this._pageInfo = pageInfo;
    this._transport = transport;
    this._stats = pdfBug ? new StatTimer() : null;
    this._pdfBug = pdfBug;
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this._intentStates = /* @__PURE__ */ new Map();
    this.destroyed = false;
    this.recordedGroups = null;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale,
    rotation = this.rotate,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.view,
      userUnit: this.userUnit,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  getAnnotations({
    intent = "display"
  } = {}) {
    const {
      renderingIntent
    } = this._transport.getRenderingIntent(intent);
    return this._transport.getAnnotations(this._pageIndex, renderingIntent);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    var _a3;
    return ((_a3 = this._transport._htmlForXfa) == null ? void 0 : _a3.children[this._pageIndex]) || null;
  }
  render({
    canvasContext,
    canvas = canvasContext.canvas,
    viewport,
    intent = "display",
    annotationMode = AnnotationMode.ENABLE,
    transform = null,
    background: background2 = null,
    optionalContentConfigPromise = null,
    annotationCanvasMap = null,
    pageColors = null,
    printAnnotationStorage = null,
    isEditing = false,
    recordOperations = false,
    filteredOperationIndexes = null
  }) {
    var _a3, _b2, _c;
    (_a3 = this._stats) == null ? void 0 : _a3.time("Overall");
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);
    const {
      renderingIntent,
      cacheKey
    } = intentArgs;
    __privateSet(this, _pendingCleanup, false);
    optionalContentConfigPromise || (optionalContentConfigPromise = this._transport.getOptionalContentConfig(renderingIntent));
    let intentState = this._intentStates.get(cacheKey);
    if (!intentState) {
      intentState = /* @__PURE__ */ Object.create(null);
      this._intentStates.set(cacheKey, intentState);
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
    if (!intentState.displayReadyCapability) {
      intentState.displayReadyCapability = Promise.withResolvers();
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      (_b2 = this._stats) == null ? void 0 : _b2.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    const shouldRecordOperations = !this.recordedGroups && (recordOperations || this._pdfBug && ((_c = globalThis.StepperManager) == null ? void 0 : _c.enabled));
    const complete = (error) => {
      var _a4, _b3, _c2;
      intentState.renderTasks.delete(internalRenderTask);
      if (shouldRecordOperations) {
        const recordedGroups = (_a4 = internalRenderTask.gfx) == null ? void 0 : _a4.dependencyTracker.take();
        if (recordedGroups) {
          (_b3 = internalRenderTask.stepper) == null ? void 0 : _b3.setOperatorGroups(recordedGroups);
          if (recordOperations) {
            this.recordedGroups = recordedGroups;
          }
        } else if (recordOperations) {
          this.recordedGroups = [];
        }
      }
      if (intentPrint) {
        __privateSet(this, _pendingCleanup, true);
      }
      __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this);
      if (error) {
        internalRenderTask.capability.reject(error);
        this._abortOperatorList({
          intentState,
          reason: error instanceof Error ? error : new Error(error)
        });
      } else {
        internalRenderTask.capability.resolve();
      }
      if (this._stats) {
        this._stats.timeEnd("Rendering");
        this._stats.timeEnd("Overall");
        if ((_c2 = globalThis.Stats) == null ? void 0 : _c2.enabled) {
          globalThis.Stats.add(this.pageNumber, this._stats);
        }
      }
    };
    const internalRenderTask = new InternalRenderTask({
      callback: complete,
      params: {
        canvas,
        canvasContext,
        dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas) : null,
        viewport,
        transform,
        background: background2
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap,
      operatorList: intentState.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !intentPrint,
      pdfBug: this._pdfBug,
      pageColors,
      enableHWA: this._transport.enableHWA,
      filteredOperationIndexes
    });
    (intentState.renderTasks || (intentState.renderTasks = /* @__PURE__ */ new Set())).add(internalRenderTask);
    const renderTask = internalRenderTask.task;
    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
      var _a4;
      if (this.destroyed) {
        complete();
        return;
      }
      (_a4 = this._stats) == null ? void 0 : _a4.time("Rendering");
      if (!(optionalContentConfig.renderingIntent & renderingIntent)) {
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      }
      internalRenderTask.initializeGraphics({
        transparency,
        optionalContentConfig
      });
      internalRenderTask.operatorListChanged();
    }).catch(complete);
    return renderTask;
  }
  getOperatorList({
    intent = "display",
    annotationMode = AnnotationMode.ENABLE,
    printAnnotationStorage = null,
    isEditing = false
  } = {}) {
    var _a3;
    function operatorListChanged() {
      if (intentState.operatorList.lastChunk) {
        intentState.opListReadCapability.resolve(intentState.operatorList);
        intentState.renderTasks.delete(opListTask);
      }
    }
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);
    let intentState = this._intentStates.get(intentArgs.cacheKey);
    if (!intentState) {
      intentState = /* @__PURE__ */ Object.create(null);
      this._intentStates.set(intentArgs.cacheKey, intentState);
    }
    let opListTask;
    if (!intentState.opListReadCapability) {
      opListTask = /* @__PURE__ */ Object.create(null);
      opListTask.operatorListChanged = operatorListChanged;
      intentState.opListReadCapability = Promise.withResolvers();
      (intentState.renderTasks || (intentState.renderTasks = /* @__PURE__ */ new Set())).add(opListTask);
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      (_a3 = this._stats) == null ? void 0 : _a3.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    return intentState.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent = false,
    disableNormalization = false
  } = {}) {
    const TEXT_CONTENT_CHUNK_SIZE = 100;
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: includeMarkedContent === true,
      disableNormalization: disableNormalization === true
    }, {
      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
      size(textContent) {
        return textContent.items.length;
      }
    });
  }
  getTextContent(params = {}) {
    if (this._transport._htmlForXfa) {
      return this.getXfa().then((xfa) => XfaText.textContent(xfa));
    }
    const readableStream = this.streamTextContent(params);
    return new Promise(function(resolve, reject) {
      function pump() {
        reader.read().then(function({
          value,
          done
        }) {
          var _a3;
          if (done) {
            resolve(textContent);
            return;
          }
          (_a3 = textContent.lang) != null ? _a3 : textContent.lang = value.lang;
          Object.assign(textContent.styles, value.styles);
          textContent.items.push(...value.items);
          pump();
        }, reject);
      }
      const reader = readableStream.getReader();
      const textContent = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: null
      };
      pump();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = true;
    const waitOn = [];
    for (const intentState of this._intentStates.values()) {
      this._abortOperatorList({
        intentState,
        reason: new Error("Page was destroyed."),
        force: true
      });
      if (intentState.opListReadCapability) {
        continue;
      }
      for (const internalRenderTask of intentState.renderTasks) {
        waitOn.push(internalRenderTask.completed);
        internalRenderTask.cancel();
      }
    }
    this.objs.clear();
    __privateSet(this, _pendingCleanup, false);
    return Promise.all(waitOn);
  }
  cleanup(resetStats = false) {
    __privateSet(this, _pendingCleanup, true);
    const success = __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this);
    if (resetStats && success) {
      this._stats && (this._stats = new StatTimer());
    }
    return success;
  }
  _startRenderPage(transparency, cacheKey) {
    var _a3, _b2;
    const intentState = this._intentStates.get(cacheKey);
    if (!intentState) {
      return;
    }
    (_a3 = this._stats) == null ? void 0 : _a3.timeEnd("Page Request");
    (_b2 = intentState.displayReadyCapability) == null ? void 0 : _b2.resolve(transparency);
  }
  _renderPageChunk(operatorListChunk, intentState) {
    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
    }
    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
    for (const internalRenderTask of intentState.renderTasks) {
      internalRenderTask.operatorListChanged();
    }
    if (operatorListChunk.lastChunk) {
      __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this);
    }
  }
  _pumpOperatorList({
    renderingIntent,
    cacheKey,
    annotationStorageSerializable,
    modifiedIds
  }) {
    const {
      map,
      transfer
    } = annotationStorageSerializable;
    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: renderingIntent,
      cacheKey,
      annotationStorage: map,
      modifiedIds
    }, transfer);
    const reader = readableStream.getReader();
    const intentState = this._intentStates.get(cacheKey);
    intentState.streamReader = reader;
    const pump = () => {
      reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          intentState.streamReader = null;
          return;
        }
        if (this._transport.destroyed) {
          return;
        }
        this._renderPageChunk(value, intentState);
        pump();
      }, (reason) => {
        intentState.streamReader = null;
        if (this._transport.destroyed) {
          return;
        }
        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;
          for (const internalRenderTask of intentState.renderTasks) {
            internalRenderTask.operatorListChanged();
          }
          __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this);
        }
        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(reason);
        } else if (intentState.opListReadCapability) {
          intentState.opListReadCapability.reject(reason);
        } else {
          throw reason;
        }
      });
    };
    pump();
  }
  _abortOperatorList({
    intentState,
    reason,
    force = false
  }) {
    if (!intentState.streamReader) {
      return;
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    if (!force) {
      if (intentState.renderTasks.size > 0) {
        return;
      }
      if (reason instanceof RenderingCancelledException) {
        let delay = RENDERING_CANCELLED_TIMEOUT;
        if (reason.extraDelay > 0 && reason.extraDelay < 1e3) {
          delay += reason.extraDelay;
        }
        intentState.streamReaderCancelTimeout = setTimeout(() => {
          intentState.streamReaderCancelTimeout = null;
          this._abortOperatorList({
            intentState,
            reason,
            force: true
          });
        }, delay);
        return;
      }
    }
    intentState.streamReader.cancel(new AbortException(reason.message)).catch(() => {
    });
    intentState.streamReader = null;
    if (this._transport.destroyed) {
      return;
    }
    for (const [curCacheKey, curIntentState] of this._intentStates) {
      if (curIntentState === intentState) {
        this._intentStates.delete(curCacheKey);
        break;
      }
    }
    this.cleanup();
  }
  get stats() {
    return this._stats;
  }
};
_pendingCleanup = new WeakMap();
_tryCleanup = new WeakSet();
tryCleanup_fn = function() {
  if (!__privateGet(this, _pendingCleanup) || this.destroyed) {
    return false;
  }
  for (const {
    renderTasks,
    operatorList
  } of this._intentStates.values()) {
    if (renderTasks.size > 0 || !operatorList.lastChunk) {
      return false;
    }
  }
  this._intentStates.clear();
  this.objs.clear();
  __privateSet(this, _pendingCleanup, false);
  return true;
};
var _capability3, _messageHandler, _port2, _webWorker, _fakeWorkerId, _isWorkerDisabled, _workerPorts, _resolve, resolve_fn, _initializeFromPort, initializeFromPort_fn, _initialize, initialize_fn, _setupFakeWorker, setupFakeWorker_fn, _mainThreadWorkerMessageHandler, mainThreadWorkerMessageHandler_get;
var _PDFWorker = class _PDFWorker {
  constructor({
    name = null,
    port = null,
    verbosity: verbosity2 = getVerbosityLevel()
  } = {}) {
    __privateAdd(this, _resolve);
    __privateAdd(this, _initializeFromPort);
    __privateAdd(this, _initialize);
    __privateAdd(this, _setupFakeWorker);
    __privateAdd(this, _capability3, Promise.withResolvers());
    __privateAdd(this, _messageHandler, null);
    __privateAdd(this, _port2, null);
    __privateAdd(this, _webWorker, null);
    this.name = name;
    this.destroyed = false;
    this.verbosity = verbosity2;
    if (port) {
      if (__privateGet(_PDFWorker, _workerPorts).has(port)) {
        throw new Error("Cannot use more than one PDFWorker per port.");
      }
      __privateGet(_PDFWorker, _workerPorts).set(port, this);
      __privateMethod(this, _initializeFromPort, initializeFromPort_fn).call(this, port);
    } else {
      __privateMethod(this, _initialize, initialize_fn).call(this);
    }
  }
  get promise() {
    return __privateGet(this, _capability3).promise;
  }
  get port() {
    return __privateGet(this, _port2);
  }
  get messageHandler() {
    return __privateGet(this, _messageHandler);
  }
  destroy() {
    var _a3, _b2;
    this.destroyed = true;
    (_a3 = __privateGet(this, _webWorker)) == null ? void 0 : _a3.terminate();
    __privateSet(this, _webWorker, null);
    __privateGet(_PDFWorker, _workerPorts).delete(__privateGet(this, _port2));
    __privateSet(this, _port2, null);
    (_b2 = __privateGet(this, _messageHandler)) == null ? void 0 : _b2.destroy();
    __privateSet(this, _messageHandler, null);
  }
  static create(params) {
    const cachedPort = __privateGet(this, _workerPorts).get(params == null ? void 0 : params.port);
    if (cachedPort) {
      if (cachedPort._pendingDestroy) {
        throw new Error("PDFWorker.create - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      }
      return cachedPort;
    }
    return new _PDFWorker(params);
  }
  static get workerSrc() {
    if (GlobalWorkerOptions.workerSrc) {
      return GlobalWorkerOptions.workerSrc;
    }
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _setupFakeWorkerGlobal() {
    const loader = async () => {
      if (__privateGet(this, _mainThreadWorkerMessageHandler, mainThreadWorkerMessageHandler_get)) {
        return __privateGet(this, _mainThreadWorkerMessageHandler, mainThreadWorkerMessageHandler_get);
      }
      const worker = await import(
        /*webpackIgnore: true*/
        /*@vite-ignore*/
        this.workerSrc
      );
      return worker.WorkerMessageHandler;
    };
    return shadow(this, "_setupFakeWorkerGlobal", loader());
  }
};
_capability3 = new WeakMap();
_messageHandler = new WeakMap();
_port2 = new WeakMap();
_webWorker = new WeakMap();
_fakeWorkerId = new WeakMap();
_isWorkerDisabled = new WeakMap();
_workerPorts = new WeakMap();
_resolve = new WeakSet();
resolve_fn = function() {
  __privateGet(this, _capability3).resolve();
  __privateGet(this, _messageHandler).send("configure", {
    verbosity: this.verbosity
  });
};
_initializeFromPort = new WeakSet();
initializeFromPort_fn = function(port) {
  __privateSet(this, _port2, port);
  __privateSet(this, _messageHandler, new MessageHandler("main", "worker", port));
  __privateGet(this, _messageHandler).on("ready", () => {
  });
  __privateMethod(this, _resolve, resolve_fn).call(this);
};
_initialize = new WeakSet();
initialize_fn = function() {
  if (__privateGet(_PDFWorker, _isWorkerDisabled) || __privateGet(_PDFWorker, _mainThreadWorkerMessageHandler, mainThreadWorkerMessageHandler_get)) {
    __privateMethod(this, _setupFakeWorker, setupFakeWorker_fn).call(this);
    return;
  }
  let {
    workerSrc
  } = _PDFWorker;
  try {
    if (!_PDFWorker._isSameOrigin(window.location, workerSrc)) {
      workerSrc = _PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);
    }
    const worker = new Worker(workerSrc, {
      type: "module"
    });
    const messageHandler = new MessageHandler("main", "worker", worker);
    const terminateEarly = () => {
      ac.abort();
      messageHandler.destroy();
      worker.terminate();
      if (this.destroyed) {
        __privateGet(this, _capability3).reject(new Error("Worker was destroyed"));
      } else {
        __privateMethod(this, _setupFakeWorker, setupFakeWorker_fn).call(this);
      }
    };
    const ac = new AbortController();
    worker.addEventListener("error", () => {
      if (!__privateGet(this, _webWorker)) {
        terminateEarly();
      }
    }, {
      signal: ac.signal
    });
    messageHandler.on("test", (data) => {
      ac.abort();
      if (this.destroyed || !data) {
        terminateEarly();
        return;
      }
      __privateSet(this, _messageHandler, messageHandler);
      __privateSet(this, _port2, worker);
      __privateSet(this, _webWorker, worker);
      __privateMethod(this, _resolve, resolve_fn).call(this);
    });
    messageHandler.on("ready", (data) => {
      ac.abort();
      if (this.destroyed) {
        terminateEarly();
        return;
      }
      try {
        sendTest();
      } catch (e) {
        __privateMethod(this, _setupFakeWorker, setupFakeWorker_fn).call(this);
      }
    });
    const sendTest = () => {
      const testObj = new Uint8Array();
      messageHandler.send("test", testObj, [testObj.buffer]);
    };
    sendTest();
    return;
  } catch (e) {
    info("The worker has been disabled.");
  }
  __privateMethod(this, _setupFakeWorker, setupFakeWorker_fn).call(this);
};
_setupFakeWorker = new WeakSet();
setupFakeWorker_fn = function() {
  if (!__privateGet(_PDFWorker, _isWorkerDisabled)) {
    warn("Setting up fake worker.");
    __privateSet(_PDFWorker, _isWorkerDisabled, true);
  }
  _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
    if (this.destroyed) {
      __privateGet(this, _capability3).reject(new Error("Worker was destroyed"));
      return;
    }
    const port = new LoopbackPort();
    __privateSet(this, _port2, port);
    const id = `fake${__privateWrapper(_PDFWorker, _fakeWorkerId)._++}`;
    const workerHandler = new MessageHandler(id + "_worker", id, port);
    WorkerMessageHandler.setup(workerHandler, port);
    __privateSet(this, _messageHandler, new MessageHandler(id, id + "_worker", port));
    __privateMethod(this, _resolve, resolve_fn).call(this);
  }).catch((reason) => {
    __privateGet(this, _capability3).reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
  });
};
_mainThreadWorkerMessageHandler = new WeakSet();
mainThreadWorkerMessageHandler_get = function() {
  var _a3;
  try {
    return ((_a3 = globalThis.pdfjsWorker) == null ? void 0 : _a3.WorkerMessageHandler) || null;
  } catch (e) {
    return null;
  }
};
__privateAdd(_PDFWorker, _mainThreadWorkerMessageHandler);
__privateAdd(_PDFWorker, _fakeWorkerId, 0);
__privateAdd(_PDFWorker, _isWorkerDisabled, false);
__privateAdd(_PDFWorker, _workerPorts, /* @__PURE__ */ new WeakMap());
(() => {
  if (isNodeJS) {
    __privateSet(_PDFWorker, _isWorkerDisabled, true);
    GlobalWorkerOptions.workerSrc || (GlobalWorkerOptions.workerSrc = "./pdf.worker.mjs");
  }
  _PDFWorker._isSameOrigin = (baseUrl, otherUrl) => {
    const base = URL.parse(baseUrl);
    if (!(base == null ? void 0 : base.origin) || base.origin === "null") {
      return false;
    }
    const other = new URL(otherUrl, base);
    return base.origin === other.origin;
  };
  _PDFWorker._createCDNWrapper = (url) => {
    const wrapper = `await import("${url}");`;
    return URL.createObjectURL(new Blob([wrapper], {
      type: "text/javascript"
    }));
  };
  _PDFWorker.fromPort = (params) => {
    deprecated("`PDFWorker.fromPort` - please use `PDFWorker.create` instead.");
    if (!(params == null ? void 0 : params.port)) {
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    }
    return _PDFWorker.create(params);
  };
})();
var PDFWorker = _PDFWorker;
var _methodPromises, _pageCache, _pagePromises, _pageRefCache, _passwordCapability, _cacheSimpleMethod, cacheSimpleMethod_fn;
var WorkerTransport = class {
  constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA) {
    __privateAdd(this, _cacheSimpleMethod);
    __privateAdd(this, _methodPromises, /* @__PURE__ */ new Map());
    __privateAdd(this, _pageCache, /* @__PURE__ */ new Map());
    __privateAdd(this, _pagePromises, /* @__PURE__ */ new Map());
    __privateAdd(this, _pageRefCache, /* @__PURE__ */ new Map());
    __privateAdd(this, _passwordCapability, null);
    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new FontLoader({
      ownerDocument: params.ownerDocument,
      styleElement: params.styleElement
    });
    this.loadingParams = params.loadingParams;
    this._params = params;
    this.canvasFactory = factory.canvasFactory;
    this.filterFactory = factory.filterFactory;
    this.cMapReaderFactory = factory.cMapReaderFactory;
    this.standardFontDataFactory = factory.standardFontDataFactory;
    this.wasmFactory = factory.wasmFactory;
    this.destroyed = false;
    this.destroyCapability = null;
    this._networkStream = networkStream;
    this._fullReader = null;
    this._lastProgress = null;
    this.downloadInfoCapability = Promise.withResolvers();
    this.enableHWA = enableHWA;
    this.setupMessageHandler();
  }
  get annotationStorage() {
    return shadow(this, "annotationStorage", new AnnotationStorage());
  }
  getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {
    let renderingIntent = RenderingIntentFlag.DISPLAY;
    let annotationStorageSerializable = SerializableEmpty;
    switch (intent) {
      case "any":
        renderingIntent = RenderingIntentFlag.ANY;
        break;
      case "display":
        break;
      case "print":
        renderingIntent = RenderingIntentFlag.PRINT;
        break;
      default:
        warn(`getRenderingIntent - invalid intent: ${intent}`);
    }
    const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
    switch (annotationMode) {
      case AnnotationMode.DISABLE:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;
        break;
      case AnnotationMode.ENABLE:
        break;
      case AnnotationMode.ENABLE_FORMS:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;
        break;
      case AnnotationMode.ENABLE_STORAGE:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;
        annotationStorageSerializable = annotationStorage.serializable;
        break;
      default:
        warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
    }
    if (isEditing) {
      renderingIntent += RenderingIntentFlag.IS_EDITING;
    }
    if (isOpList) {
      renderingIntent += RenderingIntentFlag.OPLIST;
    }
    const {
      ids: modifiedIds,
      hash: modifiedIdsHash
    } = annotationStorage.modifiedIds;
    const cacheKeyBuf = [renderingIntent, annotationStorageSerializable.hash, modifiedIdsHash];
    return {
      renderingIntent,
      cacheKey: cacheKeyBuf.join("_"),
      annotationStorageSerializable,
      modifiedIds
    };
  }
  destroy() {
    var _a3;
    if (this.destroyCapability) {
      return this.destroyCapability.promise;
    }
    this.destroyed = true;
    this.destroyCapability = Promise.withResolvers();
    (_a3 = __privateGet(this, _passwordCapability)) == null ? void 0 : _a3.reject(new Error("Worker was destroyed during onPassword callback"));
    const waitOn = [];
    for (const page of __privateGet(this, _pageCache).values()) {
      waitOn.push(page._destroy());
    }
    __privateGet(this, _pageCache).clear();
    __privateGet(this, _pagePromises).clear();
    __privateGet(this, _pageRefCache).clear();
    if (this.hasOwnProperty("annotationStorage")) {
      this.annotationStorage.resetModified();
    }
    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
    waitOn.push(terminated);
    Promise.all(waitOn).then(() => {
      var _a4, _b2;
      this.commonObjs.clear();
      this.fontLoader.clear();
      __privateGet(this, _methodPromises).clear();
      this.filterFactory.destroy();
      TextLayer.cleanup();
      (_a4 = this._networkStream) == null ? void 0 : _a4.cancelAllRequests(new AbortException("Worker was terminated."));
      (_b2 = this.messageHandler) == null ? void 0 : _b2.destroy();
      this.messageHandler = null;
      this.destroyCapability.resolve();
    }, this.destroyCapability.reject);
    return this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler,
      loadingTask
    } = this;
    messageHandler.on("GetReader", (data, sink) => {
      assert(this._networkStream, "GetReader - no `IPDFStream` instance available.");
      this._fullReader = this._networkStream.getFullReader();
      this._fullReader.onProgress = (evt) => {
        this._lastProgress = {
          loaded: evt.loaded,
          total: evt.total
        };
      };
      sink.onPull = () => {
        this._fullReader.read().then(function({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          assert(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch((reason) => {
          sink.error(reason);
        });
      };
      sink.onCancel = (reason) => {
        this._fullReader.cancel(reason);
        sink.ready.catch((readyReason) => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("ReaderHeadersReady", async (data) => {
      var _a3;
      await this._fullReader.headersReady;
      const {
        isStreamingSupported,
        isRangeSupported,
        contentLength
      } = this._fullReader;
      if (!isStreamingSupported || !isRangeSupported) {
        if (this._lastProgress) {
          (_a3 = loadingTask.onProgress) == null ? void 0 : _a3.call(loadingTask, this._lastProgress);
        }
        this._fullReader.onProgress = (evt) => {
          var _a4;
          (_a4 = loadingTask.onProgress) == null ? void 0 : _a4.call(loadingTask, {
            loaded: evt.loaded,
            total: evt.total
          });
        };
      }
      return {
        isStreamingSupported,
        isRangeSupported,
        contentLength
      };
    });
    messageHandler.on("GetRangeReader", (data, sink) => {
      assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
      if (!rangeReader) {
        sink.close();
        return;
      }
      sink.onPull = () => {
        rangeReader.read().then(function({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          assert(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch((reason) => {
          sink.error(reason);
        });
      };
      sink.onCancel = (reason) => {
        rangeReader.cancel(reason);
        sink.ready.catch((readyReason) => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("GetDoc", ({
      pdfInfo
    }) => {
      this._numPages = pdfInfo.numPages;
      this._htmlForXfa = pdfInfo.htmlForXfa;
      delete pdfInfo.htmlForXfa;
      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
    });
    messageHandler.on("DocException", (ex) => {
      loadingTask._capability.reject(wrapReason(ex));
    });
    messageHandler.on("PasswordRequest", (ex) => {
      __privateSet(this, _passwordCapability, Promise.withResolvers());
      try {
        if (!loadingTask.onPassword) {
          throw wrapReason(ex);
        }
        const updatePassword = (password) => {
          if (password instanceof Error) {
            __privateGet(this, _passwordCapability).reject(password);
          } else {
            __privateGet(this, _passwordCapability).resolve({
              password
            });
          }
        };
        loadingTask.onPassword(updatePassword, ex.code);
      } catch (err3) {
        __privateGet(this, _passwordCapability).reject(err3);
      }
      return __privateGet(this, _passwordCapability).promise;
    });
    messageHandler.on("DataLoaded", (data) => {
      var _a3;
      (_a3 = loadingTask.onProgress) == null ? void 0 : _a3.call(loadingTask, {
        loaded: data.length,
        total: data.length
      });
      this.downloadInfoCapability.resolve(data);
    });
    messageHandler.on("StartRenderPage", (data) => {
      if (this.destroyed) {
        return;
      }
      const page = __privateGet(this, _pageCache).get(data.pageIndex);
      page._startRenderPage(data.transparency, data.cacheKey);
    });
    messageHandler.on("commonobj", ([id, type, exportedData]) => {
      var _a3;
      if (this.destroyed) {
        return null;
      }
      if (this.commonObjs.has(id)) {
        return null;
      }
      switch (type) {
        case "Font":
          if ("error" in exportedData) {
            const exportedError = exportedData.error;
            warn(`Error during font loading: ${exportedError}`);
            this.commonObjs.resolve(id, exportedError);
            break;
          }
          const inspectFont = this._params.pdfBug && ((_a3 = globalThis.FontInspector) == null ? void 0 : _a3.enabled) ? (font2, url) => globalThis.FontInspector.fontAdded(font2, url) : null;
          const font = new FontFaceObject(exportedData, inspectFont);
          this.fontLoader.bind(font).catch(() => messageHandler.sendWithPromise("FontFallback", {
            id
          })).finally(() => {
            if (!font.fontExtraProperties && font.data) {
              font.data = null;
            }
            this.commonObjs.resolve(id, font);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef
          } = exportedData;
          assert(imageRef, "The imageRef must be defined.");
          for (const pageProxy of __privateGet(this, _pageCache).values()) {
            for (const [, data] of pageProxy.objs) {
              if ((data == null ? void 0 : data.ref) !== imageRef) {
                continue;
              }
              if (!data.dataLen) {
                return null;
              }
              this.commonObjs.resolve(id, structuredClone(data));
              return data.dataLen;
            }
          }
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(id, exportedData);
          break;
        default:
          throw new Error(`Got unknown common object type ${type}`);
      }
      return null;
    });
    messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
      var _a3;
      if (this.destroyed) {
        return;
      }
      const pageProxy = __privateGet(this, _pageCache).get(pageIndex);
      if (pageProxy.objs.has(id)) {
        return;
      }
      if (pageProxy._intentStates.size === 0) {
        (_a3 = imageData == null ? void 0 : imageData.bitmap) == null ? void 0 : _a3.close();
        return;
      }
      switch (type) {
        case "Image":
        case "Pattern":
          pageProxy.objs.resolve(id, imageData);
          break;
        default:
          throw new Error(`Got unknown object type ${type}`);
      }
    });
    messageHandler.on("DocProgress", (data) => {
      var _a3;
      if (this.destroyed) {
        return;
      }
      (_a3 = loadingTask.onProgress) == null ? void 0 : _a3.call(loadingTask, {
        loaded: data.loaded,
        total: data.total
      });
    });
    messageHandler.on("FetchBinaryData", async (data) => {
      if (this.destroyed) {
        throw new Error("Worker was destroyed.");
      }
      const factory = this[data.type];
      if (!factory) {
        throw new Error(`${data.type} not initialized, see the \`useWorkerFetch\` parameter.`);
      }
      return factory.fetch(data);
    });
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    var _a3, _b2;
    if (this.annotationStorage.size <= 0) {
      warn("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    }
    const {
      map,
      transfer
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: map,
      filename: (_b2 = (_a3 = this._fullReader) == null ? void 0 : _a3.filename) != null ? _b2 : null
    }, transfer).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(pageNumber) {
    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
      return Promise.reject(new Error("Invalid page request."));
    }
    const pageIndex = pageNumber - 1, cachedPromise = __privateGet(this, _pagePromises).get(pageIndex);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex
    }).then((pageInfo) => {
      if (this.destroyed) {
        throw new Error("Transport destroyed");
      }
      if (pageInfo.refStr) {
        __privateGet(this, _pageRefCache).set(pageInfo.refStr, pageNumber);
      }
      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
      __privateGet(this, _pageCache).set(pageIndex, page);
      return page;
    });
    __privateGet(this, _pagePromises).set(pageIndex, promise);
    return promise;
  }
  getPageIndex(ref) {
    if (!isRefProxy(ref)) {
      return Promise.reject(new Error("Invalid pageIndex request."));
    }
    return this.messageHandler.sendWithPromise("GetPageIndex", {
      num: ref.num,
      gen: ref.gen
    });
  }
  getAnnotations(pageIndex, intent) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex,
      intent
    });
  }
  getFieldObjects() {
    return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "GetFieldObjects");
  }
  hasJSActions() {
    return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(id) {
    if (typeof id !== "string") {
      return Promise.reject(new Error("Invalid destination request."));
    }
    return this.messageHandler.sendWithPromise("GetDestination", {
      id
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getAnnotationsByType(types, pageIndexesToSkip) {
    return this.messageHandler.sendWithPromise("GetAnnotationsByType", {
      types,
      pageIndexesToSkip
    });
  }
  getDocJSActions() {
    return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "GetDocJSActions");
  }
  getPageJSActions(pageIndex) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex
    });
  }
  getStructTree(pageIndex) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(renderingIntent) {
    return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "GetOptionalContentConfig").then((data) => new OptionalContentConfig(data, renderingIntent));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const name = "GetMetadata", cachedPromise = __privateGet(this, _methodPromises).get(name);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise(name, null).then((results) => {
      var _a3, _b2, _c, _d;
      return {
        info: results[0],
        metadata: results[1] ? new Metadata(results[1]) : null,
        contentDispositionFilename: (_b2 = (_a3 = this._fullReader) == null ? void 0 : _a3.filename) != null ? _b2 : null,
        contentLength: (_d = (_c = this._fullReader) == null ? void 0 : _c.contentLength) != null ? _d : null
      };
    });
    __privateGet(this, _methodPromises).set(name, promise);
    return promise;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(keepLoadedFonts = false) {
    if (this.destroyed) {
      return;
    }
    await this.messageHandler.sendWithPromise("Cleanup", null);
    for (const page of __privateGet(this, _pageCache).values()) {
      const cleanupSuccessful = page.cleanup();
      if (!cleanupSuccessful) {
        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
      }
    }
    this.commonObjs.clear();
    if (!keepLoadedFonts) {
      this.fontLoader.clear();
    }
    __privateGet(this, _methodPromises).clear();
    this.filterFactory.destroy(true);
    TextLayer.cleanup();
  }
  cachedPageNumber(ref) {
    var _a3;
    if (!isRefProxy(ref)) {
      return null;
    }
    const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;
    return (_a3 = __privateGet(this, _pageRefCache).get(refStr)) != null ? _a3 : null;
  }
};
_methodPromises = new WeakMap();
_pageCache = new WeakMap();
_pagePromises = new WeakMap();
_pageRefCache = new WeakMap();
_passwordCapability = new WeakMap();
_cacheSimpleMethod = new WeakSet();
cacheSimpleMethod_fn = function(name, data = null) {
  const cachedPromise = __privateGet(this, _methodPromises).get(name);
  if (cachedPromise) {
    return cachedPromise;
  }
  const promise = this.messageHandler.sendWithPromise(name, data);
  __privateGet(this, _methodPromises).set(name, promise);
  return promise;
};
var _internalRenderTask;
var RenderTask = class {
  constructor(internalRenderTask) {
    __privateAdd(this, _internalRenderTask, null);
    __publicField(this, "onContinue", null);
    __publicField(this, "onError", null);
    __privateSet(this, _internalRenderTask, internalRenderTask);
  }
  get promise() {
    return __privateGet(this, _internalRenderTask).capability.promise;
  }
  cancel(extraDelay = 0) {
    __privateGet(this, _internalRenderTask).cancel(null, extraDelay);
  }
  get separateAnnots() {
    const {
      separateAnnots
    } = __privateGet(this, _internalRenderTask).operatorList;
    if (!separateAnnots) {
      return false;
    }
    const {
      annotationCanvasMap
    } = __privateGet(this, _internalRenderTask);
    return separateAnnots.form || separateAnnots.canvas && (annotationCanvasMap == null ? void 0 : annotationCanvasMap.size) > 0;
  }
};
_internalRenderTask = new WeakMap();
var _rAF, _canvasInUse;
var _InternalRenderTask = class _InternalRenderTask {
  constructor({
    callback,
    params,
    objs,
    commonObjs,
    annotationCanvasMap,
    operatorList,
    pageIndex,
    canvasFactory,
    filterFactory,
    useRequestAnimationFrame = false,
    pdfBug = false,
    pageColors = null,
    enableHWA = false,
    filteredOperationIndexes = null
  }) {
    __privateAdd(this, _rAF, null);
    this.callback = callback;
    this.params = params;
    this.objs = objs;
    this.commonObjs = commonObjs;
    this.annotationCanvasMap = annotationCanvasMap;
    this.operatorListIdx = null;
    this.operatorList = operatorList;
    this._pageIndex = pageIndex;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this._pdfBug = pdfBug;
    this.pageColors = pageColors;
    this.running = false;
    this.graphicsReadyCallback = null;
    this.graphicsReady = false;
    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
    this.cancelled = false;
    this.capability = Promise.withResolvers();
    this.task = new RenderTask(this);
    this._cancelBound = this.cancel.bind(this);
    this._continueBound = this._continue.bind(this);
    this._scheduleNextBound = this._scheduleNext.bind(this);
    this._nextBound = this._next.bind(this);
    this._canvas = params.canvas;
    this._canvasContext = params.canvas ? null : params.canvasContext;
    this._enableHWA = enableHWA;
    this._dependencyTracker = params.dependencyTracker;
    this._filteredOperationIndexes = filteredOperationIndexes;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({
    transparency = false,
    optionalContentConfig
  }) {
    var _a3, _b2;
    if (this.cancelled) {
      return;
    }
    if (this._canvas) {
      if (__privateGet(_InternalRenderTask, _canvasInUse).has(this._canvas)) {
        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      }
      __privateGet(_InternalRenderTask, _canvasInUse).add(this._canvas);
    }
    if (this._pdfBug && ((_a3 = globalThis.StepperManager) == null ? void 0 : _a3.enabled)) {
      this.stepper = globalThis.StepperManager.create(this._pageIndex);
      this.stepper.init(this.operatorList);
      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
    }
    const {
      viewport,
      transform,
      background: background2,
      dependencyTracker
    } = this.params;
    const canvasContext = this._canvasContext || this._canvas.getContext("2d", {
      alpha: false,
      willReadFrequently: !this._enableHWA
    });
    this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig
    }, this.annotationCanvasMap, this.pageColors, dependencyTracker);
    this.gfx.beginDrawing({
      transform,
      viewport,
      transparency,
      background: background2
    });
    this.operatorListIdx = 0;
    this.graphicsReady = true;
    (_b2 = this.graphicsReadyCallback) == null ? void 0 : _b2.call(this);
  }
  cancel(error = null, extraDelay = 0) {
    var _a3, _b2, _c;
    this.running = false;
    this.cancelled = true;
    (_a3 = this.gfx) == null ? void 0 : _a3.endDrawing();
    if (__privateGet(this, _rAF)) {
      window.cancelAnimationFrame(__privateGet(this, _rAF));
      __privateSet(this, _rAF, null);
    }
    __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
    error || (error = new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));
    this.callback(error);
    (_c = (_b2 = this.task).onError) == null ? void 0 : _c.call(_b2, error);
  }
  operatorListChanged() {
    var _a3;
    if (!this.graphicsReady) {
      this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
      return;
    }
    (_a3 = this.stepper) == null ? void 0 : _a3.updateOperatorList(this.operatorList);
    if (this.running) {
      return;
    }
    this._continue();
  }
  _continue() {
    this.running = true;
    if (this.cancelled) {
      return;
    }
    if (this.task.onContinue) {
      this.task.onContinue(this._scheduleNextBound);
    } else {
      this._scheduleNext();
    }
  }
  _scheduleNext() {
    if (this._useRequestAnimationFrame) {
      __privateSet(this, _rAF, window.requestAnimationFrame(() => {
        __privateSet(this, _rAF, null);
        this._nextBound().catch(this._cancelBound);
      }));
    } else {
      Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
  }
  async _next() {
    if (this.cancelled) {
      return;
    }
    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._filteredOperationIndexes);
    if (this.operatorListIdx === this.operatorList.argsArray.length) {
      this.running = false;
      if (this.operatorList.lastChunk) {
        this.gfx.endDrawing();
        __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
        this.callback();
      }
    }
  }
};
_rAF = new WeakMap();
_canvasInUse = new WeakMap();
__privateAdd(_InternalRenderTask, _canvasInUse, /* @__PURE__ */ new WeakSet());
var InternalRenderTask = _InternalRenderTask;
var version = "5.4.149";
var build = "9e2e9e209";
var _button, _buttonSwatch, _defaultColor, _dropdown, _dropdownWasFromKeyboard, _isMainColorPicker, _editor4, _eventBus, _openDropdownAC, _uiManager2, _l10nColor, _getDropdownRoot, getDropdownRoot_fn, _colorSelect, colorSelect_fn, _keyDown, keyDown_fn, _openDropdown, openDropdown_fn, _pointerDown2, pointerDown_fn2, _isDropdownVisible, isDropdownVisible_get;
var _ColorPicker = class _ColorPicker {
  constructor({
    editor = null,
    uiManager = null
  }) {
    __privateAdd(this, _getDropdownRoot);
    __privateAdd(this, _colorSelect);
    __privateAdd(this, _keyDown);
    __privateAdd(this, _openDropdown);
    __privateAdd(this, _pointerDown2);
    __privateAdd(this, _isDropdownVisible);
    __privateAdd(this, _button, null);
    __privateAdd(this, _buttonSwatch, null);
    __privateAdd(this, _defaultColor, void 0);
    __privateAdd(this, _dropdown, null);
    __privateAdd(this, _dropdownWasFromKeyboard, false);
    __privateAdd(this, _isMainColorPicker, false);
    __privateAdd(this, _editor4, null);
    __privateAdd(this, _eventBus, void 0);
    __privateAdd(this, _openDropdownAC, null);
    __privateAdd(this, _uiManager2, null);
    var _a3, _b2;
    if (editor) {
      __privateSet(this, _isMainColorPicker, false);
      __privateSet(this, _editor4, editor);
    } else {
      __privateSet(this, _isMainColorPicker, true);
    }
    __privateSet(this, _uiManager2, (editor == null ? void 0 : editor._uiManager) || uiManager);
    __privateSet(this, _eventBus, __privateGet(this, _uiManager2)._eventBus);
    __privateSet(this, _defaultColor, ((_a3 = editor == null ? void 0 : editor.color) == null ? void 0 : _a3.toUpperCase()) || ((_b2 = __privateGet(this, _uiManager2)) == null ? void 0 : _b2.highlightColors.values().next().value) || "#FFFF98");
    __privateGet(_ColorPicker, _l10nColor) || __privateSet(_ColorPicker, _l10nColor, Object.freeze({
      blue: "pdfjs-editor-colorpicker-blue",
      green: "pdfjs-editor-colorpicker-green",
      pink: "pdfjs-editor-colorpicker-pink",
      red: "pdfjs-editor-colorpicker-red",
      yellow: "pdfjs-editor-colorpicker-yellow"
    }));
  }
  static get _keyboardManager() {
    return shadow(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], _ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], _ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], _ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], _ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], _ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], _ColorPicker.prototype._moveToEnd]]));
  }
  renderButton() {
    const button = __privateSet(this, _button, document.createElement("button"));
    button.className = "colorPicker";
    button.tabIndex = "0";
    button.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
    button.ariaHasPopup = "true";
    if (__privateGet(this, _editor4)) {
      button.ariaControls = `${__privateGet(this, _editor4).id}_colorpicker_dropdown`;
    }
    const signal = __privateGet(this, _uiManager2)._signal;
    button.addEventListener("click", __privateMethod(this, _openDropdown, openDropdown_fn).bind(this), {
      signal
    });
    button.addEventListener("keydown", __privateMethod(this, _keyDown, keyDown_fn).bind(this), {
      signal
    });
    const swatch = __privateSet(this, _buttonSwatch, document.createElement("span"));
    swatch.className = "swatch";
    swatch.ariaHidden = "true";
    swatch.style.backgroundColor = __privateGet(this, _defaultColor);
    button.append(swatch);
    return button;
  }
  renderMainDropdown() {
    const dropdown = __privateSet(this, _dropdown, __privateMethod(this, _getDropdownRoot, getDropdownRoot_fn).call(this));
    dropdown.ariaOrientation = "horizontal";
    dropdown.ariaLabelledBy = "highlightColorPickerLabel";
    return dropdown;
  }
  _colorSelectFromKeyboard(event) {
    if (event.target === __privateGet(this, _button)) {
      __privateMethod(this, _openDropdown, openDropdown_fn).call(this, event);
      return;
    }
    const color = event.target.getAttribute("data-color");
    if (!color) {
      return;
    }
    __privateMethod(this, _colorSelect, colorSelect_fn).call(this, color, event);
  }
  _moveToNext(event) {
    var _a3, _b2;
    if (!__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
      __privateMethod(this, _openDropdown, openDropdown_fn).call(this, event);
      return;
    }
    if (event.target === __privateGet(this, _button)) {
      (_a3 = __privateGet(this, _dropdown).firstChild) == null ? void 0 : _a3.focus();
      return;
    }
    (_b2 = event.target.nextSibling) == null ? void 0 : _b2.focus();
  }
  _moveToPrevious(event) {
    var _a3, _b2;
    if (event.target === ((_a3 = __privateGet(this, _dropdown)) == null ? void 0 : _a3.firstChild) || event.target === __privateGet(this, _button)) {
      if (__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
        this._hideDropdownFromKeyboard();
      }
      return;
    }
    if (!__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
      __privateMethod(this, _openDropdown, openDropdown_fn).call(this, event);
    }
    (_b2 = event.target.previousSibling) == null ? void 0 : _b2.focus();
  }
  _moveToBeginning(event) {
    var _a3;
    if (!__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
      __privateMethod(this, _openDropdown, openDropdown_fn).call(this, event);
      return;
    }
    (_a3 = __privateGet(this, _dropdown).firstChild) == null ? void 0 : _a3.focus();
  }
  _moveToEnd(event) {
    var _a3;
    if (!__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
      __privateMethod(this, _openDropdown, openDropdown_fn).call(this, event);
      return;
    }
    (_a3 = __privateGet(this, _dropdown).lastChild) == null ? void 0 : _a3.focus();
  }
  hideDropdown() {
    var _a3, _b2;
    (_a3 = __privateGet(this, _dropdown)) == null ? void 0 : _a3.classList.add("hidden");
    __privateGet(this, _button).ariaExpanded = "false";
    (_b2 = __privateGet(this, _openDropdownAC)) == null ? void 0 : _b2.abort();
    __privateSet(this, _openDropdownAC, null);
  }
  _hideDropdownFromKeyboard() {
    var _a3;
    if (__privateGet(this, _isMainColorPicker)) {
      return;
    }
    if (!__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
      (_a3 = __privateGet(this, _editor4)) == null ? void 0 : _a3.unselect();
      return;
    }
    this.hideDropdown();
    __privateGet(this, _button).focus({
      preventScroll: true,
      focusVisible: __privateGet(this, _dropdownWasFromKeyboard)
    });
  }
  updateColor(color) {
    if (__privateGet(this, _buttonSwatch)) {
      __privateGet(this, _buttonSwatch).style.backgroundColor = color;
    }
    if (!__privateGet(this, _dropdown)) {
      return;
    }
    const i = __privateGet(this, _uiManager2).highlightColors.values();
    for (const child of __privateGet(this, _dropdown).children) {
      child.ariaSelected = i.next().value === color.toUpperCase();
    }
  }
  destroy() {
    var _a3, _b2;
    (_a3 = __privateGet(this, _button)) == null ? void 0 : _a3.remove();
    __privateSet(this, _button, null);
    __privateSet(this, _buttonSwatch, null);
    (_b2 = __privateGet(this, _dropdown)) == null ? void 0 : _b2.remove();
    __privateSet(this, _dropdown, null);
  }
};
_button = new WeakMap();
_buttonSwatch = new WeakMap();
_defaultColor = new WeakMap();
_dropdown = new WeakMap();
_dropdownWasFromKeyboard = new WeakMap();
_isMainColorPicker = new WeakMap();
_editor4 = new WeakMap();
_eventBus = new WeakMap();
_openDropdownAC = new WeakMap();
_uiManager2 = new WeakMap();
_l10nColor = new WeakMap();
_getDropdownRoot = new WeakSet();
getDropdownRoot_fn = function() {
  const div = document.createElement("div");
  const signal = __privateGet(this, _uiManager2)._signal;
  div.addEventListener("contextmenu", noContextMenu, {
    signal
  });
  div.className = "dropdown";
  div.role = "listbox";
  div.ariaMultiSelectable = "false";
  div.ariaOrientation = "vertical";
  div.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
  if (__privateGet(this, _editor4)) {
    div.id = `${__privateGet(this, _editor4).id}_colorpicker_dropdown`;
  }
  for (const [name, color] of __privateGet(this, _uiManager2).highlightColors) {
    const button = document.createElement("button");
    button.tabIndex = "0";
    button.role = "option";
    button.setAttribute("data-color", color);
    button.title = name;
    button.setAttribute("data-l10n-id", __privateGet(_ColorPicker, _l10nColor)[name]);
    const swatch = document.createElement("span");
    button.append(swatch);
    swatch.className = "swatch";
    swatch.style.backgroundColor = color;
    button.ariaSelected = color === __privateGet(this, _defaultColor);
    button.addEventListener("click", __privateMethod(this, _colorSelect, colorSelect_fn).bind(this, color), {
      signal
    });
    div.append(button);
  }
  div.addEventListener("keydown", __privateMethod(this, _keyDown, keyDown_fn).bind(this), {
    signal
  });
  return div;
};
_colorSelect = new WeakSet();
colorSelect_fn = function(color, event) {
  event.stopPropagation();
  __privateGet(this, _eventBus).dispatch("switchannotationeditorparams", {
    source: this,
    type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
    value: color
  });
  this.updateColor(color);
};
_keyDown = new WeakSet();
keyDown_fn = function(event) {
  _ColorPicker._keyboardManager.exec(this, event);
};
_openDropdown = new WeakSet();
openDropdown_fn = function(event) {
  if (__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
    this.hideDropdown();
    return;
  }
  __privateSet(this, _dropdownWasFromKeyboard, event.detail === 0);
  if (!__privateGet(this, _openDropdownAC)) {
    __privateSet(this, _openDropdownAC, new AbortController());
    window.addEventListener("pointerdown", __privateMethod(this, _pointerDown2, pointerDown_fn2).bind(this), {
      signal: __privateGet(this, _uiManager2).combinedSignal(__privateGet(this, _openDropdownAC))
    });
  }
  __privateGet(this, _button).ariaExpanded = "true";
  if (__privateGet(this, _dropdown)) {
    __privateGet(this, _dropdown).classList.remove("hidden");
    return;
  }
  const root = __privateSet(this, _dropdown, __privateMethod(this, _getDropdownRoot, getDropdownRoot_fn).call(this));
  __privateGet(this, _button).append(root);
};
_pointerDown2 = new WeakSet();
pointerDown_fn2 = function(event) {
  var _a3;
  if ((_a3 = __privateGet(this, _dropdown)) == null ? void 0 : _a3.contains(event.target)) {
    return;
  }
  this.hideDropdown();
};
_isDropdownVisible = new WeakSet();
isDropdownVisible_get = function() {
  return __privateGet(this, _dropdown) && !__privateGet(this, _dropdown).classList.contains("hidden");
};
__privateAdd(_ColorPicker, _l10nColor, null);
var ColorPicker = _ColorPicker;
var _input, _editor5, _uiManager3, _l10nColor2;
var _BasicColorPicker = class _BasicColorPicker {
  constructor(editor) {
    __privateAdd(this, _input, null);
    __privateAdd(this, _editor5, null);
    __privateAdd(this, _uiManager3, null);
    __privateSet(this, _editor5, editor);
    __privateSet(this, _uiManager3, editor._uiManager);
    __privateGet(_BasicColorPicker, _l10nColor2) || __privateSet(_BasicColorPicker, _l10nColor2, Object.freeze({
      freetext: "pdfjs-editor-color-picker-free-text-input",
      ink: "pdfjs-editor-color-picker-ink-input"
    }));
  }
  renderButton() {
    if (__privateGet(this, _input)) {
      return __privateGet(this, _input);
    }
    const {
      editorType,
      colorType,
      colorValue
    } = __privateGet(this, _editor5);
    const input = __privateSet(this, _input, document.createElement("input"));
    input.type = "color";
    input.value = colorValue || "#000000";
    input.className = "basicColorPicker";
    input.tabIndex = 0;
    input.setAttribute("data-l10n-id", __privateGet(_BasicColorPicker, _l10nColor2)[editorType]);
    input.addEventListener("input", () => {
      __privateGet(this, _uiManager3).updateParams(colorType, input.value);
    }, {
      signal: __privateGet(this, _uiManager3)._signal
    });
    return input;
  }
  update(value) {
    if (!__privateGet(this, _input)) {
      return;
    }
    __privateGet(this, _input).value = value;
  }
  destroy() {
    var _a3;
    (_a3 = __privateGet(this, _input)) == null ? void 0 : _a3.remove();
    __privateSet(this, _input, null);
  }
  hideDropdown() {
  }
};
_input = new WeakMap();
_editor5 = new WeakMap();
_uiManager3 = new WeakMap();
_l10nColor2 = new WeakMap();
__privateAdd(_BasicColorPicker, _l10nColor2, null);
var BasicColorPicker = _BasicColorPicker;
function makeColorComp(n) {
  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
}
function scaleAndClamp(x) {
  return Math.max(0, Math.min(255, 255 * x));
}
var ColorConverters = class {
  static CMYK_G([c, y, m, k]) {
    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
  }
  static G_CMYK([g]) {
    return ["CMYK", 0, 0, 0, 1 - g];
  }
  static G_RGB([g]) {
    return ["RGB", g, g, g];
  }
  static G_rgb([g]) {
    g = scaleAndClamp(g);
    return [g, g, g];
  }
  static G_HTML([g]) {
    const G = makeColorComp(g);
    return `#${G}${G}${G}`;
  }
  static RGB_G([r, g, b]) {
    return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
  }
  static RGB_rgb(color) {
    return color.map(scaleAndClamp);
  }
  static RGB_HTML(color) {
    return `#${color.map(makeColorComp).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([c, y, m, k]) {
    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
  }
  static CMYK_rgb([c, y, m, k]) {
    return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];
  }
  static CMYK_HTML(components) {
    const rgb = this.CMYK_RGB(components).slice(1);
    return this.RGB_HTML(rgb);
  }
  static RGB_CMYK([r, g, b]) {
    const c = 1 - r;
    const m = 1 - g;
    const y = 1 - b;
    const k = Math.min(c, m, y);
    return ["CMYK", c, m, y, k];
  }
};
var BaseSVGFactory = class {
  create(width, height, skipDimensions = false) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid SVG dimensions");
    }
    const svg = this._createSVG("svg:svg");
    svg.setAttribute("version", "1.1");
    if (!skipDimensions) {
      svg.setAttribute("width", `${width}px`);
      svg.setAttribute("height", `${height}px`);
    }
    svg.setAttribute("preserveAspectRatio", "none");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    return svg;
  }
  createElement(type) {
    if (typeof type !== "string") {
      throw new Error("Invalid SVG element type");
    }
    return this._createSVG(type);
  }
  _createSVG(type) {
    unreachable("Abstract method `_createSVG` called.");
  }
};
var DOMSVGFactory = class extends BaseSVGFactory {
  _createSVG(type) {
    return document.createElementNS(SVG_NS, type);
  }
};
var XfaLayer = class {
  static setupStorage(html, id, element, storage, intent) {
    const storedData = storage.getValue(id, {
      value: null
    });
    switch (element.name) {
      case "textarea":
        if (storedData.value !== null) {
          html.textContent = storedData.value;
        }
        if (intent === "print") {
          break;
        }
        html.addEventListener("input", (event) => {
          storage.setValue(id, {
            value: event.target.value
          });
        });
        break;
      case "input":
        if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
          if (storedData.value === element.attributes.xfaOn) {
            html.setAttribute("checked", true);
          } else if (storedData.value === element.attributes.xfaOff) {
            html.removeAttribute("checked");
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("change", (event) => {
            storage.setValue(id, {
              value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (storedData.value !== null) {
            html.setAttribute("value", storedData.value);
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("input", (event) => {
            storage.setValue(id, {
              value: event.target.value
            });
          });
        }
        break;
      case "select":
        if (storedData.value !== null) {
          html.setAttribute("value", storedData.value);
          for (const option of element.children) {
            if (option.attributes.value === storedData.value) {
              option.attributes.selected = true;
            } else if (option.attributes.hasOwnProperty("selected")) {
              delete option.attributes.selected;
            }
          }
        }
        html.addEventListener("input", (event) => {
          const options = event.target.options;
          const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
          storage.setValue(id, {
            value
          });
        });
        break;
    }
  }
  static setAttributes({
    html,
    element,
    storage = null,
    intent,
    linkService
  }) {
    const {
      attributes
    } = element;
    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
    if (attributes.type === "radio") {
      attributes.name = `${attributes.name}-${intent}`;
    }
    for (const [key, value] of Object.entries(attributes)) {
      if (value === null || value === void 0) {
        continue;
      }
      switch (key) {
        case "class":
          if (value.length) {
            html.setAttribute(key, value.join(" "));
          }
          break;
        case "dataId":
          break;
        case "id":
          html.setAttribute("data-element-id", value);
          break;
        case "style":
          Object.assign(html.style, value);
          break;
        case "textContent":
          html.textContent = value;
          break;
        default:
          if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
            html.setAttribute(key, value);
          }
      }
    }
    if (isHTMLAnchorElement) {
      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
    }
    if (storage && attributes.dataId) {
      this.setupStorage(html, attributes.dataId, element, storage);
    }
  }
  static render(parameters) {
    var _a3, _b2;
    const storage = parameters.annotationStorage;
    const linkService = parameters.linkService;
    const root = parameters.xfaHtml;
    const intent = parameters.intent || "display";
    const rootHtml = document.createElement(root.name);
    if (root.attributes) {
      this.setAttributes({
        html: rootHtml,
        element: root,
        intent,
        linkService
      });
    }
    const isNotForRichText = intent !== "richText";
    const rootDiv = parameters.div;
    rootDiv.append(rootHtml);
    if (parameters.viewport) {
      const transform = `matrix(${parameters.viewport.transform.join(",")})`;
      rootDiv.style.transform = transform;
    }
    if (isNotForRichText) {
      rootDiv.setAttribute("class", "xfaLayer xfaFont");
    }
    const textDivs = [];
    if (root.children.length === 0) {
      if (root.value) {
        const node = document.createTextNode(root.value);
        rootHtml.append(node);
        if (isNotForRichText && XfaText.shouldBuildText(root.name)) {
          textDivs.push(node);
        }
      }
      return {
        textDivs
      };
    }
    const stack = [[root, -1, rootHtml]];
    while (stack.length > 0) {
      const [parent, i, html] = stack.at(-1);
      if (i + 1 === parent.children.length) {
        stack.pop();
        continue;
      }
      const child = parent.children[++stack.at(-1)[1]];
      if (child === null) {
        continue;
      }
      const {
        name
      } = child;
      if (name === "#text") {
        const node = document.createTextNode(child.value);
        textDivs.push(node);
        html.append(node);
        continue;
      }
      const childHtml = ((_a3 = child == null ? void 0 : child.attributes) == null ? void 0 : _a3.xmlns) ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
      html.append(childHtml);
      if (child.attributes) {
        this.setAttributes({
          html: childHtml,
          element: child,
          storage,
          intent,
          linkService
        });
      }
      if (((_b2 = child.children) == null ? void 0 : _b2.length) > 0) {
        stack.push([child, -1, childHtml]);
      } else if (child.value) {
        const node = document.createTextNode(child.value);
        if (isNotForRichText && XfaText.shouldBuildText(name)) {
          textDivs.push(node);
        }
        childHtml.append(node);
      }
    }
    for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
      el.setAttribute("readOnly", true);
    }
    return {
      textDivs
    };
  }
  static update(parameters) {
    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
    parameters.div.style.transform = transform;
    parameters.div.hidden = false;
  }
};
var annotation_layer_DEFAULT_FONT_SIZE = 9;
var GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
var TIMEZONE_OFFSET = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 60 * 1e3;
var AnnotationElementFactory = class {
  static create(parameters) {
    const subtype = parameters.data.annotationType;
    switch (subtype) {
      case AnnotationType.LINK:
        return new LinkAnnotationElement(parameters);
      case AnnotationType.TEXT:
        return new TextAnnotationElement(parameters);
      case AnnotationType.WIDGET:
        const fieldType = parameters.data.fieldType;
        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(parameters);
          case "Btn":
            if (parameters.data.radioButton) {
              return new RadioButtonWidgetAnnotationElement(parameters);
            } else if (parameters.data.checkBox) {
              return new CheckboxWidgetAnnotationElement(parameters);
            }
            return new PushButtonWidgetAnnotationElement(parameters);
          case "Ch":
            return new ChoiceWidgetAnnotationElement(parameters);
          case "Sig":
            return new SignatureWidgetAnnotationElement(parameters);
        }
        return new WidgetAnnotationElement(parameters);
      case AnnotationType.POPUP:
        return new PopupAnnotationElement(parameters);
      case AnnotationType.FREETEXT:
        return new FreeTextAnnotationElement(parameters);
      case AnnotationType.LINE:
        return new LineAnnotationElement(parameters);
      case AnnotationType.SQUARE:
        return new SquareAnnotationElement(parameters);
      case AnnotationType.CIRCLE:
        return new CircleAnnotationElement(parameters);
      case AnnotationType.POLYLINE:
        return new PolylineAnnotationElement(parameters);
      case AnnotationType.CARET:
        return new CaretAnnotationElement(parameters);
      case AnnotationType.INK:
        return new InkAnnotationElement(parameters);
      case AnnotationType.POLYGON:
        return new PolygonAnnotationElement(parameters);
      case AnnotationType.HIGHLIGHT:
        return new HighlightAnnotationElement(parameters);
      case AnnotationType.UNDERLINE:
        return new UnderlineAnnotationElement(parameters);
      case AnnotationType.SQUIGGLY:
        return new SquigglyAnnotationElement(parameters);
      case AnnotationType.STRIKEOUT:
        return new StrikeOutAnnotationElement(parameters);
      case AnnotationType.STAMP:
        return new StampAnnotationElement(parameters);
      case AnnotationType.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(parameters);
      default:
        return new AnnotationElement(parameters);
    }
  }
};
var _updates, _hasBorder, _popupElement, _changeLightness, changeLightness_fn, _setRectEdited, setRectEdited_fn;
var _AnnotationElement = class _AnnotationElement {
  constructor(parameters, {
    isRenderable = false,
    ignoreBorder = false,
    createQuadrilaterals = false
  } = {}) {
    __privateAdd(this, _changeLightness);
    __privateAdd(this, _setRectEdited);
    __privateAdd(this, _updates, null);
    __privateAdd(this, _hasBorder, false);
    __privateAdd(this, _popupElement, null);
    this.isRenderable = isRenderable;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderForms = parameters.renderForms;
    this.svgFactory = parameters.svgFactory;
    this.annotationStorage = parameters.annotationStorage;
    this.enableComment = parameters.enableComment;
    this.enableScripting = parameters.enableScripting;
    this.hasJSActions = parameters.hasJSActions;
    this._fieldObjects = parameters.fieldObjects;
    this.parent = parameters.parent;
    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }
    if (createQuadrilaterals) {
      this._createQuadrilaterals();
    }
  }
  static _hasPopupData({
    contentsObj,
    richText
  }) {
    return !!((contentsObj == null ? void 0 : contentsObj.str) || (richText == null ? void 0 : richText.str));
  }
  get _isEditable() {
    return this.data.isEditable;
  }
  get hasPopupData() {
    return _AnnotationElement._hasPopupData(this.data);
  }
  get hasCommentButton() {
    return this.enableComment && this._isEditable && this.hasPopupElement;
  }
  get commentButtonPosition() {
    const {
      quadPoints,
      rect
    } = this.data;
    let maxX = -Infinity;
    let maxY = -Infinity;
    if ((quadPoints == null ? void 0 : quadPoints.length) >= 8) {
      for (let i = 0; i < quadPoints.length; i += 8) {
        if (quadPoints[i + 1] > maxY) {
          maxY = quadPoints[i + 1];
          maxX = quadPoints[i + 2];
        } else if (quadPoints[i + 1] === maxY) {
          maxX = Math.max(maxX, quadPoints[i + 2]);
        }
      }
      return [maxX, maxY];
    }
    if (rect) {
      return [rect[2], rect[3]];
    }
    return null;
  }
  get commentButtonColor() {
    var _a3;
    if (!this.data.color) {
      return null;
    }
    const [r, g, b] = this.data.color;
    const opacity = (_a3 = this.data.opacity) != null ? _a3 : 1;
    const oppositeOpacity = 255 * (1 - opacity);
    return __privateMethod(this, _changeLightness, changeLightness_fn).call(this, Math.min(r + oppositeOpacity, 255), Math.min(g + oppositeOpacity, 255), Math.min(b + oppositeOpacity, 255));
  }
  _normalizePoint(point) {
    const {
      page: {
        view
      },
      viewport: {
        rawDims: {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        }
      }
    } = this.parent;
    point[1] = view[3] - point[1] + view[1];
    point[0] = 100 * (point[0] - pageX) / pageWidth;
    point[1] = 100 * (point[1] - pageY) / pageHeight;
    return point;
  }
  updateEdited(params) {
    var _a3;
    if (!this.container) {
      return;
    }
    if (params.rect) {
      __privateGet(this, _updates) || __privateSet(this, _updates, {
        rect: this.data.rect.slice(0)
      });
    }
    const {
      rect,
      popup: newPopup
    } = params;
    if (rect) {
      __privateMethod(this, _setRectEdited, setRectEdited_fn).call(this, rect);
    }
    let popup = ((_a3 = __privateGet(this, _popupElement)) == null ? void 0 : _a3.popup) || this.popup;
    if (!popup && (newPopup == null ? void 0 : newPopup.text)) {
      this._createPopup(newPopup);
      popup = __privateGet(this, _popupElement).popup;
    }
    if (!popup) {
      return;
    }
    popup.updateEdited(params);
    if (newPopup == null ? void 0 : newPopup.deleted) {
      popup.remove();
      __privateSet(this, _popupElement, null);
      this.popup = null;
    }
  }
  resetEdited() {
    var _a3;
    if (!__privateGet(this, _updates)) {
      return;
    }
    __privateMethod(this, _setRectEdited, setRectEdited_fn).call(this, __privateGet(this, _updates).rect);
    (_a3 = __privateGet(this, _popupElement)) == null ? void 0 : _a3.popup.resetEdited();
    __privateSet(this, _updates, null);
  }
  _createContainer(ignoreBorder) {
    const {
      data,
      parent: {
        page,
        viewport
      }
    } = this;
    const container = document.createElement("section");
    container.setAttribute("data-annotation-id", data.id);
    if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {
      container.tabIndex = 0;
    }
    const {
      style
    } = container;
    style.zIndex = this.parent.zIndex;
    this.parent.zIndex += 2;
    if (data.alternativeText) {
      container.title = data.alternativeText;
    }
    if (data.noRotate) {
      container.classList.add("norotate");
    }
    if (!data.rect || this instanceof PopupAnnotationElement) {
      const {
        rotation: rotation2
      } = data;
      if (!data.hasOwnCanvas && rotation2 !== 0) {
        this.setRotation(rotation2, container);
      }
      return container;
    }
    const {
      width,
      height
    } = this;
    if (!ignoreBorder && data.borderStyle.width > 0) {
      style.borderWidth = `${data.borderStyle.width}px`;
      const horizontalRadius = data.borderStyle.horizontalCornerRadius;
      const verticalRadius = data.borderStyle.verticalCornerRadius;
      if (horizontalRadius > 0 || verticalRadius > 0) {
        const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;
        style.borderRadius = radius;
      } else if (this instanceof RadioButtonWidgetAnnotationElement) {
        const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;
        style.borderRadius = radius;
      }
      switch (data.borderStyle.style) {
        case AnnotationBorderStyleType.SOLID:
          style.borderStyle = "solid";
          break;
        case AnnotationBorderStyleType.DASHED:
          style.borderStyle = "dashed";
          break;
        case AnnotationBorderStyleType.BEVELED:
          warn("Unimplemented border style: beveled");
          break;
        case AnnotationBorderStyleType.INSET:
          warn("Unimplemented border style: inset");
          break;
        case AnnotationBorderStyleType.UNDERLINE:
          style.borderBottomStyle = "solid";
          break;
        default:
          break;
      }
      const borderColor = data.borderColor || null;
      if (borderColor) {
        __privateSet(this, _hasBorder, true);
        style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
      } else {
        style.borderWidth = 0;
      }
    }
    const rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
    style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
    const {
      rotation
    } = data;
    if (data.hasOwnCanvas || rotation === 0) {
      style.width = `${100 * width / pageWidth}%`;
      style.height = `${100 * height / pageHeight}%`;
    } else {
      this.setRotation(rotation, container);
    }
    return container;
  }
  setRotation(angle, container = this.container) {
    if (!this.data.rect) {
      return;
    }
    const {
      pageWidth,
      pageHeight
    } = this.parent.viewport.rawDims;
    let {
      width,
      height
    } = this;
    if (angle % 180 !== 0) {
      [width, height] = [height, width];
    }
    container.style.width = `${100 * width / pageWidth}%`;
    container.style.height = `${100 * height / pageHeight}%`;
    container.setAttribute("data-main-rotation", (360 - angle) % 360);
  }
  get _commonActions() {
    const setColor = (jsName, styleName, event) => {
      const color = event.detail[jsName];
      const colorType = color[0];
      const colorArray = color.slice(1);
      event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);
      this.annotationStorage.setValue(this.data.id, {
        [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)
      });
    };
    return shadow(this, "_commonActions", {
      display: (event) => {
        const {
          display
        } = event.detail;
        const hidden = display % 2 === 1;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noView: hidden,
          noPrint: display === 1 || display === 2
        });
      },
      print: (event) => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !event.detail.print
        });
      },
      hidden: (event) => {
        const {
          hidden
        } = event.detail;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noPrint: hidden,
          noView: hidden
        });
      },
      focus: (event) => {
        setTimeout(() => event.target.focus({
          preventScroll: false
        }), 0);
      },
      userName: (event) => {
        event.target.title = event.detail.userName;
      },
      readonly: (event) => {
        event.target.disabled = event.detail.readonly;
      },
      required: (event) => {
        this._setRequired(event.target, event.detail.required);
      },
      bgColor: (event) => {
        setColor("bgColor", "backgroundColor", event);
      },
      fillColor: (event) => {
        setColor("fillColor", "backgroundColor", event);
      },
      fgColor: (event) => {
        setColor("fgColor", "color", event);
      },
      textColor: (event) => {
        setColor("textColor", "color", event);
      },
      borderColor: (event) => {
        setColor("borderColor", "borderColor", event);
      },
      strokeColor: (event) => {
        setColor("strokeColor", "borderColor", event);
      },
      rotation: (event) => {
        const angle = event.detail.rotation;
        this.setRotation(angle);
        this.annotationStorage.setValue(this.data.id, {
          rotation: angle
        });
      }
    });
  }
  _dispatchEventFromSandbox(actions, jsEvent) {
    const commonActions = this._commonActions;
    for (const name of Object.keys(jsEvent.detail)) {
      const action = actions[name] || commonActions[name];
      action == null ? void 0 : action(jsEvent);
    }
  }
  _setDefaultPropertiesFromJS(element) {
    if (!this.enableScripting) {
      return;
    }
    const storedData = this.annotationStorage.getRawValue(this.data.id);
    if (!storedData) {
      return;
    }
    const commonActions = this._commonActions;
    for (const [actionName, detail] of Object.entries(storedData)) {
      const action = commonActions[actionName];
      if (action) {
        const eventProxy = {
          detail: {
            [actionName]: detail
          },
          target: element
        };
        action(eventProxy);
        delete storedData[actionName];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container) {
      return;
    }
    const {
      quadPoints
    } = this.data;
    if (!quadPoints) {
      return;
    }
    const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x) => Math.fround(x));
    if (quadPoints.length === 8) {
      const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);
      if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
        return;
      }
    }
    const {
      style
    } = this.container;
    let svgBuffer;
    if (__privateGet(this, _hasBorder)) {
      const {
        borderColor,
        borderWidth
      } = style;
      style.borderWidth = 0;
      svgBuffer = ["url('data:image/svg+xml;utf8,", `<svg xmlns="http://www.w3.org/2000/svg"`, ` preserveAspectRatio="none" viewBox="0 0 1 1">`, `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`];
      this.container.classList.add("hasBorder");
    }
    const width = rectTrX - rectBlX;
    const height = rectTrY - rectBlY;
    const {
      svgFactory
    } = this;
    const svg = svgFactory.createElement("svg");
    svg.classList.add("quadrilateralsContainer");
    svg.setAttribute("width", 0);
    svg.setAttribute("height", 0);
    svg.role = "none";
    const defs = svgFactory.createElement("defs");
    svg.append(defs);
    const clipPath = svgFactory.createElement("clipPath");
    const id = `clippath_${this.data.id}`;
    clipPath.setAttribute("id", id);
    clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
    defs.append(clipPath);
    for (let i = 2, ii = quadPoints.length; i < ii; i += 8) {
      const trX = quadPoints[i];
      const trY = quadPoints[i + 1];
      const blX = quadPoints[i + 2];
      const blY = quadPoints[i + 3];
      const rect = svgFactory.createElement("rect");
      const x = (blX - rectBlX) / width;
      const y = (rectTrY - trY) / height;
      const rectWidth = (trX - blX) / width;
      const rectHeight = (trY - blY) / height;
      rect.setAttribute("x", x);
      rect.setAttribute("y", y);
      rect.setAttribute("width", rectWidth);
      rect.setAttribute("height", rectHeight);
      clipPath.append(rect);
      svgBuffer == null ? void 0 : svgBuffer.push(`<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`);
    }
    if (__privateGet(this, _hasBorder)) {
      svgBuffer.push(`</g></svg>')`);
      style.backgroundImage = svgBuffer.join("");
    }
    this.container.append(svg);
    this.container.style.clipPath = `url(#${id})`;
  }
  _createPopup(popupData = null) {
    const {
      data
    } = this;
    let contentsObj, modificationDate;
    if (popupData) {
      contentsObj = {
        str: popupData.text
      };
      modificationDate = popupData.date;
    } else {
      contentsObj = data.contentsObj;
      modificationDate = data.modificationDate;
    }
    const popup = __privateSet(this, _popupElement, new PopupAnnotationElement({
      data: {
        color: data.color,
        titleObj: data.titleObj,
        modificationDate,
        contentsObj,
        richText: data.richText,
        parentRect: data.rect,
        borderStyle: 0,
        id: `popup_${data.id}`,
        rotation: data.rotation,
        noRotate: true
      },
      linkService: this.linkService,
      parent: this.parent,
      elements: [this]
    }));
    this.parent.div.append(popup.render());
  }
  get hasPopupElement() {
    return !!(__privateGet(this, _popupElement) || this.popup || this.data.popupRef);
  }
  render() {
    unreachable("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(name, skipId = null) {
    const fields = [];
    if (this._fieldObjects) {
      const fieldObj = this._fieldObjects[name];
      if (fieldObj) {
        for (const {
          page,
          id,
          exportValues
        } of fieldObj) {
          if (page === -1) {
            continue;
          }
          if (id === skipId) {
            continue;
          }
          const exportValue = typeof exportValues === "string" ? exportValues : null;
          const domElement = document.querySelector(`[data-element-id="${id}"]`);
          if (domElement && !GetElementsByNameSet.has(domElement)) {
            warn(`_getElementsByName - element not allowed: ${id}`);
            continue;
          }
          fields.push({
            id,
            exportValue,
            domElement
          });
        }
      }
      return fields;
    }
    for (const domElement of document.getElementsByName(name)) {
      const {
        exportValue
      } = domElement;
      const id = domElement.getAttribute("data-element-id");
      if (id === skipId) {
        continue;
      }
      if (!GetElementsByNameSet.has(domElement)) {
        continue;
      }
      fields.push({
        id,
        exportValue,
        domElement
      });
    }
    return fields;
  }
  show() {
    var _a3;
    if (this.container) {
      this.container.hidden = false;
    }
    (_a3 = this.popup) == null ? void 0 : _a3.maybeShow();
  }
  hide() {
    var _a3;
    if (this.container) {
      this.container.hidden = true;
    }
    (_a3 = this.popup) == null ? void 0 : _a3.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const triggers = this.getElementsToTriggerPopup();
    if (Array.isArray(triggers)) {
      for (const element of triggers) {
        element.classList.add("highlightArea");
      }
    } else {
      triggers.classList.add("highlightArea");
    }
  }
  _editOnDoubleClick() {
    if (!this._isEditable) {
      return;
    }
    const {
      annotationEditorType: mode,
      data: {
        id: editId
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      var _a3;
      (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("switchannotationeditormode", {
        source: this,
        mode,
        editId,
        mustEnterInEditMode: true
      });
    });
  }
  get width() {
    return this.data.rect[2] - this.data.rect[0];
  }
  get height() {
    return this.data.rect[3] - this.data.rect[1];
  }
};
_updates = new WeakMap();
_hasBorder = new WeakMap();
_popupElement = new WeakMap();
_changeLightness = new WeakSet();
changeLightness_fn = function(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max2 = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max2 + min) / 2;
  const newL = ((1 + Math.sqrt(l)) / 2 * 100).toFixed(2);
  if (max2 === min) {
    return `hsl(0, 0%, ${newL}%)`;
  }
  const d = max2 - min;
  let h;
  if (max2 === r) {
    h = (g - b) / d + (g < b ? 6 : 0);
  } else if (max2 === g) {
    h = (b - r) / d + 2;
  } else {
    h = (r - g) / d + 4;
  }
  h = (h * 60).toFixed(2);
  const s = (d / (1 - Math.abs(2 * l - 1)) * 100).toFixed(2);
  return `hsl(${h}, ${s}%, ${newL}%)`;
};
_setRectEdited = new WeakSet();
setRectEdited_fn = function(rect) {
  const {
    container: {
      style
    },
    data: {
      rect: currentRect,
      rotation
    },
    parent: {
      viewport: {
        rawDims: {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        }
      }
    }
  } = this;
  currentRect == null ? void 0 : currentRect.splice(0, 4, ...rect);
  style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
  style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;
  if (rotation === 0) {
    style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;
    style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;
  } else {
    this.setRotation(rotation);
  }
};
var AnnotationElement = _AnnotationElement;
var _setInternalLink, setInternalLink_fn, _bindAttachment, bindAttachment_fn, _bindSetOCGState, bindSetOCGState_fn;
var LinkAnnotationElement = class extends AnnotationElement {
  constructor(parameters, options = null) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: !!(options == null ? void 0 : options.ignoreBorder),
      createQuadrilaterals: true
    });
    __privateAdd(this, _setInternalLink);
    __privateAdd(this, _bindAttachment);
    __privateAdd(this, _bindSetOCGState);
    this.isTooltipOnly = parameters.data.isTooltipOnly;
  }
  render() {
    const {
      data,
      linkService
    } = this;
    const link = document.createElement("a");
    link.setAttribute("data-element-id", data.id);
    let isBound = false;
    if (data.url) {
      linkService.addLinkAttributes(link, data.url, data.newWindow);
      isBound = true;
    } else if (data.action) {
      this._bindNamedAction(link, data.action, data.overlaidText);
      isBound = true;
    } else if (data.attachment) {
      __privateMethod(this, _bindAttachment, bindAttachment_fn).call(this, link, data.attachment, data.overlaidText, data.attachmentDest);
      isBound = true;
    } else if (data.setOCGState) {
      __privateMethod(this, _bindSetOCGState, bindSetOCGState_fn).call(this, link, data.setOCGState, data.overlaidText);
      isBound = true;
    } else if (data.dest) {
      this._bindLink(link, data.dest, data.overlaidText);
      isBound = true;
    } else {
      if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
        this._bindJSAction(link, data);
        isBound = true;
      }
      if (data.resetForm) {
        this._bindResetFormAction(link, data.resetForm);
        isBound = true;
      } else if (this.isTooltipOnly && !isBound) {
        this._bindLink(link, "");
        isBound = true;
      }
    }
    this.container.classList.add("linkAnnotation");
    if (isBound) {
      this.container.append(link);
    }
    return this.container;
  }
  _bindLink(link, destination, overlaidText = "") {
    link.href = this.linkService.getDestinationHash(destination);
    link.onclick = () => {
      if (destination) {
        this.linkService.goToDestination(destination);
      }
      return false;
    };
    if (destination || destination === "") {
      __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
    }
    if (overlaidText) {
      link.title = overlaidText;
    }
  }
  _bindNamedAction(link, action, overlaidText = "") {
    link.href = this.linkService.getAnchorUrl("");
    link.onclick = () => {
      this.linkService.executeNamedAction(action);
      return false;
    };
    if (overlaidText) {
      link.title = overlaidText;
    }
    __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
  }
  _bindJSAction(link, data) {
    link.href = this.linkService.getAnchorUrl("");
    const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const name of Object.keys(data.actions)) {
      const jsName = map.get(name);
      if (!jsName) {
        continue;
      }
      link[jsName] = () => {
        var _a3;
        (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: data.id,
            name
          }
        });
        return false;
      };
    }
    if (data.overlaidText) {
      link.title = data.overlaidText;
    }
    if (!link.onclick) {
      link.onclick = () => false;
    }
    __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
  }
  _bindResetFormAction(link, resetForm) {
    const otherClickAction = link.onclick;
    if (!otherClickAction) {
      link.href = this.linkService.getAnchorUrl("");
    }
    __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
    if (!this._fieldObjects) {
      warn(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
      if (!otherClickAction) {
        link.onclick = () => false;
      }
      return;
    }
    link.onclick = () => {
      var _a3;
      otherClickAction == null ? void 0 : otherClickAction();
      const {
        fields: resetFormFields,
        refs: resetFormRefs,
        include
      } = resetForm;
      const allFields = [];
      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
        const fieldIds = new Set(resetFormRefs);
        for (const fieldName of resetFormFields) {
          const fields = this._fieldObjects[fieldName] || [];
          for (const {
            id
          } of fields) {
            fieldIds.add(id);
          }
        }
        for (const fields of Object.values(this._fieldObjects)) {
          for (const field of fields) {
            if (fieldIds.has(field.id) === include) {
              allFields.push(field);
            }
          }
        }
      } else {
        for (const fields of Object.values(this._fieldObjects)) {
          allFields.push(...fields);
        }
      }
      const storage = this.annotationStorage;
      const allIds = [];
      for (const field of allFields) {
        const {
          id
        } = field;
        allIds.push(id);
        switch (field.type) {
          case "text": {
            const value = field.defaultValue || "";
            storage.setValue(id, {
              value
            });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const value = field.defaultValue === field.exportValues;
            storage.setValue(id, {
              value
            });
            break;
          }
          case "combobox":
          case "listbox": {
            const value = field.defaultValue || "";
            storage.setValue(id, {
              value
            });
            break;
          }
          default:
            continue;
        }
        const domElement = document.querySelector(`[data-element-id="${id}"]`);
        if (!domElement) {
          continue;
        } else if (!GetElementsByNameSet.has(domElement)) {
          warn(`_bindResetFormAction - element not allowed: ${id}`);
          continue;
        }
        domElement.dispatchEvent(new Event("resetform"));
      }
      if (this.enableScripting) {
        (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: "app",
            ids: allIds,
            name: "ResetForm"
          }
        });
      }
      return false;
    };
  }
};
_setInternalLink = new WeakSet();
setInternalLink_fn = function() {
  this.container.setAttribute("data-internal-link", "");
};
_bindAttachment = new WeakSet();
bindAttachment_fn = function(link, attachment, overlaidText = "", dest = null) {
  link.href = this.linkService.getAnchorUrl("");
  if (attachment.description) {
    link.title = attachment.description;
  } else if (overlaidText) {
    link.title = overlaidText;
  }
  link.onclick = () => {
    var _a3;
    (_a3 = this.downloadManager) == null ? void 0 : _a3.openOrDownloadData(attachment.content, attachment.filename, dest);
    return false;
  };
  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
};
_bindSetOCGState = new WeakSet();
bindSetOCGState_fn = function(link, action, overlaidText = "") {
  link.href = this.linkService.getAnchorUrl("");
  link.onclick = () => {
    this.linkService.executeSetOCGState(action);
    return false;
  };
  if (overlaidText) {
    link.title = overlaidText;
  }
  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
};
var TextAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const image = document.createElement("img");
    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
    image.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
    image.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    }));
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.append(image);
    return this.container;
  }
};
var WidgetAnnotationElement = class extends AnnotationElement {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(element) {
    var _a3;
    if (this.data.hasOwnCanvas) {
      if (((_a3 = element.previousSibling) == null ? void 0 : _a3.nodeName) === "CANVAS") {
        element.previousSibling.hidden = true;
      }
      element.hidden = false;
    }
  }
  _getKeyModifier(event) {
    return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;
  }
  _setEventListener(element, elementData, baseName, eventName, valueGetter) {
    if (baseName.includes("mouse")) {
      element.addEventListener(baseName, (event) => {
        var _a3;
        (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event),
            shift: event.shiftKey,
            modifier: this._getKeyModifier(event)
          }
        });
      });
    } else {
      element.addEventListener(baseName, (event) => {
        var _a3;
        if (baseName === "blur") {
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          elementData.focused = false;
        } else if (baseName === "focus") {
          if (elementData.focused) {
            return;
          }
          elementData.focused = true;
        }
        if (!valueGetter) {
          return;
        }
        (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event)
          }
        });
      });
    }
  }
  _setEventListeners(element, elementData, names, getter) {
    var _a3, _b2, _c;
    for (const [baseName, eventName] of names) {
      if (eventName === "Action" || ((_a3 = this.data.actions) == null ? void 0 : _a3[eventName])) {
        if (eventName === "Focus" || eventName === "Blur") {
          elementData || (elementData = {
            focused: false
          });
        }
        this._setEventListener(element, elementData, baseName, eventName, getter);
        if (eventName === "Focus" && !((_b2 = this.data.actions) == null ? void 0 : _b2.Blur)) {
          this._setEventListener(element, elementData, "blur", "Blur", null);
        } else if (eventName === "Blur" && !((_c = this.data.actions) == null ? void 0 : _c.Focus)) {
          this._setEventListener(element, elementData, "focus", "Focus", null);
        }
      }
    }
  }
  _setBackgroundColor(element) {
    const color = this.data.backgroundColor || null;
    element.style.backgroundColor = color === null ? "transparent" : Util.makeHexColor(color[0], color[1], color[2]);
  }
  _setTextStyle(element) {
    const TEXT_ALIGNMENT = ["left", "center", "right"];
    const {
      fontColor
    } = this.data.defaultAppearanceData;
    const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;
    const style = element.style;
    let computedFontSize;
    const BORDER_SIZE = 2;
    const roundToOneDecimal = (x) => Math.round(10 * x) / 10;
    if (this.data.multiLine) {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
      const lineHeight = height / numberOfLines;
      computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));
    } else {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));
    }
    style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;
    style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
    if (this.data.textAlignment !== null) {
      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
    }
  }
  _setRequired(element, isRequired) {
    if (isRequired) {
      element.setAttribute("required", true);
    } else {
      element.removeAttribute("required");
    }
    element.setAttribute("aria-required", isRequired);
  }
};
var TextWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(parameters) {
    const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    super(parameters, {
      isRenderable
    });
  }
  setPropertyOnSiblings(base, key, value, keyInStorage) {
    const storage = this.annotationStorage;
    for (const element of this._getElementsByName(base.name, base.id)) {
      if (element.domElement) {
        element.domElement[key] = value;
      }
      storage.setValue(element.id, {
        [keyInStorage]: value
      });
    }
  }
  render() {
    var _a3, _b2;
    const storage = this.annotationStorage;
    const id = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let element = null;
    if (this.renderForms) {
      const storedData = storage.getValue(id, {
        value: this.data.fieldValue
      });
      let textContent = storedData.value || "";
      const maxLen = storage.getValue(id, {
        charLimit: this.data.maxLen
      }).charLimit;
      if (maxLen && textContent.length > maxLen) {
        textContent = textContent.slice(0, maxLen);
      }
      let fieldFormattedValues = storedData.formattedValue || ((_a3 = this.data.textContent) == null ? void 0 : _a3.join("\n")) || null;
      if (fieldFormattedValues && this.data.comb) {
        fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
      }
      const elementData = {
        userValue: textContent,
        formattedValue: fieldFormattedValues,
        lastCommittedValue: null,
        commitKey: 1,
        focused: false
      };
      if (this.data.multiLine) {
        element = document.createElement("textarea");
        element.textContent = fieldFormattedValues != null ? fieldFormattedValues : textContent;
        if (this.data.doNotScroll) {
          element.style.overflowY = "hidden";
        }
      } else {
        element = document.createElement("input");
        element.type = this.data.password ? "password" : "text";
        element.setAttribute("value", fieldFormattedValues != null ? fieldFormattedValues : textContent);
        if (this.data.doNotScroll) {
          element.style.overflowX = "hidden";
        }
      }
      if (this.data.hasOwnCanvas) {
        element.hidden = true;
      }
      GetElementsByNameSet.add(element);
      element.setAttribute("data-element-id", id);
      element.disabled = this.data.readOnly;
      element.name = this.data.fieldName;
      element.tabIndex = 0;
      const {
        datetimeFormat,
        datetimeType,
        timeStep
      } = this.data;
      const hasDateOrTime = !!datetimeType && this.enableScripting;
      if (datetimeFormat) {
        element.title = datetimeFormat;
      }
      this._setRequired(element, this.data.required);
      if (maxLen) {
        element.maxLength = maxLen;
      }
      element.addEventListener("input", (event) => {
        storage.setValue(id, {
          value: event.target.value
        });
        this.setPropertyOnSiblings(element, "value", event.target.value, "value");
        elementData.formattedValue = null;
      });
      element.addEventListener("resetform", (event) => {
        var _a4;
        const defaultValue = (_a4 = this.data.defaultFieldValue) != null ? _a4 : "";
        element.value = elementData.userValue = defaultValue;
        elementData.formattedValue = null;
      });
      let blurListener = (event) => {
        const {
          formattedValue
        } = elementData;
        if (formattedValue !== null && formattedValue !== void 0) {
          event.target.value = formattedValue;
        }
        event.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("focus", (event) => {
          var _a4;
          if (elementData.focused) {
            return;
          }
          const {
            target
          } = event;
          if (hasDateOrTime) {
            target.type = datetimeType;
            if (timeStep) {
              target.step = timeStep;
            }
          }
          if (elementData.userValue) {
            const value = elementData.userValue;
            if (hasDateOrTime) {
              if (datetimeType === "time") {
                const date = new Date(value);
                const parts = [date.getHours(), date.getMinutes(), date.getSeconds()];
                target.value = parts.map((v) => v.toString().padStart(2, "0")).join(":");
              } else {
                target.value = new Date(value - TIMEZONE_OFFSET).toISOString().split(datetimeType === "date" ? "T" : ".", 1)[0];
              }
            } else {
              target.value = value;
            }
          }
          elementData.lastCommittedValue = target.value;
          elementData.commitKey = 1;
          if (!((_a4 = this.data.actions) == null ? void 0 : _a4.Focus)) {
            elementData.focused = true;
          }
        });
        element.addEventListener("updatefromsandbox", (jsEvent) => {
          this.showElementAndHideCanvas(jsEvent.target);
          const actions = {
            value(event) {
              var _a4;
              elementData.userValue = (_a4 = event.detail.value) != null ? _a4 : "";
              if (!hasDateOrTime) {
                storage.setValue(id, {
                  value: elementData.userValue.toString()
                });
              }
              event.target.value = elementData.userValue;
            },
            formattedValue(event) {
              const {
                formattedValue
              } = event.detail;
              elementData.formattedValue = formattedValue;
              if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                event.target.value = formattedValue;
              }
              const data = {
                formattedValue
              };
              if (hasDateOrTime) {
                data.value = formattedValue;
              }
              storage.setValue(id, data);
            },
            selRange(event) {
              event.target.setSelectionRange(...event.detail.selRange);
            },
            charLimit: (event) => {
              var _a4;
              const {
                charLimit
              } = event.detail;
              const {
                target
              } = event;
              if (charLimit === 0) {
                target.removeAttribute("maxLength");
                return;
              }
              target.setAttribute("maxLength", charLimit);
              let value = elementData.userValue;
              if (!value || value.length <= charLimit) {
                return;
              }
              value = value.slice(0, charLimit);
              target.value = elementData.userValue = value;
              storage.setValue(id, {
                value
              });
              (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value,
                  willCommit: true,
                  commitKey: 1,
                  selStart: target.selectionStart,
                  selEnd: target.selectionEnd
                }
              });
            }
          };
          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        element.addEventListener("keydown", (event) => {
          var _a4;
          elementData.commitKey = 1;
          let commitKey = -1;
          if (event.key === "Escape") {
            commitKey = 0;
          } else if (event.key === "Enter" && !this.data.multiLine) {
            commitKey = 2;
          } else if (event.key === "Tab") {
            elementData.commitKey = 3;
          }
          if (commitKey === -1) {
            return;
          }
          const {
            value
          } = event.target;
          if (elementData.lastCommittedValue === value) {
            return;
          }
          elementData.lastCommittedValue = value;
          elementData.userValue = value;
          (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id,
              name: "Keystroke",
              value,
              willCommit: true,
              commitKey,
              selStart: event.target.selectionStart,
              selEnd: event.target.selectionEnd
            }
          });
        });
        const _blurListener = blurListener;
        blurListener = null;
        element.addEventListener("blur", (event) => {
          var _a4, _b3;
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          if (!((_a4 = this.data.actions) == null ? void 0 : _a4.Blur)) {
            elementData.focused = false;
          }
          const {
            target
          } = event;
          let {
            value
          } = target;
          if (hasDateOrTime) {
            if (value && datetimeType === "time") {
              const parts = value.split(":").map((v) => parseInt(v, 10));
              value = new Date(2e3, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();
              target.step = "";
            } else {
              value = new Date(value).valueOf();
            }
            target.type = "text";
          }
          elementData.userValue = value;
          if (elementData.lastCommittedValue !== value) {
            (_b3 = this.linkService.eventBus) == null ? void 0 : _b3.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                willCommit: true,
                commitKey: elementData.commitKey,
                selStart: event.target.selectionStart,
                selEnd: event.target.selectionEnd
              }
            });
          }
          _blurListener(event);
        });
        if ((_b2 = this.data.actions) == null ? void 0 : _b2.Keystroke) {
          element.addEventListener("beforeinput", (event) => {
            var _a4;
            elementData.lastCommittedValue = null;
            const {
              data,
              target
            } = event;
            const {
              value,
              selectionStart,
              selectionEnd
            } = target;
            let selStart = selectionStart, selEnd = selectionEnd;
            switch (event.inputType) {
              case "deleteWordBackward": {
                const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                if (match) {
                  selStart -= match[0].length;
                }
                break;
              }
              case "deleteWordForward": {
                const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                if (match) {
                  selEnd += match[0].length;
                }
                break;
              }
              case "deleteContentBackward":
                if (selectionStart === selectionEnd) {
                  selStart -= 1;
                }
                break;
              case "deleteContentForward":
                if (selectionStart === selectionEnd) {
                  selEnd += 1;
                }
                break;
            }
            event.preventDefault();
            (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                change: data || "",
                willCommit: false,
                selStart,
                selEnd
              }
            });
          });
        }
        this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
      }
      if (blurListener) {
        element.addEventListener("blur", blurListener);
      }
      if (this.data.comb) {
        const fieldWidth = this.data.rect[2] - this.data.rect[0];
        const combWidth = fieldWidth / maxLen;
        element.classList.add("comb");
        element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;
      }
    } else {
      element = document.createElement("div");
      element.textContent = this.data.fieldValue;
      element.style.verticalAlign = "middle";
      element.style.display = "table-cell";
      if (this.data.hasOwnCanvas) {
        element.hidden = true;
      }
    }
    this._setTextStyle(element);
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
};
var SignatureWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: !!parameters.data.hasOwnCanvas
    });
  }
};
var CheckboxWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.exportValue === data.fieldValue
    }).value;
    if (typeof value === "string") {
      value = value !== "Off";
      storage.setValue(id, {
        value
      });
    }
    this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "checkbox";
    element.name = data.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.setAttribute("exportValue", data.exportValue);
    element.tabIndex = 0;
    element.addEventListener("change", (event) => {
      const {
        name,
        checked
      } = event.target;
      for (const checkbox of this._getElementsByName(name, id)) {
        const curChecked = checked && checkbox.exportValue === data.exportValue;
        if (checkbox.domElement) {
          checkbox.domElement.checked = curChecked;
        }
        storage.setValue(checkbox.id, {
          value: curChecked
        });
      }
      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", (event) => {
      const defaultValue = data.defaultFieldValue || "Off";
      event.target.checked = defaultValue === data.exportValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      element.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value(event) {
            event.target.checked = event.detail.value !== "Off";
            storage.setValue(id, {
              value: event.target.checked
            });
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
};
var RadioButtonWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.fieldValue === data.buttonValue
    }).value;
    if (typeof value === "string") {
      value = value !== data.buttonValue;
      storage.setValue(id, {
        value
      });
    }
    if (value) {
      for (const radio of this._getElementsByName(data.fieldName, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }
    }
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "radio";
    element.name = data.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.tabIndex = 0;
    element.addEventListener("change", (event) => {
      const {
        name,
        checked
      } = event.target;
      for (const radio of this._getElementsByName(name, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }
      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", (event) => {
      const defaultValue = data.defaultFieldValue;
      event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      const pdfButtonValue = data.buttonValue;
      element.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value: (event) => {
            const checked = pdfButtonValue === event.detail.value;
            for (const radio of this._getElementsByName(event.target.name)) {
              const curChecked = checked && radio.id === id;
              if (radio.domElement) {
                radio.domElement.checked = curChecked;
              }
              storage.setValue(radio.id, {
                value: curChecked
              });
            }
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
};
var PushButtonWidgetAnnotationElement = class extends LinkAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      ignoreBorder: parameters.data.hasAppearance
    });
  }
  render() {
    const container = super.render();
    container.classList.add("buttonWidgetAnnotation", "pushButton");
    const linkElement = container.lastChild;
    if (this.enableScripting && this.hasJSActions && linkElement) {
      this._setDefaultPropertiesFromJS(linkElement);
      linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
        this._dispatchEventFromSandbox({}, jsEvent);
      });
    }
    return container;
  }
};
var ChoiceWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const storage = this.annotationStorage;
    const id = this.data.id;
    const storedData = storage.getValue(id, {
      value: this.data.fieldValue
    });
    const selectElement = document.createElement("select");
    GetElementsByNameSet.add(selectElement);
    selectElement.setAttribute("data-element-id", id);
    selectElement.disabled = this.data.readOnly;
    this._setRequired(selectElement, this.data.required);
    selectElement.name = this.data.fieldName;
    selectElement.tabIndex = 0;
    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
    if (!this.data.combo) {
      selectElement.size = this.data.options.length;
      if (this.data.multiSelect) {
        selectElement.multiple = true;
      }
    }
    selectElement.addEventListener("resetform", (event) => {
      const defaultValue = this.data.defaultFieldValue;
      for (const option of selectElement.options) {
        option.selected = option.value === defaultValue;
      }
    });
    for (const option of this.data.options) {
      const optionElement = document.createElement("option");
      optionElement.textContent = option.displayValue;
      optionElement.value = option.exportValue;
      if (storedData.value.includes(option.exportValue)) {
        optionElement.setAttribute("selected", true);
        addAnEmptyEntry = false;
      }
      selectElement.append(optionElement);
    }
    let removeEmptyEntry = null;
    if (addAnEmptyEntry) {
      const noneOptionElement = document.createElement("option");
      noneOptionElement.value = " ";
      noneOptionElement.setAttribute("hidden", true);
      noneOptionElement.setAttribute("selected", true);
      selectElement.prepend(noneOptionElement);
      removeEmptyEntry = () => {
        noneOptionElement.remove();
        selectElement.removeEventListener("input", removeEmptyEntry);
        removeEmptyEntry = null;
      };
      selectElement.addEventListener("input", removeEmptyEntry);
    }
    const getValue = (isExport) => {
      const name = isExport ? "value" : "textContent";
      const {
        options,
        multiple
      } = selectElement;
      if (!multiple) {
        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
      }
      return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
    };
    let selectedValues = getValue(false);
    const getItems = (event) => {
      const options = event.target.options;
      return Array.prototype.map.call(options, (option) => ({
        displayValue: option.textContent,
        exportValue: option.value
      }));
    };
    if (this.enableScripting && this.hasJSActions) {
      selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value(event) {
            removeEmptyEntry == null ? void 0 : removeEmptyEntry();
            const value = event.detail.value;
            const values = new Set(Array.isArray(value) ? value : [value]);
            for (const option of selectElement.options) {
              option.selected = values.has(option.value);
            }
            storage.setValue(id, {
              value: getValue(true)
            });
            selectedValues = getValue(false);
          },
          multipleSelection(event) {
            selectElement.multiple = true;
          },
          remove(event) {
            const options = selectElement.options;
            const index = event.detail.remove;
            options[index].selected = false;
            selectElement.remove(index);
            if (options.length > 0) {
              const i = Array.prototype.findIndex.call(options, (option) => option.selected);
              if (i === -1) {
                options[0].selected = true;
              }
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          clear(event) {
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            storage.setValue(id, {
              value: null,
              items: []
            });
            selectedValues = getValue(false);
          },
          insert(event) {
            const {
              index,
              displayValue,
              exportValue
            } = event.detail.insert;
            const selectChild = selectElement.children[index];
            const optionElement = document.createElement("option");
            optionElement.textContent = displayValue;
            optionElement.value = exportValue;
            if (selectChild) {
              selectChild.before(optionElement);
            } else {
              selectElement.append(optionElement);
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          items(event) {
            const {
              items
            } = event.detail;
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            for (const item of items) {
              const {
                displayValue,
                exportValue
              } = item;
              const optionElement = document.createElement("option");
              optionElement.textContent = displayValue;
              optionElement.value = exportValue;
              selectElement.append(optionElement);
            }
            if (selectElement.options.length > 0) {
              selectElement.options[0].selected = true;
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          indices(event) {
            const indices = new Set(event.detail.indices);
            for (const option of event.target.options) {
              option.selected = indices.has(option.index);
            }
            storage.setValue(id, {
              value: getValue(true)
            });
            selectedValues = getValue(false);
          },
          editable(event) {
            event.target.disabled = !event.detail.editable;
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      selectElement.addEventListener("input", (event) => {
        var _a3;
        const exportValue = getValue(true);
        const change = getValue(false);
        storage.setValue(id, {
          value: exportValue
        });
        event.preventDefault();
        (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id,
            name: "Keystroke",
            value: selectedValues,
            change,
            changeEx: exportValue,
            willCommit: false,
            commitKey: 1,
            keyDown: false
          }
        });
      });
      this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (event) => event.target.value);
    } else {
      selectElement.addEventListener("input", function(event) {
        storage.setValue(id, {
          value: getValue(true)
        });
      });
    }
    if (this.data.combo) {
      this._setTextStyle(selectElement);
    } else {
    }
    this._setBackgroundColor(selectElement);
    this._setDefaultPropertiesFromJS(selectElement);
    this.container.append(selectElement);
    return this.container;
  }
};
var PopupAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    const {
      data,
      elements
    } = parameters;
    super(parameters, {
      isRenderable: AnnotationElement._hasPopupData(data)
    });
    this.elements = elements;
    this.popup = null;
  }
  render() {
    const {
      container
    } = this;
    container.classList.add("popupAnnotation");
    container.role = "comment";
    const popup = this.popup = new PopupElement({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate || this.data.creationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open,
      eventBus: this.linkService.eventBus
    });
    const elementIds = [];
    for (const element of this.elements) {
      element.popup = popup;
      element.container.ariaHasPopup = "dialog";
      elementIds.push(element.data.id);
      element.addHighlightArea();
    }
    this.container.setAttribute("aria-controls", elementIds.map((id) => `${AnnotationPrefix}${id}`).join(","));
    return this.container;
  }
};
var _boundKeyDown, _boundHide, _boundShow, _boundToggle, _color, _container4, _contentsObj, _dateObj, _elements, _eventBus2, _parent, _parentRect, _pinned, _popup, _popupAbortController, _position2, _commentButton2, _commentButtonPosition, _commentButtonColor, _rect, _richText, _titleObj, _updates2, _wasVisible, _addEventListeners, addEventListeners_fn, _setCommentButtonPosition, setCommentButtonPosition_fn, _renderCommentButton, renderCommentButton_fn, _html, html_get, _fontSize, fontSize_get, _fontColor, fontColor_get, _makePopupContent, makePopupContent_fn, _keyDown2, keyDown_fn2, _setPosition, setPosition_fn, _toggle, toggle_fn, _show, show_fn, _hide, hide_fn;
var PopupElement = class {
  constructor({
    container,
    color,
    elements,
    titleObj,
    modificationDate,
    contentsObj,
    richText,
    parent,
    rect,
    parentRect,
    open,
    eventBus = null
  }) {
    __privateAdd(this, _addEventListeners);
    __privateAdd(this, _setCommentButtonPosition);
    __privateAdd(this, _renderCommentButton);
    __privateAdd(this, _html);
    __privateAdd(this, _fontSize);
    __privateAdd(this, _fontColor);
    __privateAdd(this, _makePopupContent);
    __privateAdd(this, _keyDown2);
    __privateAdd(this, _setPosition);
    __privateAdd(this, _toggle);
    __privateAdd(this, _show);
    __privateAdd(this, _hide);
    __privateAdd(this, _boundKeyDown, __privateMethod(this, _keyDown2, keyDown_fn2).bind(this));
    __privateAdd(this, _boundHide, __privateMethod(this, _hide, hide_fn).bind(this));
    __privateAdd(this, _boundShow, __privateMethod(this, _show, show_fn).bind(this));
    __privateAdd(this, _boundToggle, __privateMethod(this, _toggle, toggle_fn).bind(this));
    __privateAdd(this, _color, null);
    __privateAdd(this, _container4, null);
    __privateAdd(this, _contentsObj, null);
    __privateAdd(this, _dateObj, null);
    __privateAdd(this, _elements, null);
    __privateAdd(this, _eventBus2, null);
    __privateAdd(this, _parent, null);
    __privateAdd(this, _parentRect, null);
    __privateAdd(this, _pinned, false);
    __privateAdd(this, _popup, null);
    __privateAdd(this, _popupAbortController, null);
    __privateAdd(this, _position2, null);
    __privateAdd(this, _commentButton2, null);
    __privateAdd(this, _commentButtonPosition, null);
    __privateAdd(this, _commentButtonColor, null);
    __privateAdd(this, _rect, null);
    __privateAdd(this, _richText, null);
    __privateAdd(this, _titleObj, null);
    __privateAdd(this, _updates2, null);
    __privateAdd(this, _wasVisible, false);
    __privateSet(this, _container4, container);
    __privateSet(this, _titleObj, titleObj);
    __privateSet(this, _contentsObj, contentsObj);
    __privateSet(this, _richText, richText);
    __privateSet(this, _parent, parent);
    __privateSet(this, _color, color);
    __privateSet(this, _rect, rect);
    __privateSet(this, _parentRect, parentRect);
    __privateSet(this, _elements, elements);
    __privateSet(this, _eventBus2, eventBus);
    __privateSet(this, _dateObj, PDFDateString.toDateObject(modificationDate));
    this.trigger = elements.flatMap((e) => e.getElementsToTriggerPopup());
    __privateMethod(this, _addEventListeners, addEventListeners_fn).call(this);
    __privateGet(this, _container4).hidden = true;
    if (open) {
      __privateMethod(this, _toggle, toggle_fn).call(this);
    }
  }
  render() {
    var _a3;
    if (__privateGet(this, _popup)) {
      return;
    }
    const popup = __privateSet(this, _popup, document.createElement("div"));
    popup.className = "popup";
    if (__privateGet(this, _color)) {
      const baseColor = popup.style.outlineColor = Util.makeHexColor(...__privateGet(this, _color));
      popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
    }
    const header = document.createElement("span");
    header.className = "header";
    if ((_a3 = __privateGet(this, _titleObj)) == null ? void 0 : _a3.str) {
      const title = document.createElement("span");
      title.className = "title";
      header.append(title);
      ({
        dir: title.dir,
        str: title.textContent
      } = __privateGet(this, _titleObj));
    }
    popup.append(header);
    if (__privateGet(this, _dateObj)) {
      const modificationDate = document.createElement("time");
      modificationDate.className = "popupDate";
      modificationDate.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string");
      modificationDate.setAttribute("data-l10n-args", JSON.stringify({
        dateObj: __privateGet(this, _dateObj).valueOf()
      }));
      modificationDate.dateTime = __privateGet(this, _dateObj).toISOString();
      header.append(modificationDate);
    }
    const html = __privateGet(this, _html, html_get);
    if (html) {
      XfaLayer.render({
        xfaHtml: html,
        intent: "richText",
        div: popup
      });
      popup.lastChild.classList.add("richText", "popupContent");
    } else {
      const contents = this._formatContents(__privateGet(this, _contentsObj));
      popup.append(contents);
    }
    __privateGet(this, _container4).append(popup);
  }
  _formatContents({
    str,
    dir
  }) {
    const p = document.createElement("p");
    p.classList.add("popupContent");
    p.dir = dir;
    const lines = str.split(/(?:\r\n?|\n)/);
    for (let i = 0, ii = lines.length; i < ii; ++i) {
      const line = lines[i];
      p.append(document.createTextNode(line));
      if (i < ii - 1) {
        p.append(document.createElement("br"));
      }
    }
    return p;
  }
  updateEdited({
    rect,
    popup,
    deleted
  }) {
    var _a3;
    if (deleted || (popup == null ? void 0 : popup.deleted)) {
      this.remove();
      return;
    }
    __privateMethod(this, _addEventListeners, addEventListeners_fn).call(this);
    __privateGet(this, _updates2) || __privateSet(this, _updates2, {
      contentsObj: __privateGet(this, _contentsObj),
      richText: __privateGet(this, _richText)
    });
    if (rect) {
      __privateSet(this, _position2, null);
    }
    if (popup) {
      __privateSet(this, _richText, __privateMethod(this, _makePopupContent, makePopupContent_fn).call(this, popup.text));
      __privateSet(this, _dateObj, PDFDateString.toDateObject(popup.date));
      __privateSet(this, _contentsObj, null);
    }
    (_a3 = __privateGet(this, _popup)) == null ? void 0 : _a3.remove();
    __privateSet(this, _popup, null);
  }
  resetEdited() {
    var _a3;
    if (!__privateGet(this, _updates2)) {
      return;
    }
    ({
      contentsObj: __privateWrapper(this, _contentsObj)._,
      richText: __privateWrapper(this, _richText)._
    } = __privateGet(this, _updates2));
    __privateSet(this, _updates2, null);
    (_a3 = __privateGet(this, _popup)) == null ? void 0 : _a3.remove();
    __privateSet(this, _popup, null);
    __privateSet(this, _position2, null);
  }
  remove() {
    var _a3, _b2;
    (_a3 = __privateGet(this, _popupAbortController)) == null ? void 0 : _a3.abort();
    __privateSet(this, _popupAbortController, null);
    (_b2 = __privateGet(this, _popup)) == null ? void 0 : _b2.remove();
    __privateSet(this, _popup, null);
    __privateSet(this, _wasVisible, false);
    __privateSet(this, _pinned, false);
    for (const element of this.trigger) {
      element.classList.remove("popupTriggerArea");
    }
  }
  forceHide() {
    __privateSet(this, _wasVisible, this.isVisible);
    if (!__privateGet(this, _wasVisible)) {
      return;
    }
    __privateGet(this, _container4).hidden = true;
  }
  maybeShow() {
    __privateMethod(this, _addEventListeners, addEventListeners_fn).call(this);
    if (!__privateGet(this, _wasVisible)) {
      return;
    }
    if (!__privateGet(this, _popup)) {
      __privateMethod(this, _show, show_fn).call(this);
    }
    __privateSet(this, _wasVisible, false);
    __privateGet(this, _container4).hidden = false;
  }
  get isVisible() {
    return __privateGet(this, _container4).hidden === false;
  }
};
_boundKeyDown = new WeakMap();
_boundHide = new WeakMap();
_boundShow = new WeakMap();
_boundToggle = new WeakMap();
_color = new WeakMap();
_container4 = new WeakMap();
_contentsObj = new WeakMap();
_dateObj = new WeakMap();
_elements = new WeakMap();
_eventBus2 = new WeakMap();
_parent = new WeakMap();
_parentRect = new WeakMap();
_pinned = new WeakMap();
_popup = new WeakMap();
_popupAbortController = new WeakMap();
_position2 = new WeakMap();
_commentButton2 = new WeakMap();
_commentButtonPosition = new WeakMap();
_commentButtonColor = new WeakMap();
_rect = new WeakMap();
_richText = new WeakMap();
_titleObj = new WeakMap();
_updates2 = new WeakMap();
_wasVisible = new WeakMap();
_addEventListeners = new WeakSet();
addEventListeners_fn = function() {
  var _a3;
  if (__privateGet(this, _popupAbortController)) {
    return;
  }
  __privateSet(this, _popupAbortController, new AbortController());
  const {
    signal
  } = __privateGet(this, _popupAbortController);
  for (const element of this.trigger) {
    element.addEventListener("click", __privateGet(this, _boundToggle), {
      signal
    });
    element.addEventListener("mouseenter", __privateGet(this, _boundShow), {
      signal
    });
    element.addEventListener("mouseleave", __privateGet(this, _boundHide), {
      signal
    });
    element.classList.add("popupTriggerArea");
  }
  for (const element of __privateGet(this, _elements)) {
    (_a3 = element.container) == null ? void 0 : _a3.addEventListener("keydown", __privateGet(this, _boundKeyDown), {
      signal
    });
  }
  __privateMethod(this, _renderCommentButton, renderCommentButton_fn).call(this);
};
_setCommentButtonPosition = new WeakSet();
setCommentButtonPosition_fn = function() {
  const element = __privateGet(this, _elements).find((e) => e.hasCommentButton);
  if (!element) {
    return;
  }
  __privateSet(this, _commentButtonPosition, element._normalizePoint(element.commentButtonPosition));
  __privateSet(this, _commentButtonColor, element.commentButtonColor);
};
_renderCommentButton = new WeakSet();
renderCommentButton_fn = function() {
  if (__privateGet(this, _commentButton2)) {
    return;
  }
  if (!__privateGet(this, _commentButtonPosition)) {
    __privateMethod(this, _setCommentButtonPosition, setCommentButtonPosition_fn).call(this);
  }
  if (!__privateGet(this, _commentButtonPosition)) {
    return;
  }
  const button = __privateSet(this, _commentButton2, document.createElement("button"));
  button.className = "annotationCommentButton";
  const parentContainer = __privateGet(this, _elements)[0].container;
  button.style.zIndex = parentContainer.style.zIndex + 1;
  button.tabIndex = 0;
  const {
    signal
  } = __privateGet(this, _popupAbortController);
  button.addEventListener("hover", __privateGet(this, _boundToggle), {
    signal
  });
  button.addEventListener("keydown", __privateGet(this, _boundKeyDown), {
    signal
  });
  button.addEventListener("click", () => {
    var _a3;
    const [{
      data: {
        id: editId
      },
      annotationEditorType: mode
    }] = __privateGet(this, _elements);
    (_a3 = __privateGet(this, _eventBus2)) == null ? void 0 : _a3.dispatch("switchannotationeditormode", {
      source: this,
      editId,
      mode,
      editComment: true
    });
  }, {
    signal
  });
  const {
    style
  } = button;
  style.left = `calc(${__privateGet(this, _commentButtonPosition)[0]}%)`;
  style.top = `calc(${__privateGet(this, _commentButtonPosition)[1]}% - var(--comment-button-dim))`;
  if (__privateGet(this, _commentButtonColor)) {
    style.backgroundColor = __privateGet(this, _commentButtonColor);
  }
  parentContainer.after(button);
};
_html = new WeakSet();
html_get = function() {
  const richText = __privateGet(this, _richText);
  const contentsObj = __privateGet(this, _contentsObj);
  if ((richText == null ? void 0 : richText.str) && (!(contentsObj == null ? void 0 : contentsObj.str) || contentsObj.str === richText.str)) {
    return __privateGet(this, _richText).html || null;
  }
  return null;
};
_fontSize = new WeakSet();
fontSize_get = function() {
  var _a3, _b2, _c;
  return ((_c = (_b2 = (_a3 = __privateGet(this, _html, html_get)) == null ? void 0 : _a3.attributes) == null ? void 0 : _b2.style) == null ? void 0 : _c.fontSize) || 0;
};
_fontColor = new WeakSet();
fontColor_get = function() {
  var _a3, _b2, _c;
  return ((_c = (_b2 = (_a3 = __privateGet(this, _html, html_get)) == null ? void 0 : _a3.attributes) == null ? void 0 : _b2.style) == null ? void 0 : _c.color) || null;
};
_makePopupContent = new WeakSet();
makePopupContent_fn = function(text) {
  const popupLines = [];
  const popupContent = {
    str: text,
    html: {
      name: "div",
      attributes: {
        dir: "auto"
      },
      children: [{
        name: "p",
        children: popupLines
      }]
    }
  };
  const lineAttributes = {
    style: {
      color: __privateGet(this, _fontColor, fontColor_get),
      fontSize: __privateGet(this, _fontSize, fontSize_get) ? `calc(${__privateGet(this, _fontSize, fontSize_get)}px * var(--total-scale-factor))` : ""
    }
  };
  for (const line of text.split("\n")) {
    popupLines.push({
      name: "span",
      value: line,
      attributes: lineAttributes
    });
  }
  return popupContent;
};
_keyDown2 = new WeakSet();
keyDown_fn2 = function(event) {
  if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
    return;
  }
  if (event.key === "Enter" || event.key === "Escape" && __privateGet(this, _pinned)) {
    __privateMethod(this, _toggle, toggle_fn).call(this);
  }
};
_setPosition = new WeakSet();
setPosition_fn = function() {
  if (__privateGet(this, _position2) !== null) {
    return;
  }
  const {
    page: {
      view
    },
    viewport: {
      rawDims: {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      }
    }
  } = __privateGet(this, _parent);
  let useParentRect = !!__privateGet(this, _parentRect);
  let rect = useParentRect ? __privateGet(this, _parentRect) : __privateGet(this, _rect);
  for (const element of __privateGet(this, _elements)) {
    if (!rect || Util.intersect(element.data.rect, rect) !== null) {
      rect = element.data.rect;
      useParentRect = true;
      break;
    }
  }
  const normalizedRect = Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
  const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
  const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
  const popupLeft = normalizedRect[0] + parentWidth;
  const popupTop = normalizedRect[1];
  __privateSet(this, _position2, [100 * (popupLeft - pageX) / pageWidth, 100 * (popupTop - pageY) / pageHeight]);
  const {
    style
  } = __privateGet(this, _container4);
  style.left = `${__privateGet(this, _position2)[0]}%`;
  style.top = `${__privateGet(this, _position2)[1]}%`;
};
_toggle = new WeakSet();
toggle_fn = function() {
  __privateSet(this, _pinned, !__privateGet(this, _pinned));
  if (__privateGet(this, _pinned)) {
    __privateMethod(this, _show, show_fn).call(this);
    __privateGet(this, _container4).addEventListener("click", __privateGet(this, _boundToggle));
    __privateGet(this, _container4).addEventListener("keydown", __privateGet(this, _boundKeyDown));
  } else {
    __privateMethod(this, _hide, hide_fn).call(this);
    __privateGet(this, _container4).removeEventListener("click", __privateGet(this, _boundToggle));
    __privateGet(this, _container4).removeEventListener("keydown", __privateGet(this, _boundKeyDown));
  }
};
_show = new WeakSet();
show_fn = function() {
  if (!__privateGet(this, _popup)) {
    this.render();
  }
  if (!this.isVisible) {
    __privateMethod(this, _setPosition, setPosition_fn).call(this);
    __privateGet(this, _container4).hidden = false;
    __privateGet(this, _container4).style.zIndex = parseInt(__privateGet(this, _container4).style.zIndex) + 1e3;
  } else if (__privateGet(this, _pinned)) {
    __privateGet(this, _container4).classList.add("focused");
  }
};
_hide = new WeakSet();
hide_fn = function() {
  __privateGet(this, _container4).classList.remove("focused");
  if (__privateGet(this, _pinned) || !this.isVisible) {
    return;
  }
  __privateGet(this, _container4).hidden = true;
  __privateGet(this, _container4).style.zIndex = parseInt(__privateGet(this, _container4).style.zIndex) - 1e3;
};
var FreeTextAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.textContent = parameters.data.textContent;
    this.textPosition = parameters.data.textPosition;
    this.annotationEditorType = AnnotationEditorType.FREETEXT;
  }
  render() {
    this.container.classList.add("freeTextAnnotation");
    if (this.textContent) {
      const content = document.createElement("div");
      content.classList.add("annotationTextContent");
      content.setAttribute("role", "comment");
      for (const line of this.textContent) {
        const lineSpan = document.createElement("span");
        lineSpan.textContent = line;
        content.append(lineSpan);
      }
      this.container.append(content);
    }
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this._editOnDoubleClick();
    return this.container;
  }
};
var _line;
var LineAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    __privateAdd(this, _line, null);
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const {
      data,
      width,
      height
    } = this;
    const svg = this.svgFactory.create(width, height, true);
    const line = __privateSet(this, _line, this.svgFactory.createElement("svg:line"));
    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
    line.setAttribute("stroke-width", data.borderStyle.width || 1);
    line.setAttribute("stroke", "transparent");
    line.setAttribute("fill", "transparent");
    svg.append(line);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _line);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_line = new WeakMap();
var _square;
var SquareAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    __privateAdd(this, _square, null);
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const {
      data,
      width,
      height
    } = this;
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const square = __privateSet(this, _square, this.svgFactory.createElement("svg:rect"));
    square.setAttribute("x", borderWidth / 2);
    square.setAttribute("y", borderWidth / 2);
    square.setAttribute("width", width - borderWidth);
    square.setAttribute("height", height - borderWidth);
    square.setAttribute("stroke-width", borderWidth || 1);
    square.setAttribute("stroke", "transparent");
    square.setAttribute("fill", "transparent");
    svg.append(square);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _square);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_square = new WeakMap();
var _circle;
var CircleAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    __privateAdd(this, _circle, null);
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const {
      data,
      width,
      height
    } = this;
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const circle = __privateSet(this, _circle, this.svgFactory.createElement("svg:ellipse"));
    circle.setAttribute("cx", width / 2);
    circle.setAttribute("cy", height / 2);
    circle.setAttribute("rx", width / 2 - borderWidth / 2);
    circle.setAttribute("ry", height / 2 - borderWidth / 2);
    circle.setAttribute("stroke-width", borderWidth || 1);
    circle.setAttribute("stroke", "transparent");
    circle.setAttribute("fill", "transparent");
    svg.append(circle);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _circle);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_circle = new WeakMap();
var _polyline;
var PolylineAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    __privateAdd(this, _polyline, null);
    this.containerClassName = "polylineAnnotation";
    this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect,
        vertices,
        borderStyle,
        popupRef
      },
      width,
      height
    } = this;
    if (!vertices) {
      return this.container;
    }
    const svg = this.svgFactory.create(width, height, true);
    let points = [];
    for (let i = 0, ii = vertices.length; i < ii; i += 2) {
      const x = vertices[i] - rect[0];
      const y = rect[3] - vertices[i + 1];
      points.push(`${x},${y}`);
    }
    points = points.join(" ");
    const polyline = __privateSet(this, _polyline, this.svgFactory.createElement(this.svgElementName));
    polyline.setAttribute("points", points);
    polyline.setAttribute("stroke-width", borderStyle.width || 1);
    polyline.setAttribute("stroke", "transparent");
    polyline.setAttribute("fill", "transparent");
    svg.append(polyline);
    this.container.append(svg);
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _polyline);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_polyline = new WeakMap();
var PolygonAnnotationElement = class extends PolylineAnnotationElement {
  constructor(parameters) {
    super(parameters);
    this.containerClassName = "polygonAnnotation";
    this.svgElementName = "svg:polygon";
  }
};
var CaretAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("caretAnnotation");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
};
var _polylinesGroupElement, _polylines, _getTransform, getTransform_fn;
var InkAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    __privateAdd(this, _getTransform);
    __privateAdd(this, _polylinesGroupElement, null);
    __privateAdd(this, _polylines, []);
    this.containerClassName = "inkAnnotation";
    this.svgElementName = "svg:polyline";
    this.annotationEditorType = this.data.it === "InkHighlight" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect,
        rotation,
        inkLists,
        borderStyle,
        popupRef
      }
    } = this;
    const {
      transform,
      width,
      height
    } = __privateMethod(this, _getTransform, getTransform_fn).call(this, rotation, rect);
    const svg = this.svgFactory.create(width, height, true);
    const g = __privateSet(this, _polylinesGroupElement, this.svgFactory.createElement("svg:g"));
    svg.append(g);
    g.setAttribute("stroke-width", borderStyle.width || 1);
    g.setAttribute("stroke-linecap", "round");
    g.setAttribute("stroke-linejoin", "round");
    g.setAttribute("stroke-miterlimit", 10);
    g.setAttribute("stroke", "transparent");
    g.setAttribute("fill", "transparent");
    g.setAttribute("transform", transform);
    for (let i = 0, ii = inkLists.length; i < ii; i++) {
      const polyline = this.svgFactory.createElement(this.svgElementName);
      __privateGet(this, _polylines).push(polyline);
      polyline.setAttribute("points", inkLists[i].join(","));
      g.append(polyline);
    }
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.append(svg);
    this._editOnDoubleClick();
    return this.container;
  }
  updateEdited(params) {
    super.updateEdited(params);
    const {
      thickness,
      points,
      rect
    } = params;
    const g = __privateGet(this, _polylinesGroupElement);
    if (thickness >= 0) {
      g.setAttribute("stroke-width", thickness || 1);
    }
    if (points) {
      for (let i = 0, ii = __privateGet(this, _polylines).length; i < ii; i++) {
        __privateGet(this, _polylines)[i].setAttribute("points", points[i].join(","));
      }
    }
    if (rect) {
      const {
        transform,
        width,
        height
      } = __privateMethod(this, _getTransform, getTransform_fn).call(this, this.data.rotation, rect);
      const root = g.parentElement;
      root.setAttribute("viewBox", `0 0 ${width} ${height}`);
      g.setAttribute("transform", transform);
    }
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _polylines);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
  get commentButtonPosition() {
    const {
      inkLists,
      rect
    } = this.data;
    if ((inkLists == null ? void 0 : inkLists.length) >= 1) {
      let maxX = -Infinity;
      let maxY = -Infinity;
      for (const inkList of inkLists) {
        for (let i = 0, ii = inkList.length; i < ii; i += 2) {
          if (inkList[i + 1] > maxY) {
            maxY = inkList[i + 1];
            maxX = inkList[i];
          } else if (inkList[i + 1] === maxY) {
            maxX = Math.max(maxX, inkList[i]);
          }
        }
      }
      if (maxX !== Infinity) {
        return [maxX, maxY];
      }
    }
    if (rect) {
      return [rect[2], rect[3]];
    }
    return null;
  }
};
_polylinesGroupElement = new WeakMap();
_polylines = new WeakMap();
_getTransform = new WeakSet();
getTransform_fn = function(rotation, rect) {
  switch (rotation) {
    case 90:
      return {
        transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,
        width: rect[3] - rect[1],
        height: rect[2] - rect[0]
      };
    case 180:
      return {
        transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,
        width: rect[2] - rect[0],
        height: rect[3] - rect[1]
      };
    case 270:
      return {
        transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,
        width: rect[3] - rect[1],
        height: rect[2] - rect[0]
      };
    default:
      return {
        transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,
        width: rect[2] - rect[0],
        height: rect[3] - rect[1]
      };
  }
};
var HighlightAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
    this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("highlightAnnotation");
    this._editOnDoubleClick();
    if (overlaidText) {
      const mark = document.createElement("mark");
      mark.classList.add("overlaidText");
      mark.textContent = overlaidText;
      this.container.append(mark);
    }
    return this.container;
  }
};
var UnderlineAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("underlineAnnotation");
    if (overlaidText) {
      const underline = document.createElement("u");
      underline.classList.add("overlaidText");
      underline.textContent = overlaidText;
      this.container.append(underline);
    }
    return this.container;
  }
};
var SquigglyAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("squigglyAnnotation");
    if (overlaidText) {
      const underline = document.createElement("u");
      underline.classList.add("overlaidText");
      underline.textContent = overlaidText;
      this.container.append(underline);
    }
    return this.container;
  }
};
var StrikeOutAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("strikeoutAnnotation");
    if (overlaidText) {
      const strikeout = document.createElement("s");
      strikeout.classList.add("overlaidText");
      strikeout.textContent = overlaidText;
      this.container.append(strikeout);
    }
    return this.container;
  }
};
var StampAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.annotationEditorType = AnnotationEditorType.STAMP;
  }
  render() {
    this.container.classList.add("stampAnnotation");
    this.container.setAttribute("role", "img");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this._editOnDoubleClick();
    return this.container;
  }
};
var _trigger, _download, download_fn;
var FileAttachmentAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    var _a3;
    super(parameters, {
      isRenderable: true
    });
    __privateAdd(this, _download);
    __privateAdd(this, _trigger, null);
    const {
      file
    } = this.data;
    this.filename = file.filename;
    this.content = file.content;
    (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("fileattachmentannotation", {
      source: this,
      ...file
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container,
      data
    } = this;
    let trigger;
    if (data.hasAppearance || data.fillAlpha === 0) {
      trigger = document.createElement("div");
    } else {
      trigger = document.createElement("img");
      trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? "paperclip" : "pushpin"}.svg`;
      if (data.fillAlpha && data.fillAlpha < 1) {
        trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;
      }
    }
    trigger.addEventListener("dblclick", __privateMethod(this, _download, download_fn).bind(this));
    __privateSet(this, _trigger, trigger);
    const {
      isMac
    } = util_FeatureTest.platform;
    container.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
        __privateMethod(this, _download, download_fn).call(this);
      }
    });
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    } else {
      trigger.classList.add("popupTriggerArea");
    }
    container.append(trigger);
    return container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _trigger);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_trigger = new WeakMap();
_download = new WeakSet();
download_fn = function() {
  var _a3;
  (_a3 = this.downloadManager) == null ? void 0 : _a3.openOrDownloadData(this.content, this.filename);
};
var _accessibilityManager, _annotationCanvasMap, _editableAnnotations, _structTreeLayer, _appendElement, appendElement_fn, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn;
var _AnnotationLayer = class _AnnotationLayer {
  constructor({
    div,
    accessibilityManager,
    annotationCanvasMap,
    annotationEditorUIManager,
    page,
    viewport,
    structTreeLayer
  }) {
    __privateAdd(this, _appendElement);
    __privateAdd(this, _setAnnotationCanvasMap);
    __privateAdd(this, _accessibilityManager, null);
    __privateAdd(this, _annotationCanvasMap, null);
    __privateAdd(this, _editableAnnotations, /* @__PURE__ */ new Map());
    __privateAdd(this, _structTreeLayer, null);
    this.div = div;
    __privateSet(this, _accessibilityManager, accessibilityManager);
    __privateSet(this, _annotationCanvasMap, annotationCanvasMap);
    __privateSet(this, _structTreeLayer, structTreeLayer || null);
    this.page = page;
    this.viewport = viewport;
    this.zIndex = 0;
    this._annotationEditorUIManager = annotationEditorUIManager;
  }
  hasEditableAnnotations() {
    return __privateGet(this, _editableAnnotations).size > 0;
  }
  async render(params) {
    var _a3;
    const {
      annotations
    } = params;
    const layer = this.div;
    setLayerDimensions(layer, this.viewport);
    const popupToElements = /* @__PURE__ */ new Map();
    const elementParams = {
      data: null,
      layer,
      linkService: params.linkService,
      downloadManager: params.downloadManager,
      imageResourcesPath: params.imageResourcesPath || "",
      renderForms: params.renderForms !== false,
      svgFactory: new DOMSVGFactory(),
      annotationStorage: params.annotationStorage || new AnnotationStorage(),
      enableComment: params.enableComment === true,
      enableScripting: params.enableScripting === true,
      hasJSActions: params.hasJSActions,
      fieldObjects: params.fieldObjects,
      parent: this,
      elements: null
    };
    for (const data of annotations) {
      if (data.noHTML) {
        continue;
      }
      const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
      if (!isPopupAnnotation) {
        if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {
          continue;
        }
      } else {
        const elements = popupToElements.get(data.id);
        if (!elements) {
          continue;
        }
        elementParams.elements = elements;
      }
      elementParams.data = data;
      const element = AnnotationElementFactory.create(elementParams);
      if (!element.isRenderable) {
        continue;
      }
      if (!isPopupAnnotation && data.popupRef) {
        const elements = popupToElements.get(data.popupRef);
        if (!elements) {
          popupToElements.set(data.popupRef, [element]);
        } else {
          elements.push(element);
        }
      }
      const rendered = element.render();
      if (data.hidden) {
        rendered.style.visibility = "hidden";
      }
      await __privateMethod(this, _appendElement, appendElement_fn).call(this, rendered, data.id, elementParams.elements);
      if (element._isEditable) {
        __privateGet(this, _editableAnnotations).set(element.data.id, element);
        (_a3 = this._annotationEditorUIManager) == null ? void 0 : _a3.renderAnnotationElement(element);
      }
    }
    __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this);
  }
  async addLinkAnnotations(annotations, linkService) {
    const elementParams = {
      data: null,
      layer: this.div,
      linkService,
      svgFactory: new DOMSVGFactory(),
      parent: this
    };
    for (const data of annotations) {
      data.borderStyle || (data.borderStyle = _AnnotationLayer._defaultBorderStyle);
      elementParams.data = data;
      const element = AnnotationElementFactory.create(elementParams);
      if (!element.isRenderable) {
        continue;
      }
      const rendered = element.render();
      await __privateMethod(this, _appendElement, appendElement_fn).call(this, rendered, data.id, null);
    }
  }
  update({
    viewport
  }) {
    const layer = this.div;
    this.viewport = viewport;
    setLayerDimensions(layer, {
      rotation: viewport.rotation
    });
    __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this);
    layer.hidden = false;
  }
  getEditableAnnotations() {
    return Array.from(__privateGet(this, _editableAnnotations).values());
  }
  getEditableAnnotation(id) {
    return __privateGet(this, _editableAnnotations).get(id);
  }
  static get _defaultBorderStyle() {
    return shadow(this, "_defaultBorderStyle", Object.freeze({
      width: 1,
      rawWidth: 1,
      style: AnnotationBorderStyleType.SOLID,
      dashArray: [3],
      horizontalCornerRadius: 0,
      verticalCornerRadius: 0
    }));
  }
};
_accessibilityManager = new WeakMap();
_annotationCanvasMap = new WeakMap();
_editableAnnotations = new WeakMap();
_structTreeLayer = new WeakMap();
_appendElement = new WeakSet();
appendElement_fn = async function(element, id, popupElements) {
  var _a3, _b2;
  const contentElement = element.firstChild || element;
  const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;
  const ariaAttributes = await ((_a3 = __privateGet(this, _structTreeLayer)) == null ? void 0 : _a3.getAriaAttributes(annotationId));
  if (ariaAttributes) {
    for (const [key, value] of ariaAttributes) {
      contentElement.setAttribute(key, value);
    }
  }
  if (popupElements) {
    popupElements.at(-1).container.after(element);
  } else {
    this.div.append(element);
    (_b2 = __privateGet(this, _accessibilityManager)) == null ? void 0 : _b2.moveElementInDOM(this.div, element, contentElement, false);
  }
};
_setAnnotationCanvasMap = new WeakSet();
setAnnotationCanvasMap_fn = function() {
  var _a3;
  if (!__privateGet(this, _annotationCanvasMap)) {
    return;
  }
  const layer = this.div;
  for (const [id, canvas] of __privateGet(this, _annotationCanvasMap)) {
    const element = layer.querySelector(`[data-annotation-id="${id}"]`);
    if (!element) {
      continue;
    }
    canvas.className = "annotationContent";
    const {
      firstChild
    } = element;
    if (!firstChild) {
      element.append(canvas);
    } else if (firstChild.nodeName === "CANVAS") {
      firstChild.replaceWith(canvas);
    } else if (!firstChild.classList.contains("annotationContent")) {
      firstChild.before(canvas);
    } else {
      firstChild.after(canvas);
    }
    const editableAnnotation = __privateGet(this, _editableAnnotations).get(id);
    if (!editableAnnotation) {
      continue;
    }
    if (editableAnnotation._hasNoCanvas) {
      (_a3 = this._annotationEditorUIManager) == null ? void 0 : _a3.setMissingCanvas(id, element.id, canvas);
      editableAnnotation._hasNoCanvas = false;
    } else {
      editableAnnotation.canvas = canvas;
    }
  }
  __privateGet(this, _annotationCanvasMap).clear();
};
var AnnotationLayer = _AnnotationLayer;
var EOL_PATTERN = /\r\n?|\n/g;
var _color2, _content, _editorDivId, _editModeAC, _fontSize2, _updateFontSize, updateFontSize_fn, _updateColor, updateColor_fn, _extractText, extractText_fn, _setEditorDimensions, setEditorDimensions_fn, _getNodeContent, getNodeContent_fn, _setContent, setContent_fn, _serializeContent, serializeContent_fn, _deserializeContent, deserializeContent_fn, _hasElementChanged, hasElementChanged_fn;
var _FreeTextEditor = class _FreeTextEditor extends AnnotationEditor {
  constructor(params) {
    super({
      ...params,
      name: "freeTextEditor"
    });
    __privateAdd(this, _updateFontSize);
    __privateAdd(this, _updateColor);
    __privateAdd(this, _extractText);
    __privateAdd(this, _setEditorDimensions);
    __privateAdd(this, _setContent);
    __privateAdd(this, _serializeContent);
    __privateAdd(this, _hasElementChanged);
    __privateAdd(this, _color2, void 0);
    __privateAdd(this, _content, "");
    __privateAdd(this, _editorDivId, `${this.id}-editor`);
    __privateAdd(this, _editModeAC, null);
    __privateAdd(this, _fontSize2, void 0);
    __publicField(this, "_colorPicker", null);
    __privateSet(this, _color2, params.color || _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor);
    __privateSet(this, _fontSize2, params.fontSize || _FreeTextEditor._defaultFontSize);
    if (!this.annotationElementId) {
      this._uiManager.a11yAlert("pdfjs-editor-freetext-added-alert");
    }
  }
  static get _keyboardManager() {
    const proto = _FreeTextEditor.prototype;
    const arrowChecker = (self) => self.isEmpty();
    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
    const big = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
      bubbles: true
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    const style = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.FREETEXT_SIZE:
        _FreeTextEditor._defaultFontSize = value;
        break;
      case AnnotationEditorParamsType.FREETEXT_COLOR:
        _FreeTextEditor._defaultColor = value;
        break;
    }
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.FREETEXT_SIZE:
        __privateMethod(this, _updateFontSize, updateFontSize_fn).call(this, value);
        break;
      case AnnotationEditorParamsType.FREETEXT_COLOR:
        __privateMethod(this, _updateColor, updateColor_fn).call(this, value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType.FREETEXT_SIZE, __privateGet(this, _fontSize2)], [AnnotationEditorParamsType.FREETEXT_COLOR, __privateGet(this, _color2)]];
  }
  get toolbarButtons() {
    this._colorPicker || (this._colorPicker = new BasicColorPicker(this));
    return [["colorPicker", this._colorPicker]];
  }
  get colorType() {
    return AnnotationEditorParamsType.FREETEXT_COLOR;
  }
  get colorValue() {
    return __privateGet(this, _color2);
  }
  _translateEmpty(x, y) {
    this._uiManager.translateSelectedEditors(x, y, true);
  }
  getInitialTranslation() {
    const scale = this.parentScale;
    return [-_FreeTextEditor._internalPadding * scale, -(_FreeTextEditor._internalPadding + __privateGet(this, _fontSize2)) * scale];
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  enableEditMode() {
    if (!super.enableEditMode()) {
      return false;
    }
    this.overlayDiv.classList.remove("enabled");
    this.editorDiv.contentEditable = true;
    this._isDraggable = false;
    this.div.removeAttribute("aria-activedescendant");
    __privateSet(this, _editModeAC, new AbortController());
    const signal = this._uiManager.combinedSignal(__privateGet(this, _editModeAC));
    this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
      signal
    });
    return true;
  }
  disableEditMode() {
    var _a3;
    if (!super.disableEditMode()) {
      return false;
    }
    this.overlayDiv.classList.add("enabled");
    this.editorDiv.contentEditable = false;
    this.div.setAttribute("aria-activedescendant", __privateGet(this, _editorDivId));
    this._isDraggable = true;
    (_a3 = __privateGet(this, _editModeAC)) == null ? void 0 : _a3.abort();
    __privateSet(this, _editModeAC, null);
    this.div.focus({
      preventScroll: true
    });
    this.isEditing = false;
    this.parent.div.classList.add("freetextEditing");
    return true;
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    super.focusin(event);
    if (event.target !== this.editorDiv) {
      this.editorDiv.focus();
    }
  }
  onceAdded(focus) {
    var _a3;
    if (this.width) {
      return;
    }
    this.enableEditMode();
    if (focus) {
      this.editorDiv.focus();
    }
    if ((_a3 = this._initialOptions) == null ? void 0 : _a3.isCentered) {
      this.center();
    }
    this._initialOptions = null;
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = false;
    if (this.parent) {
      this.parent.setEditingState(true);
      this.parent.div.classList.add("freetextEditing");
    }
    super.remove();
  }
  commit() {
    if (!this.isInEditMode()) {
      return;
    }
    super.commit();
    this.disableEditMode();
    const savedText = __privateGet(this, _content);
    const newText = __privateSet(this, _content, __privateMethod(this, _extractText, extractText_fn).call(this).trimEnd());
    if (savedText === newText) {
      return;
    }
    const setText = (text) => {
      __privateSet(this, _content, text);
      if (!text) {
        this.remove();
        return;
      }
      __privateMethod(this, _setContent, setContent_fn).call(this);
      this._uiManager.rebuild(this);
      __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
    };
    this.addCommands({
      cmd: () => {
        setText(newText);
      },
      undo: () => {
        setText(savedText);
      },
      mustExec: false
    });
    __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode();
    this.editorDiv.focus();
  }
  keydown(event) {
    if (event.target === this.div && event.key === "Enter") {
      this.enterInEditMode();
      event.preventDefault();
    }
  }
  editorDivKeydown(event) {
    _FreeTextEditor._keyboardManager.exec(this, event);
  }
  editorDivFocus(event) {
    this.isEditing = true;
  }
  editorDivBlur(event) {
    this.isEditing = false;
  }
  editorDivInput(event) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment");
    this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox");
    this.editorDiv.setAttribute("aria-multiline", true);
  }
  get canChangeContent() {
    return true;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this._isCopy || this.annotationElementId) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.editorDiv = document.createElement("div");
    this.editorDiv.className = "internal";
    this.editorDiv.setAttribute("id", __privateGet(this, _editorDivId));
    this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2");
    this.editorDiv.setAttribute("data-l10n-attrs", "default-content");
    this.enableEditing();
    this.editorDiv.contentEditable = true;
    const {
      style
    } = this.editorDiv;
    style.fontSize = `calc(${__privateGet(this, _fontSize2)}px * var(--total-scale-factor))`;
    style.color = __privateGet(this, _color2);
    this.div.append(this.editorDiv);
    this.overlayDiv = document.createElement("div");
    this.overlayDiv.classList.add("overlay", "enabled");
    this.div.append(this.overlayDiv);
    if (this._isCopy || this.annotationElementId) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position
        } = this._initialData;
        let [tx, ty] = this.getInitialTranslation();
        [tx, ty] = this.pageTranslationToScreen(tx, ty);
        const [pageWidth, pageHeight] = this.pageDimensions;
        const [pageX, pageY] = this.pageTranslation;
        let posX, posY;
        switch (this.rotation) {
          case 0:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY + this.height - (position[1] - pageY) / pageHeight;
            break;
          case 90:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [ty, -tx];
            break;
          case 180:
            posX = baseX - this.width + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [-tx, -ty];
            break;
          case 270:
            posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
            posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
            [tx, ty] = [-ty, tx];
            break;
        }
        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
      } else {
        this._moveAfterPaste(baseX, baseY);
      }
      __privateMethod(this, _setContent, setContent_fn).call(this);
      this._isDraggable = true;
      this.editorDiv.contentEditable = false;
    } else {
      this._isDraggable = false;
      this.editorDiv.contentEditable = true;
    }
    return this.div;
  }
  editorDivPaste(event) {
    var _a3, _b2, _c;
    const clipboardData = event.clipboardData || window.clipboardData;
    const {
      types
    } = clipboardData;
    if (types.length === 1 && types[0] === "text/plain") {
      return;
    }
    event.preventDefault();
    const paste = __privateMethod(_a3 = _FreeTextEditor, _deserializeContent, deserializeContent_fn).call(_a3, clipboardData.getData("text") || "").replaceAll(EOL_PATTERN, "\n");
    if (!paste) {
      return;
    }
    const selection2 = window.getSelection();
    if (!selection2.rangeCount) {
      return;
    }
    this.editorDiv.normalize();
    selection2.deleteFromDocument();
    const range = selection2.getRangeAt(0);
    if (!paste.includes("\n")) {
      range.insertNode(document.createTextNode(paste));
      this.editorDiv.normalize();
      selection2.collapseToStart();
      return;
    }
    const {
      startContainer,
      startOffset
    } = range;
    const bufferBefore = [];
    const bufferAfter = [];
    if (startContainer.nodeType === Node.TEXT_NODE) {
      const parent = startContainer.parentElement;
      bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, ""));
      if (parent !== this.editorDiv) {
        let buffer = bufferBefore;
        for (const child of this.editorDiv.childNodes) {
          if (child === parent) {
            buffer = bufferAfter;
            continue;
          }
          buffer.push(__privateMethod(_b2 = _FreeTextEditor, _getNodeContent, getNodeContent_fn).call(_b2, child));
        }
      }
      bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, ""));
    } else if (startContainer === this.editorDiv) {
      let buffer = bufferBefore;
      let i = 0;
      for (const child of this.editorDiv.childNodes) {
        if (i++ === startOffset) {
          buffer = bufferAfter;
        }
        buffer.push(__privateMethod(_c = _FreeTextEditor, _getNodeContent, getNodeContent_fn).call(_c, child));
      }
    }
    __privateSet(this, _content, `${bufferBefore.join("\n")}${paste}${bufferAfter.join("\n")}`);
    __privateMethod(this, _setContent, setContent_fn).call(this);
    const newRange = new Range();
    let beforeLength = Math.sumPrecise(bufferBefore.map((line) => line.length));
    for (const {
      firstChild
    } of this.editorDiv.childNodes) {
      if (firstChild.nodeType === Node.TEXT_NODE) {
        const length = firstChild.nodeValue.length;
        if (beforeLength <= length) {
          newRange.setStart(firstChild, beforeLength);
          newRange.setEnd(firstChild, beforeLength);
          break;
        }
        beforeLength -= length;
      }
    }
    selection2.removeAllRanges();
    selection2.addRange(newRange);
  }
  get contentDiv() {
    return this.editorDiv;
  }
  getPDFRect() {
    const padding = _FreeTextEditor._internalPadding * this.parentScale;
    return this.getRect(padding, padding);
  }
  static async deserialize(data, parent, uiManager) {
    var _a3;
    let initialData = null;
    if (data instanceof FreeTextAnnotationElement) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize,
            fontColor
          },
          rect,
          rotation,
          id,
          popupRef,
          contentsObj
        },
        textContent,
        textPosition,
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      if (!textContent || textContent.length === 0) {
        return null;
      }
      initialData = data = {
        annotationType: AnnotationEditorType.FREETEXT,
        color: Array.from(fontColor),
        fontSize,
        value: textContent.join("\n"),
        position: textPosition,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        comment: (contentsObj == null ? void 0 : contentsObj.str) || null
      };
    }
    const editor = await super.deserialize(data, parent, uiManager);
    __privateSet(editor, _fontSize2, data.fontSize);
    __privateSet(editor, _color2, Util.makeHexColor(...data.color));
    __privateSet(editor, _content, __privateMethod(_a3 = _FreeTextEditor, _deserializeContent, deserializeContent_fn).call(_a3, data.value));
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data.comment);
    }
    return editor;
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const rect = this.getPDFRect();
    const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : __privateGet(this, _color2));
    const serialized = {
      annotationType: AnnotationEditorType.FREETEXT,
      color,
      fontSize: __privateGet(this, _fontSize2),
      value: __privateMethod(this, _serializeContent, serializeContent_fn).call(this),
      pageIndex: this.pageIndex,
      rect,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    this.addComment(serialized);
    if (isForCopying) {
      serialized.isCopy = true;
      return serialized;
    }
    if (this.annotationElementId && !__privateMethod(this, _hasElementChanged, hasElementChanged_fn).call(this, serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  renderAnnotationElement(annotation) {
    const content = super.renderAnnotationElement(annotation);
    if (!content) {
      return null;
    }
    const {
      style
    } = content;
    style.fontSize = `calc(${__privateGet(this, _fontSize2)}px * var(--total-scale-factor))`;
    style.color = __privateGet(this, _color2);
    content.replaceChildren();
    for (const line of __privateGet(this, _content).split("\n")) {
      const div = document.createElement("div");
      div.append(line ? document.createTextNode(line) : document.createElement("br"));
      content.append(div);
    }
    const params = {
      rect: this.getPDFRect()
    };
    params.popup = this.hasEditedComment ? this.comment : {
      text: __privateGet(this, _content)
    };
    annotation.updateEdited(params);
    return content;
  }
  resetAnnotationElement(annotation) {
    super.resetAnnotationElement(annotation);
    annotation.resetEdited();
  }
};
_color2 = new WeakMap();
_content = new WeakMap();
_editorDivId = new WeakMap();
_editModeAC = new WeakMap();
_fontSize2 = new WeakMap();
_updateFontSize = new WeakSet();
updateFontSize_fn = function(fontSize) {
  const setFontsize = (size) => {
    this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;
    this.translate(0, -(size - __privateGet(this, _fontSize2)) * this.parentScale);
    __privateSet(this, _fontSize2, size);
    __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
  };
  const savedFontsize = __privateGet(this, _fontSize2);
  this.addCommands({
    cmd: setFontsize.bind(this, fontSize),
    undo: setFontsize.bind(this, savedFontsize),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: true,
    type: AnnotationEditorParamsType.FREETEXT_SIZE,
    overwriteIfSameType: true,
    keepUndo: true
  });
};
_updateColor = new WeakSet();
updateColor_fn = function(color) {
  const setColor = (col) => {
    var _a3;
    __privateSet(this, _color2, this.editorDiv.style.color = col);
    (_a3 = this._colorPicker) == null ? void 0 : _a3.update(col);
  };
  const savedColor = __privateGet(this, _color2);
  this.addCommands({
    cmd: setColor.bind(this, color),
    undo: setColor.bind(this, savedColor),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: true,
    type: AnnotationEditorParamsType.FREETEXT_COLOR,
    overwriteIfSameType: true,
    keepUndo: true
  });
};
_extractText = new WeakSet();
extractText_fn = function() {
  var _a3;
  const buffer = [];
  this.editorDiv.normalize();
  let prevChild = null;
  for (const child of this.editorDiv.childNodes) {
    if ((prevChild == null ? void 0 : prevChild.nodeType) === Node.TEXT_NODE && child.nodeName === "BR") {
      continue;
    }
    buffer.push(__privateMethod(_a3 = _FreeTextEditor, _getNodeContent, getNodeContent_fn).call(_a3, child));
    prevChild = child;
  }
  return buffer.join("\n");
};
_setEditorDimensions = new WeakSet();
setEditorDimensions_fn = function() {
  const [parentWidth, parentHeight] = this.parentDimensions;
  let rect;
  if (this.isAttachedToDOM) {
    rect = this.div.getBoundingClientRect();
  } else {
    const {
      currentLayer,
      div
    } = this;
    const savedDisplay = div.style.display;
    const savedVisibility = div.classList.contains("hidden");
    div.classList.remove("hidden");
    div.style.display = "hidden";
    currentLayer.div.append(this.div);
    rect = div.getBoundingClientRect();
    div.remove();
    div.style.display = savedDisplay;
    div.classList.toggle("hidden", savedVisibility);
  }
  if (this.rotation % 180 === this.parentRotation % 180) {
    this.width = rect.width / parentWidth;
    this.height = rect.height / parentHeight;
  } else {
    this.width = rect.height / parentWidth;
    this.height = rect.width / parentHeight;
  }
  this.fixAndSetPosition();
};
_getNodeContent = new WeakSet();
getNodeContent_fn = function(node) {
  return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, "");
};
_setContent = new WeakSet();
setContent_fn = function() {
  this.editorDiv.replaceChildren();
  if (!__privateGet(this, _content)) {
    return;
  }
  for (const line of __privateGet(this, _content).split("\n")) {
    const div = document.createElement("div");
    div.append(line ? document.createTextNode(line) : document.createElement("br"));
    this.editorDiv.append(div);
  }
};
_serializeContent = new WeakSet();
serializeContent_fn = function() {
  return __privateGet(this, _content).replaceAll("\xA0", " ");
};
_deserializeContent = new WeakSet();
deserializeContent_fn = function(content) {
  return content.replaceAll(" ", "\xA0");
};
_hasElementChanged = new WeakSet();
hasElementChanged_fn = function(serialized) {
  const {
    value,
    fontSize,
    color,
    pageIndex
  } = this._initialData;
  return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;
};
__privateAdd(_FreeTextEditor, _getNodeContent);
__privateAdd(_FreeTextEditor, _deserializeContent);
__publicField(_FreeTextEditor, "_freeTextDefaultContent", "");
__publicField(_FreeTextEditor, "_internalPadding", 0);
__publicField(_FreeTextEditor, "_defaultColor", null);
__publicField(_FreeTextEditor, "_defaultFontSize", 10);
__publicField(_FreeTextEditor, "_type", "freetext");
__publicField(_FreeTextEditor, "_editorType", AnnotationEditorType.FREETEXT);
var FreeTextEditor = _FreeTextEditor;
var Outline = class {
  toSVGPath() {
    unreachable("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    unreachable("Abstract getter `box` must be implemented.");
  }
  serialize(_bbox3, _rotation4) {
    unreachable("Abstract method `serialize` must be implemented.");
  }
  static _rescale(src, tx, ty, sx, sy, dest) {
    dest || (dest = new Float32Array(src.length));
    for (let i = 0, ii = src.length; i < ii; i += 2) {
      dest[i] = tx + src[i] * sx;
      dest[i + 1] = ty + src[i + 1] * sy;
    }
    return dest;
  }
  static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {
    dest || (dest = new Float32Array(src.length));
    for (let i = 0, ii = src.length; i < ii; i += 2) {
      dest[i] = tx + src[i + 1] * sx;
      dest[i + 1] = ty + src[i] * sy;
    }
    return dest;
  }
  static _translate(src, tx, ty, dest) {
    dest || (dest = new Float32Array(src.length));
    for (let i = 0, ii = src.length; i < ii; i += 2) {
      dest[i] = tx + src[i];
      dest[i + 1] = ty + src[i + 1];
    }
    return dest;
  }
  static svgRound(x) {
    return Math.round(x * 1e4);
  }
  static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {
    switch (rotation) {
      case 90:
        return [1 - y / parentWidth, x / parentHeight];
      case 180:
        return [1 - x / parentWidth, 1 - y / parentHeight];
      case 270:
        return [y / parentWidth, 1 - x / parentHeight];
      default:
        return [x / parentWidth, y / parentHeight];
    }
  }
  static _normalizePagePoint(x, y, rotation) {
    switch (rotation) {
      case 90:
        return [1 - y, x];
      case 180:
        return [1 - x, 1 - y];
      case 270:
        return [y, 1 - x];
      default:
        return [x, y];
    }
  }
  static createBezierPoints(x1, y1, x2, y2, x3, y3) {
    return [(x1 + 5 * x2) / 6, (y1 + 5 * y2) / 6, (5 * x2 + x3) / 6, (5 * y2 + y3) / 6, (x2 + x3) / 2, (y2 + y3) / 2];
  }
};
__publicField(Outline, "PRECISION", 1e-4);
var _box, _bottom, _innerMargin, _isLTR, _top, _last, _lastX, _lastY, _min, _min_dist, _scaleFactor, _thickness, _points, _MIN_DIST, _MIN_DIFF, _MIN, _getLastCoords, getLastCoords_fn, _toSVGPathTwoPoints, toSVGPathTwoPoints_fn, _toSVGPathStart, toSVGPathStart_fn, _toSVGPathEnd, toSVGPathEnd_fn, _getOutlineTwoPoints, getOutlineTwoPoints_fn, _getOutlineStart, getOutlineStart_fn, _getOutlineEnd, getOutlineEnd_fn;
var _FreeDrawOutliner = class _FreeDrawOutliner {
  constructor({
    x,
    y
  }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
    __privateAdd(this, _getLastCoords);
    __privateAdd(this, _toSVGPathTwoPoints);
    __privateAdd(this, _toSVGPathStart);
    __privateAdd(this, _toSVGPathEnd);
    __privateAdd(this, _getOutlineTwoPoints);
    __privateAdd(this, _getOutlineStart);
    __privateAdd(this, _getOutlineEnd);
    __privateAdd(this, _box, void 0);
    __privateAdd(this, _bottom, []);
    __privateAdd(this, _innerMargin, void 0);
    __privateAdd(this, _isLTR, void 0);
    __privateAdd(this, _top, []);
    __privateAdd(this, _last, new Float32Array(18));
    __privateAdd(this, _lastX, void 0);
    __privateAdd(this, _lastY, void 0);
    __privateAdd(this, _min, void 0);
    __privateAdd(this, _min_dist, void 0);
    __privateAdd(this, _scaleFactor, void 0);
    __privateAdd(this, _thickness, void 0);
    __privateAdd(this, _points, []);
    __privateSet(this, _box, box);
    __privateSet(this, _thickness, thickness * scaleFactor);
    __privateSet(this, _isLTR, isLTR);
    __privateGet(this, _last).set([NaN, NaN, NaN, NaN, x, y], 6);
    __privateSet(this, _innerMargin, innerMargin);
    __privateSet(this, _min_dist, __privateGet(_FreeDrawOutliner, _MIN_DIST) * scaleFactor);
    __privateSet(this, _min, __privateGet(_FreeDrawOutliner, _MIN) * scaleFactor);
    __privateSet(this, _scaleFactor, scaleFactor);
    __privateGet(this, _points).push(x, y);
  }
  isEmpty() {
    return isNaN(__privateGet(this, _last)[8]);
  }
  add({
    x,
    y
  }) {
    var _a3;
    __privateSet(this, _lastX, x);
    __privateSet(this, _lastY, y);
    const [layerX, layerY, layerWidth, layerHeight] = __privateGet(this, _box);
    let [x1, y1, x2, y2] = __privateGet(this, _last).subarray(8, 12);
    const diffX = x - x2;
    const diffY = y - y2;
    const d = Math.hypot(diffX, diffY);
    if (d < __privateGet(this, _min)) {
      return false;
    }
    const diffD = d - __privateGet(this, _min_dist);
    const K = diffD / d;
    const shiftX = K * diffX;
    const shiftY = K * diffY;
    let x0 = x1;
    let y0 = y1;
    x1 = x2;
    y1 = y2;
    x2 += shiftX;
    y2 += shiftY;
    (_a3 = __privateGet(this, _points)) == null ? void 0 : _a3.push(x, y);
    const nX = -shiftY / diffD;
    const nY = shiftX / diffD;
    const thX = nX * __privateGet(this, _thickness);
    const thY = nY * __privateGet(this, _thickness);
    __privateGet(this, _last).set(__privateGet(this, _last).subarray(2, 8), 0);
    __privateGet(this, _last).set([x2 + thX, y2 + thY], 4);
    __privateGet(this, _last).set(__privateGet(this, _last).subarray(14, 18), 12);
    __privateGet(this, _last).set([x2 - thX, y2 - thY], 16);
    if (isNaN(__privateGet(this, _last)[6])) {
      if (__privateGet(this, _top).length === 0) {
        __privateGet(this, _last).set([x1 + thX, y1 + thY], 2);
        __privateGet(this, _top).push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);
        __privateGet(this, _last).set([x1 - thX, y1 - thY], 14);
        __privateGet(this, _bottom).push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);
      }
      __privateGet(this, _last).set([x0, y0, x1, y1, x2, y2], 6);
      return !this.isEmpty();
    }
    __privateGet(this, _last).set([x0, y0, x1, y1, x2, y2], 6);
    const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));
    if (angle < Math.PI / 2) {
      [x1, y1, x2, y2] = __privateGet(this, _last).subarray(2, 6);
      __privateGet(this, _top).push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
      [x1, y1, x0, y0] = __privateGet(this, _last).subarray(14, 18);
      __privateGet(this, _bottom).push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);
      return true;
    }
    [x0, y0, x1, y1, x2, y2] = __privateGet(this, _last).subarray(0, 6);
    __privateGet(this, _top).push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
    [x2, y2, x1, y1, x0, y0] = __privateGet(this, _last).subarray(12, 18);
    __privateGet(this, _bottom).push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
    return true;
  }
  toSVGPath() {
    if (this.isEmpty()) {
      return "";
    }
    const top = __privateGet(this, _top);
    const bottom = __privateGet(this, _bottom);
    if (isNaN(__privateGet(this, _last)[6]) && !this.isEmpty()) {
      return __privateMethod(this, _toSVGPathTwoPoints, toSVGPathTwoPoints_fn).call(this);
    }
    const buffer = [];
    buffer.push(`M${top[4]} ${top[5]}`);
    for (let i = 6; i < top.length; i += 6) {
      if (isNaN(top[i])) {
        buffer.push(`L${top[i + 4]} ${top[i + 5]}`);
      } else {
        buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);
      }
    }
    __privateMethod(this, _toSVGPathEnd, toSVGPathEnd_fn).call(this, buffer);
    for (let i = bottom.length - 6; i >= 6; i -= 6) {
      if (isNaN(bottom[i])) {
        buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);
      } else {
        buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);
      }
    }
    __privateMethod(this, _toSVGPathStart, toSVGPathStart_fn).call(this, buffer);
    return buffer.join(" ");
  }
  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
    return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
  }
  getOutlines() {
    var _a3, _b2;
    const top = __privateGet(this, _top);
    const bottom = __privateGet(this, _bottom);
    const last = __privateGet(this, _last);
    const [layerX, layerY, layerWidth, layerHeight] = __privateGet(this, _box);
    const points = new Float32Array(((_b2 = (_a3 = __privateGet(this, _points)) == null ? void 0 : _a3.length) != null ? _b2 : 0) + 2);
    for (let i = 0, ii = points.length - 2; i < ii; i += 2) {
      points[i] = (__privateGet(this, _points)[i] - layerX) / layerWidth;
      points[i + 1] = (__privateGet(this, _points)[i + 1] - layerY) / layerHeight;
    }
    points[points.length - 2] = (__privateGet(this, _lastX) - layerX) / layerWidth;
    points[points.length - 1] = (__privateGet(this, _lastY) - layerY) / layerHeight;
    if (isNaN(last[6]) && !this.isEmpty()) {
      return __privateMethod(this, _getOutlineTwoPoints, getOutlineTwoPoints_fn).call(this, points);
    }
    const outline = new Float32Array(__privateGet(this, _top).length + 24 + __privateGet(this, _bottom).length);
    let N = top.length;
    for (let i = 0; i < N; i += 2) {
      if (isNaN(top[i])) {
        outline[i] = outline[i + 1] = NaN;
        continue;
      }
      outline[i] = top[i];
      outline[i + 1] = top[i + 1];
    }
    N = __privateMethod(this, _getOutlineEnd, getOutlineEnd_fn).call(this, outline, N);
    for (let i = bottom.length - 6; i >= 6; i -= 6) {
      for (let j = 0; j < 6; j += 2) {
        if (isNaN(bottom[i + j])) {
          outline[N] = outline[N + 1] = NaN;
          N += 2;
          continue;
        }
        outline[N] = bottom[i + j];
        outline[N + 1] = bottom[i + j + 1];
        N += 2;
      }
    }
    __privateMethod(this, _getOutlineStart, getOutlineStart_fn).call(this, outline, N);
    return this.newFreeDrawOutline(outline, points, __privateGet(this, _box), __privateGet(this, _scaleFactor), __privateGet(this, _innerMargin), __privateGet(this, _isLTR));
  }
};
_box = new WeakMap();
_bottom = new WeakMap();
_innerMargin = new WeakMap();
_isLTR = new WeakMap();
_top = new WeakMap();
_last = new WeakMap();
_lastX = new WeakMap();
_lastY = new WeakMap();
_min = new WeakMap();
_min_dist = new WeakMap();
_scaleFactor = new WeakMap();
_thickness = new WeakMap();
_points = new WeakMap();
_MIN_DIST = new WeakMap();
_MIN_DIFF = new WeakMap();
_MIN = new WeakMap();
_getLastCoords = new WeakSet();
getLastCoords_fn = function() {
  const lastTop = __privateGet(this, _last).subarray(4, 6);
  const lastBottom = __privateGet(this, _last).subarray(16, 18);
  const [x, y, width, height] = __privateGet(this, _box);
  return [(__privateGet(this, _lastX) + (lastTop[0] - lastBottom[0]) / 2 - x) / width, (__privateGet(this, _lastY) + (lastTop[1] - lastBottom[1]) / 2 - y) / height, (__privateGet(this, _lastX) + (lastBottom[0] - lastTop[0]) / 2 - x) / width, (__privateGet(this, _lastY) + (lastBottom[1] - lastTop[1]) / 2 - y) / height];
};
_toSVGPathTwoPoints = new WeakSet();
toSVGPathTwoPoints_fn = function() {
  const [x, y, width, height] = __privateGet(this, _box);
  const [lastTopX, lastTopY, lastBottomX, lastBottomY] = __privateMethod(this, _getLastCoords, getLastCoords_fn).call(this);
  return `M${(__privateGet(this, _last)[2] - x) / width} ${(__privateGet(this, _last)[3] - y) / height} L${(__privateGet(this, _last)[4] - x) / width} ${(__privateGet(this, _last)[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(__privateGet(this, _last)[16] - x) / width} ${(__privateGet(this, _last)[17] - y) / height} L${(__privateGet(this, _last)[14] - x) / width} ${(__privateGet(this, _last)[15] - y) / height} Z`;
};
_toSVGPathStart = new WeakSet();
toSVGPathStart_fn = function(buffer) {
  const bottom = __privateGet(this, _bottom);
  buffer.push(`L${bottom[4]} ${bottom[5]} Z`);
};
_toSVGPathEnd = new WeakSet();
toSVGPathEnd_fn = function(buffer) {
  const [x, y, width, height] = __privateGet(this, _box);
  const lastTop = __privateGet(this, _last).subarray(4, 6);
  const lastBottom = __privateGet(this, _last).subarray(16, 18);
  const [lastTopX, lastTopY, lastBottomX, lastBottomY] = __privateMethod(this, _getLastCoords, getLastCoords_fn).call(this);
  buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);
};
_getOutlineTwoPoints = new WeakSet();
getOutlineTwoPoints_fn = function(points) {
  const last = __privateGet(this, _last);
  const [layerX, layerY, layerWidth, layerHeight] = __privateGet(this, _box);
  const [lastTopX, lastTopY, lastBottomX, lastBottomY] = __privateMethod(this, _getLastCoords, getLastCoords_fn).call(this);
  const outline = new Float32Array(36);
  outline.set([NaN, NaN, NaN, NaN, (last[2] - layerX) / layerWidth, (last[3] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[4] - layerX) / layerWidth, (last[5] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (last[16] - layerX) / layerWidth, (last[17] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[14] - layerX) / layerWidth, (last[15] - layerY) / layerHeight], 0);
  return this.newFreeDrawOutline(outline, points, __privateGet(this, _box), __privateGet(this, _scaleFactor), __privateGet(this, _innerMargin), __privateGet(this, _isLTR));
};
_getOutlineStart = new WeakSet();
getOutlineStart_fn = function(outline, pos) {
  const bottom = __privateGet(this, _bottom);
  outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], pos);
  return pos += 6;
};
_getOutlineEnd = new WeakSet();
getOutlineEnd_fn = function(outline, pos) {
  const lastTop = __privateGet(this, _last).subarray(4, 6);
  const lastBottom = __privateGet(this, _last).subarray(16, 18);
  const [layerX, layerY, layerWidth, layerHeight] = __privateGet(this, _box);
  const [lastTopX, lastTopY, lastBottomX, lastBottomY] = __privateMethod(this, _getLastCoords, getLastCoords_fn).call(this);
  outline.set([NaN, NaN, NaN, NaN, (lastTop[0] - layerX) / layerWidth, (lastTop[1] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (lastBottom[0] - layerX) / layerWidth, (lastBottom[1] - layerY) / layerHeight], pos);
  return pos += 24;
};
__privateAdd(_FreeDrawOutliner, _MIN_DIST, 8);
__privateAdd(_FreeDrawOutliner, _MIN_DIFF, 2);
__privateAdd(_FreeDrawOutliner, _MIN, __privateGet(_FreeDrawOutliner, _MIN_DIST) + __privateGet(_FreeDrawOutliner, _MIN_DIFF));
var FreeDrawOutliner = _FreeDrawOutliner;
var _box2, _bbox, _innerMargin2, _isLTR2, _points2, _scaleFactor2, _outline, _computeMinMax, computeMinMax_fn;
var FreeDrawOutline = class extends Outline {
  constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {
    super();
    __privateAdd(this, _computeMinMax);
    __privateAdd(this, _box2, void 0);
    __privateAdd(this, _bbox, new Float32Array(4));
    __privateAdd(this, _innerMargin2, void 0);
    __privateAdd(this, _isLTR2, void 0);
    __privateAdd(this, _points2, void 0);
    __privateAdd(this, _scaleFactor2, void 0);
    __privateAdd(this, _outline, void 0);
    __privateSet(this, _outline, outline);
    __privateSet(this, _points2, points);
    __privateSet(this, _box2, box);
    __privateSet(this, _scaleFactor2, scaleFactor);
    __privateSet(this, _innerMargin2, innerMargin);
    __privateSet(this, _isLTR2, isLTR);
    this.lastPoint = [NaN, NaN];
    __privateMethod(this, _computeMinMax, computeMinMax_fn).call(this, isLTR);
    const [x, y, width, height] = __privateGet(this, _bbox);
    for (let i = 0, ii = outline.length; i < ii; i += 2) {
      outline[i] = (outline[i] - x) / width;
      outline[i + 1] = (outline[i + 1] - y) / height;
    }
    for (let i = 0, ii = points.length; i < ii; i += 2) {
      points[i] = (points[i] - x) / width;
      points[i + 1] = (points[i + 1] - y) / height;
    }
  }
  toSVGPath() {
    const buffer = [`M${__privateGet(this, _outline)[4]} ${__privateGet(this, _outline)[5]}`];
    for (let i = 6, ii = __privateGet(this, _outline).length; i < ii; i += 6) {
      if (isNaN(__privateGet(this, _outline)[i])) {
        buffer.push(`L${__privateGet(this, _outline)[i + 4]} ${__privateGet(this, _outline)[i + 5]}`);
        continue;
      }
      buffer.push(`C${__privateGet(this, _outline)[i]} ${__privateGet(this, _outline)[i + 1]} ${__privateGet(this, _outline)[i + 2]} ${__privateGet(this, _outline)[i + 3]} ${__privateGet(this, _outline)[i + 4]} ${__privateGet(this, _outline)[i + 5]}`);
    }
    buffer.push("Z");
    return buffer.join(" ");
  }
  serialize([blX, blY, trX, trY], rotation) {
    const width = trX - blX;
    const height = trY - blY;
    let outline;
    let points;
    switch (rotation) {
      case 0:
        outline = Outline._rescale(__privateGet(this, _outline), blX, trY, width, -height);
        points = Outline._rescale(__privateGet(this, _points2), blX, trY, width, -height);
        break;
      case 90:
        outline = Outline._rescaleAndSwap(__privateGet(this, _outline), blX, blY, width, height);
        points = Outline._rescaleAndSwap(__privateGet(this, _points2), blX, blY, width, height);
        break;
      case 180:
        outline = Outline._rescale(__privateGet(this, _outline), trX, blY, -width, height);
        points = Outline._rescale(__privateGet(this, _points2), trX, blY, -width, height);
        break;
      case 270:
        outline = Outline._rescaleAndSwap(__privateGet(this, _outline), trX, trY, -width, -height);
        points = Outline._rescaleAndSwap(__privateGet(this, _points2), trX, trY, -width, -height);
        break;
    }
    return {
      outline: Array.from(outline),
      points: [Array.from(points)]
    };
  }
  get box() {
    return __privateGet(this, _bbox);
  }
  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
    return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
  }
  getNewOutline(thickness, innerMargin) {
    const [x, y, width, height] = __privateGet(this, _bbox);
    const [layerX, layerY, layerWidth, layerHeight] = __privateGet(this, _box2);
    const sx = width * layerWidth;
    const sy = height * layerHeight;
    const tx = x * layerWidth + layerX;
    const ty = y * layerHeight + layerY;
    const outliner = this.newOutliner({
      x: __privateGet(this, _points2)[0] * sx + tx,
      y: __privateGet(this, _points2)[1] * sy + ty
    }, __privateGet(this, _box2), __privateGet(this, _scaleFactor2), thickness, __privateGet(this, _isLTR2), innerMargin != null ? innerMargin : __privateGet(this, _innerMargin2));
    for (let i = 2; i < __privateGet(this, _points2).length; i += 2) {
      outliner.add({
        x: __privateGet(this, _points2)[i] * sx + tx,
        y: __privateGet(this, _points2)[i + 1] * sy + ty
      });
    }
    return outliner.getOutlines();
  }
};
_box2 = new WeakMap();
_bbox = new WeakMap();
_innerMargin2 = new WeakMap();
_isLTR2 = new WeakMap();
_points2 = new WeakMap();
_scaleFactor2 = new WeakMap();
_outline = new WeakMap();
_computeMinMax = new WeakSet();
computeMinMax_fn = function(isLTR) {
  const outline = __privateGet(this, _outline);
  let lastX = outline[4];
  let lastY = outline[5];
  const minMax = [lastX, lastY, lastX, lastY];
  let lastPointX = lastX;
  let lastPointY = lastY;
  const ltrCallback = isLTR ? Math.max : Math.min;
  for (let i = 6, ii = outline.length; i < ii; i += 6) {
    const x = outline[i + 4], y = outline[i + 5];
    if (isNaN(outline[i])) {
      Util.pointBoundingBox(x, y, minMax);
      if (lastPointY < y) {
        lastPointX = x;
        lastPointY = y;
      } else if (lastPointY === y) {
        lastPointX = ltrCallback(lastPointX, x);
      }
    } else {
      const bbox2 = [Infinity, Infinity, -Infinity, -Infinity];
      Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bbox2);
      Util.rectBoundingBox(...bbox2, minMax);
      if (lastPointY < bbox2[3]) {
        lastPointX = bbox2[2];
        lastPointY = bbox2[3];
      } else if (lastPointY === bbox2[3]) {
        lastPointX = ltrCallback(lastPointX, bbox2[2]);
      }
    }
    lastX = x;
    lastY = y;
  }
  const bbox = __privateGet(this, _bbox);
  bbox[0] = minMax[0] - __privateGet(this, _innerMargin2);
  bbox[1] = minMax[1] - __privateGet(this, _innerMargin2);
  bbox[2] = minMax[2] - minMax[0] + 2 * __privateGet(this, _innerMargin2);
  bbox[3] = minMax[3] - minMax[1] + 2 * __privateGet(this, _innerMargin2);
  this.lastPoint = [lastPointX, lastPointY];
};
var _box3, _lastPoint, _verticalEdges, _intervals, _getOutlines, getOutlines_fn, _binarySearch, binarySearch_fn, _insert, insert_fn, _remove, remove_fn, _breakEdge, breakEdge_fn;
var HighlightOutliner = class {
  constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {
    __privateAdd(this, _getOutlines);
    __privateAdd(this, _binarySearch);
    __privateAdd(this, _insert);
    __privateAdd(this, _remove);
    __privateAdd(this, _breakEdge);
    __privateAdd(this, _box3, void 0);
    __privateAdd(this, _lastPoint, void 0);
    __privateAdd(this, _verticalEdges, []);
    __privateAdd(this, _intervals, []);
    const minMax = [Infinity, Infinity, -Infinity, -Infinity];
    const NUMBER_OF_DIGITS = 4;
    const EPSILON = 10 ** -NUMBER_OF_DIGITS;
    for (const {
      x,
      y,
      width,
      height
    } of boxes) {
      const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;
      const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;
      const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;
      const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;
      const left = [x1, y1, y2, true];
      const right = [x2, y1, y2, false];
      __privateGet(this, _verticalEdges).push(left, right);
      Util.rectBoundingBox(x1, y1, x2, y2, minMax);
    }
    const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;
    const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;
    const shiftedMinX = minMax[0] - innerMargin;
    const shiftedMinY = minMax[1] - innerMargin;
    const lastEdge = __privateGet(this, _verticalEdges).at(isLTR ? -1 : -2);
    const lastPoint = [lastEdge[0], lastEdge[2]];
    for (const edge of __privateGet(this, _verticalEdges)) {
      const [x, y1, y2] = edge;
      edge[0] = (x - shiftedMinX) / bboxWidth;
      edge[1] = (y1 - shiftedMinY) / bboxHeight;
      edge[2] = (y2 - shiftedMinY) / bboxHeight;
    }
    __privateSet(this, _box3, new Float32Array([shiftedMinX, shiftedMinY, bboxWidth, bboxHeight]));
    __privateSet(this, _lastPoint, lastPoint);
  }
  getOutlines() {
    __privateGet(this, _verticalEdges).sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);
    const outlineVerticalEdges = [];
    for (const edge of __privateGet(this, _verticalEdges)) {
      if (edge[3]) {
        outlineVerticalEdges.push(...__privateMethod(this, _breakEdge, breakEdge_fn).call(this, edge));
        __privateMethod(this, _insert, insert_fn).call(this, edge);
      } else {
        __privateMethod(this, _remove, remove_fn).call(this, edge);
        outlineVerticalEdges.push(...__privateMethod(this, _breakEdge, breakEdge_fn).call(this, edge));
      }
    }
    return __privateMethod(this, _getOutlines, getOutlines_fn).call(this, outlineVerticalEdges);
  }
};
_box3 = new WeakMap();
_lastPoint = new WeakMap();
_verticalEdges = new WeakMap();
_intervals = new WeakMap();
_getOutlines = new WeakSet();
getOutlines_fn = function(outlineVerticalEdges) {
  const edges = [];
  const allEdges = /* @__PURE__ */ new Set();
  for (const edge of outlineVerticalEdges) {
    const [x, y1, y2] = edge;
    edges.push([x, y1, edge], [x, y2, edge]);
  }
  edges.sort((a, b) => a[1] - b[1] || a[0] - b[0]);
  for (let i = 0, ii = edges.length; i < ii; i += 2) {
    const edge1 = edges[i][2];
    const edge2 = edges[i + 1][2];
    edge1.push(edge2);
    edge2.push(edge1);
    allEdges.add(edge1);
    allEdges.add(edge2);
  }
  const outlines = [];
  let outline;
  while (allEdges.size > 0) {
    const edge = allEdges.values().next().value;
    let [x, y1, y2, edge1, edge2] = edge;
    allEdges.delete(edge);
    let lastPointX = x;
    let lastPointY = y1;
    outline = [x, y2];
    outlines.push(outline);
    while (true) {
      let e;
      if (allEdges.has(edge1)) {
        e = edge1;
      } else if (allEdges.has(edge2)) {
        e = edge2;
      } else {
        break;
      }
      allEdges.delete(e);
      [x, y1, y2, edge1, edge2] = e;
      if (lastPointX !== x) {
        outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);
        lastPointX = x;
      }
      lastPointY = lastPointY === y1 ? y2 : y1;
    }
    outline.push(lastPointX, lastPointY);
  }
  return new HighlightOutline(outlines, __privateGet(this, _box3), __privateGet(this, _lastPoint));
};
_binarySearch = new WeakSet();
binarySearch_fn = function(y) {
  const array = __privateGet(this, _intervals);
  let start = 0;
  let end = array.length - 1;
  while (start <= end) {
    const middle = start + end >> 1;
    const y1 = array[middle][0];
    if (y1 === y) {
      return middle;
    }
    if (y1 < y) {
      start = middle + 1;
    } else {
      end = middle - 1;
    }
  }
  return end + 1;
};
_insert = new WeakSet();
insert_fn = function([, y1, y2]) {
  const index = __privateMethod(this, _binarySearch, binarySearch_fn).call(this, y1);
  __privateGet(this, _intervals).splice(index, 0, [y1, y2]);
};
_remove = new WeakSet();
remove_fn = function([, y1, y2]) {
  const index = __privateMethod(this, _binarySearch, binarySearch_fn).call(this, y1);
  for (let i = index; i < __privateGet(this, _intervals).length; i++) {
    const [start, end] = __privateGet(this, _intervals)[i];
    if (start !== y1) {
      break;
    }
    if (start === y1 && end === y2) {
      __privateGet(this, _intervals).splice(i, 1);
      return;
    }
  }
  for (let i = index - 1; i >= 0; i--) {
    const [start, end] = __privateGet(this, _intervals)[i];
    if (start !== y1) {
      break;
    }
    if (start === y1 && end === y2) {
      __privateGet(this, _intervals).splice(i, 1);
      return;
    }
  }
};
_breakEdge = new WeakSet();
breakEdge_fn = function(edge) {
  const [x, y1, y2] = edge;
  const results = [[x, y1, y2]];
  const index = __privateMethod(this, _binarySearch, binarySearch_fn).call(this, y2);
  for (let i = 0; i < index; i++) {
    const [start, end] = __privateGet(this, _intervals)[i];
    for (let j = 0, jj = results.length; j < jj; j++) {
      const [, y3, y4] = results[j];
      if (end <= y3 || y4 <= start) {
        continue;
      }
      if (y3 >= start) {
        if (y4 > end) {
          results[j][1] = end;
        } else {
          if (jj === 1) {
            return [];
          }
          results.splice(j, 1);
          j--;
          jj--;
        }
        continue;
      }
      results[j][2] = start;
      if (y4 > end) {
        results.push([x, end, y4]);
      }
    }
  }
  return results;
};
var _box4, _outlines;
var HighlightOutline = class extends Outline {
  constructor(outlines, box, lastPoint) {
    super();
    __privateAdd(this, _box4, void 0);
    __privateAdd(this, _outlines, void 0);
    __privateSet(this, _outlines, outlines);
    __privateSet(this, _box4, box);
    this.lastPoint = lastPoint;
  }
  toSVGPath() {
    const buffer = [];
    for (const polygon of __privateGet(this, _outlines)) {
      let [prevX, prevY] = polygon;
      buffer.push(`M${prevX} ${prevY}`);
      for (let i = 2; i < polygon.length; i += 2) {
        const x = polygon[i];
        const y = polygon[i + 1];
        if (x === prevX) {
          buffer.push(`V${y}`);
          prevY = y;
        } else if (y === prevY) {
          buffer.push(`H${x}`);
          prevX = x;
        }
      }
      buffer.push("Z");
    }
    return buffer.join(" ");
  }
  serialize([blX, blY, trX, trY], _rotation4) {
    const outlines = [];
    const width = trX - blX;
    const height = trY - blY;
    for (const outline of __privateGet(this, _outlines)) {
      const points = new Array(outline.length);
      for (let i = 0; i < outline.length; i += 2) {
        points[i] = blX + outline[i] * width;
        points[i + 1] = trY - outline[i + 1] * height;
      }
      outlines.push(points);
    }
    return outlines;
  }
  get box() {
    return __privateGet(this, _box4);
  }
  get classNamesForOutlining() {
    return ["highlightOutline"];
  }
};
_box4 = new WeakMap();
_outlines = new WeakMap();
var FreeHighlightOutliner = class extends FreeDrawOutliner {
  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
    return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
  }
};
var FreeHighlightOutline = class extends FreeDrawOutline {
  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
    return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
  }
};
var _anchorNode, _anchorOffset, _boxes, _clipPathId, _colorPicker2, _focusOutlines, _focusNode, _focusOffset, _highlightDiv, _highlightOutlines, _id4, _isFreeHighlight, _lastPoint2, _opacity, _outlineId, _text2, _thickness2, _methodOfCreation, _createOutlines, createOutlines_fn, _createFreeOutlines, createFreeOutlines_fn, _updateColor2, updateColor_fn2, _updateThickness, updateThickness_fn, _changeThickness, changeThickness_fn, _cleanDrawLayer, cleanDrawLayer_fn, _addToDrawLayer, addToDrawLayer_fn, _rotateBbox, rotateBbox_fn, _keydown, keydown_fn, _setCaret, setCaret_fn, _getRotation, getRotation_fn, _serializeBoxes, serializeBoxes_fn, _serializeOutlines, serializeOutlines_fn, _highlightMove, highlightMove_fn, _endHighlight, endHighlight_fn, _hasElementChanged2, hasElementChanged_fn2;
var _HighlightEditor = class _HighlightEditor extends AnnotationEditor {
  constructor(params) {
    super({
      ...params,
      name: "highlightEditor"
    });
    __privateAdd(this, _createOutlines);
    __privateAdd(this, _createFreeOutlines);
    __privateAdd(this, _updateColor2);
    __privateAdd(this, _updateThickness);
    __privateAdd(this, _changeThickness);
    __privateAdd(this, _cleanDrawLayer);
    __privateAdd(this, _addToDrawLayer);
    __privateAdd(this, _keydown);
    __privateAdd(this, _setCaret);
    __privateAdd(this, _getRotation);
    __privateAdd(this, _serializeBoxes);
    __privateAdd(this, _serializeOutlines);
    __privateAdd(this, _hasElementChanged2);
    __privateAdd(this, _anchorNode, null);
    __privateAdd(this, _anchorOffset, 0);
    __privateAdd(this, _boxes, void 0);
    __privateAdd(this, _clipPathId, null);
    __privateAdd(this, _colorPicker2, null);
    __privateAdd(this, _focusOutlines, null);
    __privateAdd(this, _focusNode, null);
    __privateAdd(this, _focusOffset, 0);
    __privateAdd(this, _highlightDiv, null);
    __privateAdd(this, _highlightOutlines, null);
    __privateAdd(this, _id4, null);
    __privateAdd(this, _isFreeHighlight, false);
    __privateAdd(this, _lastPoint2, null);
    __privateAdd(this, _opacity, void 0);
    __privateAdd(this, _outlineId, null);
    __privateAdd(this, _text2, "");
    __privateAdd(this, _thickness2, void 0);
    __privateAdd(this, _methodOfCreation, "");
    this.color = params.color || _HighlightEditor._defaultColor;
    __privateSet(this, _thickness2, params.thickness || _HighlightEditor._defaultThickness);
    __privateSet(this, _opacity, params.opacity || _HighlightEditor._defaultOpacity);
    __privateSet(this, _boxes, params.boxes || null);
    __privateSet(this, _methodOfCreation, params.methodOfCreation || "");
    __privateSet(this, _text2, params.text || "");
    this._isDraggable = false;
    this.defaultL10nId = "pdfjs-editor-highlight-editor";
    if (params.highlightId > -1) {
      __privateSet(this, _isFreeHighlight, true);
      __privateMethod(this, _createFreeOutlines, createFreeOutlines_fn).call(this, params);
      __privateMethod(this, _addToDrawLayer, addToDrawLayer_fn).call(this);
    } else if (__privateGet(this, _boxes)) {
      __privateSet(this, _anchorNode, params.anchorNode);
      __privateSet(this, _anchorOffset, params.anchorOffset);
      __privateSet(this, _focusNode, params.focusNode);
      __privateSet(this, _focusOffset, params.focusOffset);
      __privateMethod(this, _createOutlines, createOutlines_fn).call(this);
      __privateMethod(this, _addToDrawLayer, addToDrawLayer_fn).call(this);
      this.rotate(this.rotation);
    }
    if (!this.annotationElementId) {
      this._uiManager.a11yAlert("pdfjs-editor-highlight-added-alert");
    }
  }
  static get _keyboardManager() {
    const proto = _HighlightEditor.prototype;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], proto._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], proto._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], proto._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], proto._moveCaret, {
      args: [3]
    }]]));
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: __privateGet(this, _isFreeHighlight) ? "free_highlight" : "highlight",
      color: this._uiManager.getNonHCMColorName(this.color),
      thickness: __privateGet(this, _thickness2),
      methodOfCreation: __privateGet(this, _methodOfCreation)
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.getNonHCMColorName(this.color)
    };
  }
  get commentColor() {
    return this.color;
  }
  static computeTelemetryFinalData(data) {
    return {
      numberOfColors: data.get("color").size
    };
  }
  static initialize(l10n, uiManager) {
    var _a3;
    AnnotationEditor.initialize(l10n, uiManager);
    _HighlightEditor._defaultColor || (_HighlightEditor._defaultColor = ((_a3 = uiManager.highlightColors) == null ? void 0 : _a3.values().next().value) || "#fff066");
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
        _HighlightEditor._defaultColor = value;
        break;
      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
        _HighlightEditor._defaultThickness = value;
        break;
    }
  }
  translateInPage(x, y) {
  }
  get toolbarPosition() {
    return __privateGet(this, _lastPoint2);
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
        __privateMethod(this, _updateColor2, updateColor_fn2).call(this, value);
        break;
      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
        __privateMethod(this, _updateThickness, updateThickness_fn).call(this, value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, _HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, _HighlightEditor._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.color || _HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, __privateGet(this, _thickness2) || _HighlightEditor._defaultThickness], [AnnotationEditorParamsType.HIGHLIGHT_FREE, __privateGet(this, _isFreeHighlight)]];
  }
  get toolbarButtons() {
    if (this._uiManager.highlightColors) {
      const colorPicker = __privateSet(this, _colorPicker2, new ColorPicker({
        editor: this
      }));
      return [["colorPicker", colorPicker]];
    }
    return super.toolbarButtons;
  }
  disableEditing() {
    super.disableEditing();
    this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing();
    this.div.classList.toggle("disabled", false);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(__privateMethod(this, _getRotation, getRotation_fn).call(this));
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(tx, ty) {
    return super.getRect(tx, ty, __privateMethod(this, _getRotation, getRotation_fn).call(this));
  }
  onceAdded(focus) {
    if (!this.annotationElementId) {
      this.parent.addUndoableEditor(this);
    }
    if (focus) {
      this.div.focus();
    }
  }
  remove() {
    __privateMethod(this, _cleanDrawLayer, cleanDrawLayer_fn).call(this);
    this._reportTelemetry({
      action: "deleted"
    });
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    __privateMethod(this, _addToDrawLayer, addToDrawLayer_fn).call(this);
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  setParent(parent) {
    var _a3;
    let mustBeSelected = false;
    if (this.parent && !parent) {
      __privateMethod(this, _cleanDrawLayer, cleanDrawLayer_fn).call(this);
    } else if (parent) {
      __privateMethod(this, _addToDrawLayer, addToDrawLayer_fn).call(this, parent);
      mustBeSelected = !this.parent && ((_a3 = this.div) == null ? void 0 : _a3.classList.contains("selectedEditor"));
    }
    super.setParent(parent);
    this.show(this._isVisible);
    if (mustBeSelected) {
      this.select();
    }
  }
  rotate(angle) {
    var _a3, _b2, _c;
    const {
      drawLayer
    } = this.parent;
    let box;
    if (__privateGet(this, _isFreeHighlight)) {
      angle = (angle - this.rotation + 360) % 360;
      box = __privateMethod(_a3 = _HighlightEditor, _rotateBbox, rotateBbox_fn).call(_a3, __privateGet(this, _highlightOutlines).box, angle);
    } else {
      box = __privateMethod(_b2 = _HighlightEditor, _rotateBbox, rotateBbox_fn).call(_b2, [this.x, this.y, this.width, this.height], angle);
    }
    drawLayer.updateProperties(__privateGet(this, _id4), {
      bbox: box,
      root: {
        "data-main-rotation": angle
      }
    });
    drawLayer.updateProperties(__privateGet(this, _outlineId), {
      bbox: __privateMethod(_c = _HighlightEditor, _rotateBbox, rotateBbox_fn).call(_c, __privateGet(this, _focusOutlines).box, angle),
      root: {
        "data-main-rotation": angle
      }
    });
  }
  render() {
    if (this.div) {
      return this.div;
    }
    const div = super.render();
    if (__privateGet(this, _text2)) {
      div.setAttribute("aria-label", __privateGet(this, _text2));
      div.setAttribute("role", "mark");
    }
    if (__privateGet(this, _isFreeHighlight)) {
      div.classList.add("free");
    } else {
      this.div.addEventListener("keydown", __privateMethod(this, _keydown, keydown_fn).bind(this), {
        signal: this._uiManager._signal
      });
    }
    const highlightDiv = __privateSet(this, _highlightDiv, document.createElement("div"));
    div.append(highlightDiv);
    highlightDiv.setAttribute("aria-hidden", "true");
    highlightDiv.className = "internal";
    highlightDiv.style.clipPath = __privateGet(this, _clipPathId);
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setDims(this.width * parentWidth, this.height * parentHeight);
    bindEvents(this, __privateGet(this, _highlightDiv), ["pointerover", "pointerleave"]);
    this.enableEditing();
    return div;
  }
  pointerover() {
    var _a3;
    if (!this.isSelected) {
      (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(__privateGet(this, _outlineId), {
        rootClass: {
          hovered: true
        }
      });
    }
  }
  pointerleave() {
    var _a3;
    if (!this.isSelected) {
      (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(__privateGet(this, _outlineId), {
        rootClass: {
          hovered: false
        }
      });
    }
  }
  _moveCaret(direction) {
    this.parent.unselect(this);
    switch (direction) {
      case 0:
      case 2:
        __privateMethod(this, _setCaret, setCaret_fn).call(this, true);
        break;
      case 1:
      case 3:
        __privateMethod(this, _setCaret, setCaret_fn).call(this, false);
        break;
    }
  }
  select() {
    var _a3;
    super.select();
    if (!__privateGet(this, _outlineId)) {
      return;
    }
    (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(__privateGet(this, _outlineId), {
      rootClass: {
        hovered: false,
        selected: true
      }
    });
  }
  unselect() {
    var _a3;
    super.unselect();
    if (!__privateGet(this, _outlineId)) {
      return;
    }
    (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(__privateGet(this, _outlineId), {
      rootClass: {
        selected: false
      }
    });
    if (!__privateGet(this, _isFreeHighlight)) {
      __privateMethod(this, _setCaret, setCaret_fn).call(this, false);
    }
  }
  get _mustFixPosition() {
    return !__privateGet(this, _isFreeHighlight);
  }
  show(visible = this._isVisible) {
    super.show(visible);
    if (this.parent) {
      this.parent.drawLayer.updateProperties(__privateGet(this, _id4), {
        rootClass: {
          hidden: !visible
        }
      });
      this.parent.drawLayer.updateProperties(__privateGet(this, _outlineId), {
        rootClass: {
          hidden: !visible
        }
      });
    }
  }
  static startHighlighting(parent, isLTR, {
    target: textLayer,
    x,
    y
  }) {
    const {
      x: layerX,
      y: layerY,
      width: parentWidth,
      height: parentHeight
    } = textLayer.getBoundingClientRect();
    const ac = new AbortController();
    const signal = parent.combinedSignal(ac);
    const pointerUpCallback = (e) => {
      ac.abort();
      __privateMethod(this, _endHighlight, endHighlight_fn).call(this, parent, e);
    };
    window.addEventListener("blur", pointerUpCallback, {
      signal
    });
    window.addEventListener("pointerup", pointerUpCallback, {
      signal
    });
    window.addEventListener("pointerdown", stopEvent, {
      capture: true,
      passive: false,
      signal
    });
    window.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    textLayer.addEventListener("pointermove", __privateMethod(this, _highlightMove, highlightMove_fn).bind(this, parent), {
      signal
    });
    this._freeHighlight = new FreeHighlightOutliner({
      x,
      y
    }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 1e-3);
    ({
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = parent.drawLayer.draw({
      bbox: [0, 0, 1, 1],
      root: {
        viewBox: "0 0 1 1",
        fill: this._defaultColor,
        "fill-opacity": this._defaultOpacity
      },
      rootClass: {
        highlight: true,
        free: true
      },
      path: {
        d: this._freeHighlight.toSVGPath()
      }
    }, true, true));
  }
  static async deserialize(data, parent, uiManager) {
    var _a3, _b2, _c, _d;
    let initialData = null;
    if (data instanceof HighlightAnnotationElement) {
      const {
        data: {
          quadPoints: quadPoints2,
          rect,
          rotation,
          id,
          color: color2,
          opacity: opacity2,
          popupRef,
          contentsObj
        },
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      initialData = data = {
        annotationType: AnnotationEditorType.HIGHLIGHT,
        color: Array.from(color2),
        opacity: opacity2,
        quadPoints: quadPoints2,
        boxes: null,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        comment: (contentsObj == null ? void 0 : contentsObj.str) || null
      };
    } else if (data instanceof InkAnnotationElement) {
      const {
        data: {
          inkLists: inkLists2,
          rect,
          rotation,
          id,
          color: color2,
          borderStyle: {
            rawWidth: thickness
          },
          popupRef,
          contentsObj
        },
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      initialData = data = {
        annotationType: AnnotationEditorType.HIGHLIGHT,
        color: Array.from(color2),
        thickness,
        inkLists: inkLists2,
        boxes: null,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        comment: (contentsObj == null ? void 0 : contentsObj.str) || null
      };
    }
    const {
      color,
      quadPoints,
      inkLists,
      opacity
    } = data;
    const editor = await super.deserialize(data, parent, uiManager);
    editor.color = Util.makeHexColor(...color);
    __privateSet(editor, _opacity, opacity || 1);
    if (inkLists) {
      __privateSet(editor, _thickness2, data.thickness);
    }
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data.comment);
    }
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const [pageX, pageY] = editor.pageTranslation;
    if (quadPoints) {
      const boxes = __privateSet(editor, _boxes, []);
      for (let i = 0; i < quadPoints.length; i += 8) {
        boxes.push({
          x: (quadPoints[i] - pageX) / pageWidth,
          y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,
          width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,
          height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight
        });
      }
      __privateMethod(_a3 = editor, _createOutlines, createOutlines_fn).call(_a3);
      __privateMethod(_b2 = editor, _addToDrawLayer, addToDrawLayer_fn).call(_b2);
      editor.rotate(editor.rotation);
    } else if (inkLists) {
      __privateSet(editor, _isFreeHighlight, true);
      const points = inkLists[0];
      const point = {
        x: points[0] - pageX,
        y: pageHeight - (points[1] - pageY)
      };
      const outliner = new FreeHighlightOutliner(point, [0, 0, pageWidth, pageHeight], 1, __privateGet(editor, _thickness2) / 2, true, 1e-3);
      for (let i = 0, ii = points.length; i < ii; i += 2) {
        point.x = points[i] - pageX;
        point.y = pageHeight - (points[i + 1] - pageY);
        outliner.add(point);
      }
      const {
        id,
        clipPathId
      } = parent.drawLayer.draw({
        bbox: [0, 0, 1, 1],
        root: {
          viewBox: "0 0 1 1",
          fill: editor.color,
          "fill-opacity": editor._defaultOpacity
        },
        rootClass: {
          highlight: true,
          free: true
        },
        path: {
          d: outliner.toSVGPath()
        }
      }, true, true);
      __privateMethod(_c = editor, _createFreeOutlines, createFreeOutlines_fn).call(_c, {
        highlightOutlines: outliner.getOutlines(),
        highlightId: id,
        clipPathId
      });
      __privateMethod(_d = editor, _addToDrawLayer, addToDrawLayer_fn).call(_d);
      editor.rotate(editor.parentRotation);
    }
    return editor;
  }
  serialize(isForCopying = false) {
    if (this.isEmpty() || isForCopying) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const rect = this.getPDFRect();
    const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
    const serialized = {
      annotationType: AnnotationEditorType.HIGHLIGHT,
      color,
      opacity: __privateGet(this, _opacity),
      thickness: __privateGet(this, _thickness2),
      quadPoints: __privateMethod(this, _serializeBoxes, serializeBoxes_fn).call(this),
      outlines: __privateMethod(this, _serializeOutlines, serializeOutlines_fn).call(this, rect),
      pageIndex: this.pageIndex,
      rect,
      rotation: __privateMethod(this, _getRotation, getRotation_fn).call(this),
      structTreeParentId: this._structTreeParentId
    };
    this.addComment(serialized);
    if (this.annotationElementId && !__privateMethod(this, _hasElementChanged2, hasElementChanged_fn2).call(this, serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    const params = {
      rect: this.getPDFRect()
    };
    if (this.hasEditedComment) {
      params.popup = this.comment;
    }
    annotation.updateEdited(params);
    return null;
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
};
_anchorNode = new WeakMap();
_anchorOffset = new WeakMap();
_boxes = new WeakMap();
_clipPathId = new WeakMap();
_colorPicker2 = new WeakMap();
_focusOutlines = new WeakMap();
_focusNode = new WeakMap();
_focusOffset = new WeakMap();
_highlightDiv = new WeakMap();
_highlightOutlines = new WeakMap();
_id4 = new WeakMap();
_isFreeHighlight = new WeakMap();
_lastPoint2 = new WeakMap();
_opacity = new WeakMap();
_outlineId = new WeakMap();
_text2 = new WeakMap();
_thickness2 = new WeakMap();
_methodOfCreation = new WeakMap();
_createOutlines = new WeakSet();
createOutlines_fn = function() {
  const outliner = new HighlightOutliner(__privateGet(this, _boxes), 1e-3);
  __privateSet(this, _highlightOutlines, outliner.getOutlines());
  [this.x, this.y, this.width, this.height] = __privateGet(this, _highlightOutlines).box;
  const outlinerForOutline = new HighlightOutliner(__privateGet(this, _boxes), 25e-4, 1e-3, this._uiManager.direction === "ltr");
  __privateSet(this, _focusOutlines, outlinerForOutline.getOutlines());
  const {
    lastPoint
  } = __privateGet(this, _focusOutlines);
  __privateSet(this, _lastPoint2, [(lastPoint[0] - this.x) / this.width, (lastPoint[1] - this.y) / this.height]);
};
_createFreeOutlines = new WeakSet();
createFreeOutlines_fn = function({
  highlightOutlines,
  highlightId,
  clipPathId
}) {
  var _a3, _b2;
  __privateSet(this, _highlightOutlines, highlightOutlines);
  const extraThickness = 1.5;
  __privateSet(this, _focusOutlines, highlightOutlines.getNewOutline(__privateGet(this, _thickness2) / 2 + extraThickness, 25e-4));
  if (highlightId >= 0) {
    __privateSet(this, _id4, highlightId);
    __privateSet(this, _clipPathId, clipPathId);
    this.parent.drawLayer.finalizeDraw(highlightId, {
      bbox: highlightOutlines.box,
      path: {
        d: highlightOutlines.toSVGPath()
      }
    });
    __privateSet(this, _outlineId, this.parent.drawLayer.drawOutline({
      rootClass: {
        highlightOutline: true,
        free: true
      },
      bbox: __privateGet(this, _focusOutlines).box,
      path: {
        d: __privateGet(this, _focusOutlines).toSVGPath()
      }
    }, true));
  } else if (this.parent) {
    const angle = this.parent.viewport.rotation;
    this.parent.drawLayer.updateProperties(__privateGet(this, _id4), {
      bbox: __privateMethod(_a3 = _HighlightEditor, _rotateBbox, rotateBbox_fn).call(_a3, __privateGet(this, _highlightOutlines).box, (angle - this.rotation + 360) % 360),
      path: {
        d: highlightOutlines.toSVGPath()
      }
    });
    this.parent.drawLayer.updateProperties(__privateGet(this, _outlineId), {
      bbox: __privateMethod(_b2 = _HighlightEditor, _rotateBbox, rotateBbox_fn).call(_b2, __privateGet(this, _focusOutlines).box, angle),
      path: {
        d: __privateGet(this, _focusOutlines).toSVGPath()
      }
    });
  }
  const [x, y, width, height] = highlightOutlines.box;
  switch (this.rotation) {
    case 0:
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      break;
    case 90: {
      const [pageWidth, pageHeight] = this.parentDimensions;
      this.x = y;
      this.y = 1 - x;
      this.width = width * pageHeight / pageWidth;
      this.height = height * pageWidth / pageHeight;
      break;
    }
    case 180:
      this.x = 1 - x;
      this.y = 1 - y;
      this.width = width;
      this.height = height;
      break;
    case 270: {
      const [pageWidth, pageHeight] = this.parentDimensions;
      this.x = 1 - y;
      this.y = x;
      this.width = width * pageHeight / pageWidth;
      this.height = height * pageWidth / pageHeight;
      break;
    }
  }
  const {
    lastPoint
  } = __privateGet(this, _focusOutlines);
  __privateSet(this, _lastPoint2, [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height]);
};
_updateColor2 = new WeakSet();
updateColor_fn2 = function(color) {
  const setColorAndOpacity = (col, opa) => {
    var _a3, _b2;
    this.color = col;
    __privateSet(this, _opacity, opa);
    (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(__privateGet(this, _id4), {
      root: {
        fill: col,
        "fill-opacity": opa
      }
    });
    (_b2 = __privateGet(this, _colorPicker2)) == null ? void 0 : _b2.updateColor(col);
  };
  const savedColor = this.color;
  const savedOpacity = __privateGet(this, _opacity);
  this.addCommands({
    cmd: setColorAndOpacity.bind(this, color, _HighlightEditor._defaultOpacity),
    undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: true,
    type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
    overwriteIfSameType: true,
    keepUndo: true
  });
  this._reportTelemetry({
    action: "color_changed",
    color: this._uiManager.getNonHCMColorName(color)
  }, true);
};
_updateThickness = new WeakSet();
updateThickness_fn = function(thickness) {
  const savedThickness = __privateGet(this, _thickness2);
  const setThickness = (th) => {
    __privateSet(this, _thickness2, th);
    __privateMethod(this, _changeThickness, changeThickness_fn).call(this, th);
  };
  this.addCommands({
    cmd: setThickness.bind(this, thickness),
    undo: setThickness.bind(this, savedThickness),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: true,
    type: AnnotationEditorParamsType.INK_THICKNESS,
    overwriteIfSameType: true,
    keepUndo: true
  });
  this._reportTelemetry({
    action: "thickness_changed",
    thickness
  }, true);
};
_changeThickness = new WeakSet();
changeThickness_fn = function(thickness) {
  if (!__privateGet(this, _isFreeHighlight)) {
    return;
  }
  __privateMethod(this, _createFreeOutlines, createFreeOutlines_fn).call(this, {
    highlightOutlines: __privateGet(this, _highlightOutlines).getNewOutline(thickness / 2)
  });
  this.fixAndSetPosition();
  const [parentWidth, parentHeight] = this.parentDimensions;
  this.setDims(this.width * parentWidth, this.height * parentHeight);
};
_cleanDrawLayer = new WeakSet();
cleanDrawLayer_fn = function() {
  if (__privateGet(this, _id4) === null || !this.parent) {
    return;
  }
  this.parent.drawLayer.remove(__privateGet(this, _id4));
  __privateSet(this, _id4, null);
  this.parent.drawLayer.remove(__privateGet(this, _outlineId));
  __privateSet(this, _outlineId, null);
};
_addToDrawLayer = new WeakSet();
addToDrawLayer_fn = function(parent = this.parent) {
  if (__privateGet(this, _id4) !== null) {
    return;
  }
  ({
    id: __privateWrapper(this, _id4)._,
    clipPathId: __privateWrapper(this, _clipPathId)._
  } = parent.drawLayer.draw({
    bbox: __privateGet(this, _highlightOutlines).box,
    root: {
      viewBox: "0 0 1 1",
      fill: this.color,
      "fill-opacity": __privateGet(this, _opacity)
    },
    rootClass: {
      highlight: true,
      free: __privateGet(this, _isFreeHighlight)
    },
    path: {
      d: __privateGet(this, _highlightOutlines).toSVGPath()
    }
  }, false, true));
  __privateSet(this, _outlineId, parent.drawLayer.drawOutline({
    rootClass: {
      highlightOutline: true,
      free: __privateGet(this, _isFreeHighlight)
    },
    bbox: __privateGet(this, _focusOutlines).box,
    path: {
      d: __privateGet(this, _focusOutlines).toSVGPath()
    }
  }, __privateGet(this, _isFreeHighlight)));
  if (__privateGet(this, _highlightDiv)) {
    __privateGet(this, _highlightDiv).style.clipPath = __privateGet(this, _clipPathId);
  }
};
_rotateBbox = new WeakSet();
rotateBbox_fn = function([x, y, width, height], angle) {
  switch (angle) {
    case 90:
      return [1 - y - height, x, height, width];
    case 180:
      return [1 - x - width, 1 - y - height, width, height];
    case 270:
      return [y, 1 - x - width, height, width];
  }
  return [x, y, width, height];
};
_keydown = new WeakSet();
keydown_fn = function(event) {
  _HighlightEditor._keyboardManager.exec(this, event);
};
_setCaret = new WeakSet();
setCaret_fn = function(start) {
  if (!__privateGet(this, _anchorNode)) {
    return;
  }
  const selection2 = window.getSelection();
  if (start) {
    selection2.setPosition(__privateGet(this, _anchorNode), __privateGet(this, _anchorOffset));
  } else {
    selection2.setPosition(__privateGet(this, _focusNode), __privateGet(this, _focusOffset));
  }
};
_getRotation = new WeakSet();
getRotation_fn = function() {
  return __privateGet(this, _isFreeHighlight) ? this.rotation : 0;
};
_serializeBoxes = new WeakSet();
serializeBoxes_fn = function() {
  if (__privateGet(this, _isFreeHighlight)) {
    return null;
  }
  const [pageWidth, pageHeight] = this.pageDimensions;
  const [pageX, pageY] = this.pageTranslation;
  const boxes = __privateGet(this, _boxes);
  const quadPoints = new Float32Array(boxes.length * 8);
  let i = 0;
  for (const {
    x,
    y,
    width,
    height
  } of boxes) {
    const sx = x * pageWidth + pageX;
    const sy = (1 - y) * pageHeight + pageY;
    quadPoints[i] = quadPoints[i + 4] = sx;
    quadPoints[i + 1] = quadPoints[i + 3] = sy;
    quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;
    quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;
    i += 8;
  }
  return quadPoints;
};
_serializeOutlines = new WeakSet();
serializeOutlines_fn = function(rect) {
  return __privateGet(this, _highlightOutlines).serialize(rect, __privateMethod(this, _getRotation, getRotation_fn).call(this));
};
_highlightMove = new WeakSet();
highlightMove_fn = function(parent, event) {
  if (this._freeHighlight.add(event)) {
    parent.drawLayer.updateProperties(this._freeHighlightId, {
      path: {
        d: this._freeHighlight.toSVGPath()
      }
    });
  }
};
_endHighlight = new WeakSet();
endHighlight_fn = function(parent, event) {
  if (!this._freeHighlight.isEmpty()) {
    parent.createAndAddNewEditor(event, false, {
      highlightId: this._freeHighlightId,
      highlightOutlines: this._freeHighlight.getOutlines(),
      clipPathId: this._freeHighlightClipId,
      methodOfCreation: "main_toolbar"
    });
  } else {
    parent.drawLayer.remove(this._freeHighlightId);
  }
  this._freeHighlightId = -1;
  this._freeHighlight = null;
  this._freeHighlightClipId = "";
};
_hasElementChanged2 = new WeakSet();
hasElementChanged_fn2 = function(serialized) {
  const {
    color
  } = this._initialData;
  return this.hasEditedComment || serialized.color.some((c, i) => c !== color[i]);
};
__privateAdd(_HighlightEditor, _rotateBbox);
__privateAdd(_HighlightEditor, _highlightMove);
__privateAdd(_HighlightEditor, _endHighlight);
__publicField(_HighlightEditor, "_defaultColor", null);
__publicField(_HighlightEditor, "_defaultOpacity", 1);
__publicField(_HighlightEditor, "_defaultThickness", 12);
__publicField(_HighlightEditor, "_type", "highlight");
__publicField(_HighlightEditor, "_editorType", AnnotationEditorType.HIGHLIGHT);
__publicField(_HighlightEditor, "_freeHighlightId", -1);
__publicField(_HighlightEditor, "_freeHighlight", null);
__publicField(_HighlightEditor, "_freeHighlightClipId", "");
var HighlightEditor = _HighlightEditor;
var _svgProperties;
var DrawingOptions = class {
  constructor() {
    __privateAdd(this, _svgProperties, /* @__PURE__ */ Object.create(null));
  }
  updateProperty(name, value) {
    this[name] = value;
    this.updateSVGProperty(name, value);
  }
  updateProperties(properties) {
    if (!properties) {
      return;
    }
    for (const [name, value] of Object.entries(properties)) {
      if (!name.startsWith("_")) {
        this.updateProperty(name, value);
      }
    }
  }
  updateSVGProperty(name, value) {
    __privateGet(this, _svgProperties)[name] = value;
  }
  toSVGProperties() {
    const root = __privateGet(this, _svgProperties);
    __privateSet(this, _svgProperties, /* @__PURE__ */ Object.create(null));
    return {
      root
    };
  }
  reset() {
    __privateSet(this, _svgProperties, /* @__PURE__ */ Object.create(null));
  }
  updateAll(options = this) {
    this.updateProperties(options);
  }
  clone() {
    unreachable("Not implemented");
  }
};
_svgProperties = new WeakMap();
var _drawOutlines, _mustBeCommitted, _currentDraw, _currentDrawingAC, _currentDrawingOptions, _currentPointerId, _currentPointerType, _currentPointerIds, _currentMoveTimestamp, _createDrawOutlines, createDrawOutlines_fn, _createDrawing, createDrawing_fn, _cleanDrawLayer2, cleanDrawLayer_fn2, _addToDrawLayer2, addToDrawLayer_fn2, _convertToParentSpace, convertToParentSpace_fn, _convertToDrawSpace, convertToDrawSpace_fn, _updateBbox, updateBbox_fn, _rotateBox, rotateBox_fn;
var _DrawingEditor = class _DrawingEditor extends AnnotationEditor {
  constructor(params) {
    super(params);
    __privateAdd(this, _createDrawOutlines);
    __privateAdd(this, _createDrawing);
    __privateAdd(this, _cleanDrawLayer2);
    __privateAdd(this, _addToDrawLayer2);
    __privateAdd(this, _convertToParentSpace);
    __privateAdd(this, _convertToDrawSpace);
    __privateAdd(this, _updateBbox);
    __privateAdd(this, _rotateBox);
    __privateAdd(this, _drawOutlines, null);
    __privateAdd(this, _mustBeCommitted, void 0);
    __publicField(this, "_colorPicker", null);
    __publicField(this, "_drawId", null);
    __privateSet(this, _mustBeCommitted, params.mustBeCommitted || false);
    this._addOutlines(params);
  }
  _addOutlines(params) {
    if (params.drawOutlines) {
      __privateMethod(this, _createDrawOutlines, createDrawOutlines_fn).call(this, params);
      __privateMethod(this, _addToDrawLayer2, addToDrawLayer_fn2).call(this);
    }
  }
  static _mergeSVGProperties(p1, p2) {
    const p1Keys = new Set(Object.keys(p1));
    for (const [key, value] of Object.entries(p2)) {
      if (p1Keys.has(key)) {
        Object.assign(p1[key], value);
      } else {
        p1[key] = value;
      }
    }
    return p1;
  }
  static getDefaultDrawingOptions(_options) {
    unreachable("Not implemented");
  }
  static get typesMap() {
    unreachable("Not implemented");
  }
  static get isDrawer() {
    return true;
  }
  static get supportMultipleDrawings() {
    return false;
  }
  static updateDefaultParams(type, value) {
    const propertyName = this.typesMap.get(type);
    if (propertyName) {
      this._defaultDrawingOptions.updateProperty(propertyName, value);
    }
    if (this._currentParent) {
      __privateGet(_DrawingEditor, _currentDraw).updateProperty(propertyName, value);
      this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
    }
  }
  updateParams(type, value) {
    const propertyName = this.constructor.typesMap.get(type);
    if (propertyName) {
      this._updateProperty(type, propertyName, value);
    }
  }
  static get defaultPropertiesToUpdate() {
    const properties = [];
    const options = this._defaultDrawingOptions;
    for (const [type, name] of this.typesMap) {
      properties.push([type, options[name]]);
    }
    return properties;
  }
  get propertiesToUpdate() {
    const properties = [];
    const {
      _drawingOptions
    } = this;
    for (const [type, name] of this.constructor.typesMap) {
      properties.push([type, _drawingOptions[name]]);
    }
    return properties;
  }
  _updateProperty(type, name, value) {
    const options = this._drawingOptions;
    const savedValue = options[name];
    const setter = (val) => {
      var _a3, _b2;
      options.updateProperty(name, val);
      const bbox = __privateGet(this, _drawOutlines).updateProperty(name, val);
      if (bbox) {
        __privateMethod(this, _updateBbox, updateBbox_fn).call(this, bbox);
      }
      (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(this._drawId, options.toSVGProperties());
      if (type === this.colorType) {
        (_b2 = this._colorPicker) == null ? void 0 : _b2.update(val);
      }
    };
    this.addCommands({
      cmd: setter.bind(this, value),
      undo: setter.bind(this, savedValue),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  _onResizing() {
    var _a3;
    (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _drawOutlines).getPathResizingSVGProperties(__privateMethod(this, _convertToDrawSpace, convertToDrawSpace_fn).call(this)), {
      bbox: __privateMethod(this, _rotateBox, rotateBox_fn).call(this)
    }));
  }
  _onResized() {
    var _a3;
    (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _drawOutlines).getPathResizedSVGProperties(__privateMethod(this, _convertToDrawSpace, convertToDrawSpace_fn).call(this)), {
      bbox: __privateMethod(this, _rotateBox, rotateBox_fn).call(this)
    }));
  }
  _onTranslating(_x, _y) {
    var _a3;
    (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(this._drawId, {
      bbox: __privateMethod(this, _rotateBox, rotateBox_fn).call(this)
    });
  }
  _onTranslated() {
    var _a3;
    (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _drawOutlines).getPathTranslatedSVGProperties(__privateMethod(this, _convertToDrawSpace, convertToDrawSpace_fn).call(this), this.parentDimensions), {
      bbox: __privateMethod(this, _rotateBox, rotateBox_fn).call(this)
    }));
  }
  _onStartDragging() {
    var _a3;
    (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(this._drawId, {
      rootClass: {
        moving: true
      }
    });
  }
  _onStopDragging() {
    var _a3;
    (_a3 = this.parent) == null ? void 0 : _a3.drawLayer.updateProperties(this._drawId, {
      rootClass: {
        moving: false
      }
    });
  }
  commit() {
    super.commit();
    this.disableEditMode();
    this.disableEditing();
  }
  disableEditing() {
    super.disableEditing();
    this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing();
    this.div.classList.toggle("disabled", false);
  }
  getBaseTranslation() {
    return [0, 0];
  }
  get isResizable() {
    return true;
  }
  onceAdded(focus) {
    if (!this.annotationElementId) {
      this.parent.addUndoableEditor(this);
    }
    this._isDraggable = true;
    if (__privateGet(this, _mustBeCommitted)) {
      __privateSet(this, _mustBeCommitted, false);
      this.commit();
      this.parent.setSelected(this);
      if (focus && this.isOnScreen) {
        this.div.focus();
      }
    }
  }
  remove() {
    __privateMethod(this, _cleanDrawLayer2, cleanDrawLayer_fn2).call(this);
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    __privateMethod(this, _addToDrawLayer2, addToDrawLayer_fn2).call(this);
    __privateMethod(this, _updateBbox, updateBbox_fn).call(this, __privateGet(this, _drawOutlines).box);
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  setParent(parent) {
    var _a3;
    let mustBeSelected = false;
    if (this.parent && !parent) {
      this._uiManager.removeShouldRescale(this);
      __privateMethod(this, _cleanDrawLayer2, cleanDrawLayer_fn2).call(this);
    } else if (parent) {
      this._uiManager.addShouldRescale(this);
      __privateMethod(this, _addToDrawLayer2, addToDrawLayer_fn2).call(this, parent);
      mustBeSelected = !this.parent && ((_a3 = this.div) == null ? void 0 : _a3.classList.contains("selectedEditor"));
    }
    super.setParent(parent);
    if (mustBeSelected) {
      this.select();
    }
  }
  rotate() {
    if (!this.parent) {
      return;
    }
    this.parent.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties({
      bbox: __privateMethod(this, _rotateBox, rotateBox_fn).call(this)
    }, __privateGet(this, _drawOutlines).updateRotation((this.parentRotation - this.rotation + 360) % 360)));
  }
  onScaleChanging() {
    if (!this.parent) {
      return;
    }
    __privateMethod(this, _updateBbox, updateBbox_fn).call(this, __privateGet(this, _drawOutlines).updateParentDimensions(this.parentDimensions, this.parent.scale));
  }
  static onScaleChangingWhenDrawing() {
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this._isCopy) {
      baseX = this.x;
      baseY = this.y;
    }
    const div = super.render();
    div.classList.add("draw");
    const drawDiv = document.createElement("div");
    div.append(drawDiv);
    drawDiv.setAttribute("aria-hidden", "true");
    drawDiv.className = "internal";
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setDims(this.width * parentWidth, this.height * parentHeight);
    this._uiManager.addShouldRescale(this);
    this.disableEditing();
    if (this._isCopy) {
      this._moveAfterPaste(baseX, baseY);
    }
    return div;
  }
  static createDrawerInstance(_x, _y, _parentWidth3, _parentHeight3, _rotation4) {
    unreachable("Not implemented");
  }
  static startDrawing(parent, uiManager, _isLTR3, event) {
    var _a3, _b2;
    const {
      target,
      offsetX: x,
      offsetY: y,
      pointerId,
      pointerType
    } = event;
    if (__privateGet(_DrawingEditor, _currentPointerType) && __privateGet(_DrawingEditor, _currentPointerType) !== pointerType) {
      return;
    }
    const {
      viewport: {
        rotation
      }
    } = parent;
    const {
      width: parentWidth,
      height: parentHeight
    } = target.getBoundingClientRect();
    const ac = __privateSet(_DrawingEditor, _currentDrawingAC, new AbortController());
    const signal = parent.combinedSignal(ac);
    __privateGet(_DrawingEditor, _currentPointerId) || __privateSet(_DrawingEditor, _currentPointerId, pointerId);
    (_a3 = __privateGet(_DrawingEditor, _currentPointerType)) != null ? _a3 : __privateSet(_DrawingEditor, _currentPointerType, pointerType);
    window.addEventListener("pointerup", (e) => {
      var _a4;
      if (__privateGet(_DrawingEditor, _currentPointerId) === e.pointerId) {
        this._endDraw(e);
      } else {
        (_a4 = __privateGet(_DrawingEditor, _currentPointerIds)) == null ? void 0 : _a4.delete(e.pointerId);
      }
    }, {
      signal
    });
    window.addEventListener("pointercancel", (e) => {
      var _a4;
      if (__privateGet(_DrawingEditor, _currentPointerId) === e.pointerId) {
        this._currentParent.endDrawingSession();
      } else {
        (_a4 = __privateGet(_DrawingEditor, _currentPointerIds)) == null ? void 0 : _a4.delete(e.pointerId);
      }
    }, {
      signal
    });
    window.addEventListener("pointerdown", (e) => {
      if (__privateGet(_DrawingEditor, _currentPointerType) !== e.pointerType) {
        return;
      }
      (__privateGet(_DrawingEditor, _currentPointerIds) || __privateSet(_DrawingEditor, _currentPointerIds, /* @__PURE__ */ new Set())).add(e.pointerId);
      if (__privateGet(_DrawingEditor, _currentDraw).isCancellable()) {
        __privateGet(_DrawingEditor, _currentDraw).removeLastElement();
        if (__privateGet(_DrawingEditor, _currentDraw).isEmpty()) {
          this._currentParent.endDrawingSession(true);
        } else {
          this._endDraw(null);
        }
      }
    }, {
      capture: true,
      passive: false,
      signal
    });
    window.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    target.addEventListener("pointermove", this._drawMove.bind(this), {
      signal
    });
    target.addEventListener("touchmove", (e) => {
      if (e.timeStamp === __privateGet(_DrawingEditor, _currentMoveTimestamp)) {
        stopEvent(e);
      }
    }, {
      signal
    });
    parent.toggleDrawing();
    (_b2 = uiManager._editorUndoBar) == null ? void 0 : _b2.hide();
    if (__privateGet(_DrawingEditor, _currentDraw)) {
      parent.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _currentDraw).startNew(x, y, parentWidth, parentHeight, rotation));
      return;
    }
    uiManager.updateUIForDefaultProperties(this);
    __privateSet(_DrawingEditor, _currentDraw, this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation));
    __privateSet(_DrawingEditor, _currentDrawingOptions, this.getDefaultDrawingOptions());
    this._currentParent = parent;
    ({
      id: this._currentDrawId
    } = parent.drawLayer.draw(this._mergeSVGProperties(__privateGet(_DrawingEditor, _currentDrawingOptions).toSVGProperties(), __privateGet(_DrawingEditor, _currentDraw).defaultSVGProperties), true, false));
  }
  static _drawMove(event) {
    var _a3;
    __privateSet(_DrawingEditor, _currentMoveTimestamp, -1);
    if (!__privateGet(_DrawingEditor, _currentDraw)) {
      return;
    }
    const {
      offsetX,
      offsetY,
      pointerId
    } = event;
    if (__privateGet(_DrawingEditor, _currentPointerId) !== pointerId) {
      return;
    }
    if (((_a3 = __privateGet(_DrawingEditor, _currentPointerIds)) == null ? void 0 : _a3.size) >= 1) {
      this._endDraw(event);
      return;
    }
    this._currentParent.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _currentDraw).add(offsetX, offsetY));
    __privateSet(_DrawingEditor, _currentMoveTimestamp, event.timeStamp);
    stopEvent(event);
  }
  static _cleanup(all) {
    if (all) {
      this._currentDrawId = -1;
      this._currentParent = null;
      __privateSet(_DrawingEditor, _currentDraw, null);
      __privateSet(_DrawingEditor, _currentDrawingOptions, null);
      __privateSet(_DrawingEditor, _currentPointerType, null);
      __privateSet(_DrawingEditor, _currentMoveTimestamp, NaN);
    }
    if (__privateGet(_DrawingEditor, _currentDrawingAC)) {
      __privateGet(_DrawingEditor, _currentDrawingAC).abort();
      __privateSet(_DrawingEditor, _currentDrawingAC, null);
      __privateSet(_DrawingEditor, _currentPointerId, NaN);
      __privateSet(_DrawingEditor, _currentPointerIds, null);
    }
  }
  static _endDraw(event) {
    const parent = this._currentParent;
    if (!parent) {
      return;
    }
    parent.toggleDrawing(true);
    this._cleanup(false);
    if ((event == null ? void 0 : event.target) === parent.div) {
      parent.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _currentDraw).end(event.offsetX, event.offsetY));
    }
    if (this.supportMultipleDrawings) {
      const draw = __privateGet(_DrawingEditor, _currentDraw);
      const drawId = this._currentDrawId;
      const lastElement = draw.getLastElement();
      parent.addCommands({
        cmd: () => {
          parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));
        },
        undo: () => {
          parent.drawLayer.updateProperties(drawId, draw.removeLastElement());
        },
        mustExec: false,
        type: AnnotationEditorParamsType.DRAW_STEP
      });
      return;
    }
    this.endDrawing(false);
  }
  static endDrawing(isAborted) {
    const parent = this._currentParent;
    if (!parent) {
      return null;
    }
    parent.toggleDrawing(true);
    parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);
    if (!__privateGet(_DrawingEditor, _currentDraw).isEmpty()) {
      const {
        pageDimensions: [pageWidth, pageHeight],
        scale
      } = parent;
      const editor = parent.createAndAddNewEditor({
        offsetX: 0,
        offsetY: 0
      }, false, {
        drawId: this._currentDrawId,
        drawOutlines: __privateGet(_DrawingEditor, _currentDraw).getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),
        drawingOptions: __privateGet(_DrawingEditor, _currentDrawingOptions),
        mustBeCommitted: !isAborted
      });
      this._cleanup(true);
      return editor;
    }
    parent.drawLayer.remove(this._currentDrawId);
    this._cleanup(true);
    return null;
  }
  createDrawingOptions(_data2) {
  }
  static deserializeDraw(_pageX, _pageY, _pageWidth2, _pageHeight2, _innerWidth, _data2) {
    unreachable("Not implemented");
  }
  static async deserialize(data, parent, uiManager) {
    var _a3, _b2;
    const {
      rawDims: {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      }
    } = parent.viewport;
    const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);
    const editor = await super.deserialize(data, parent, uiManager);
    editor.createDrawingOptions(data);
    __privateMethod(_a3 = editor, _createDrawOutlines, createDrawOutlines_fn).call(_a3, {
      drawOutlines
    });
    __privateMethod(_b2 = editor, _addToDrawLayer2, addToDrawLayer_fn2).call(_b2);
    editor.onScaleChanging();
    editor.rotate();
    return editor;
  }
  serializeDraw(isForCopying) {
    const [pageX, pageY] = this.pageTranslation;
    const [pageWidth, pageHeight] = this.pageDimensions;
    return __privateGet(this, _drawOutlines).serialize([pageX, pageY, pageWidth, pageHeight], isForCopying);
  }
  renderAnnotationElement(annotation) {
    annotation.updateEdited({
      rect: this.getPDFRect()
    });
    return null;
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
};
_drawOutlines = new WeakMap();
_mustBeCommitted = new WeakMap();
_currentDraw = new WeakMap();
_currentDrawingAC = new WeakMap();
_currentDrawingOptions = new WeakMap();
_currentPointerId = new WeakMap();
_currentPointerType = new WeakMap();
_currentPointerIds = new WeakMap();
_currentMoveTimestamp = new WeakMap();
_createDrawOutlines = new WeakSet();
createDrawOutlines_fn = function({
  drawOutlines,
  drawId,
  drawingOptions
}) {
  __privateSet(this, _drawOutlines, drawOutlines);
  this._drawingOptions || (this._drawingOptions = drawingOptions);
  if (!this.annotationElementId) {
    this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);
  }
  if (drawId >= 0) {
    this._drawId = drawId;
    this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);
  } else {
    this._drawId = __privateMethod(this, _createDrawing, createDrawing_fn).call(this, drawOutlines, this.parent);
  }
  __privateMethod(this, _updateBbox, updateBbox_fn).call(this, drawOutlines.box);
};
_createDrawing = new WeakSet();
createDrawing_fn = function(drawOutlines, parent) {
  const {
    id
  } = parent.drawLayer.draw(_DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);
  return id;
};
_cleanDrawLayer2 = new WeakSet();
cleanDrawLayer_fn2 = function() {
  if (this._drawId === null || !this.parent) {
    return;
  }
  this.parent.drawLayer.remove(this._drawId);
  this._drawId = null;
  this._drawingOptions.reset();
};
_addToDrawLayer2 = new WeakSet();
addToDrawLayer_fn2 = function(parent = this.parent) {
  if (this._drawId !== null && this.parent === parent) {
    return;
  }
  if (this._drawId !== null) {
    this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);
    return;
  }
  this._drawingOptions.updateAll();
  this._drawId = __privateMethod(this, _createDrawing, createDrawing_fn).call(this, __privateGet(this, _drawOutlines), parent);
};
_convertToParentSpace = new WeakSet();
convertToParentSpace_fn = function([x, y, width, height]) {
  const {
    parentDimensions: [pW, pH],
    rotation
  } = this;
  switch (rotation) {
    case 90:
      return [y, 1 - x, width * (pH / pW), height * (pW / pH)];
    case 180:
      return [1 - x, 1 - y, width, height];
    case 270:
      return [1 - y, x, width * (pH / pW), height * (pW / pH)];
    default:
      return [x, y, width, height];
  }
};
_convertToDrawSpace = new WeakSet();
convertToDrawSpace_fn = function() {
  const {
    x,
    y,
    width,
    height,
    parentDimensions: [pW, pH],
    rotation
  } = this;
  switch (rotation) {
    case 90:
      return [1 - y, x, width * (pW / pH), height * (pH / pW)];
    case 180:
      return [1 - x, 1 - y, width, height];
    case 270:
      return [y, 1 - x, width * (pW / pH), height * (pH / pW)];
    default:
      return [x, y, width, height];
  }
};
_updateBbox = new WeakSet();
updateBbox_fn = function(bbox) {
  [this.x, this.y, this.width, this.height] = __privateMethod(this, _convertToParentSpace, convertToParentSpace_fn).call(this, bbox);
  if (this.div) {
    this.fixAndSetPosition();
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setDims(this.width * parentWidth, this.height * parentHeight);
  }
  this._onResized();
};
_rotateBox = new WeakSet();
rotateBox_fn = function() {
  const {
    x,
    y,
    width,
    height,
    rotation,
    parentRotation,
    parentDimensions: [pW, pH]
  } = this;
  switch ((rotation * 4 + parentRotation) / 90) {
    case 1:
      return [1 - y - height, x, height, width];
    case 2:
      return [1 - x - width, 1 - y - height, width, height];
    case 3:
      return [y, 1 - x - width, height, width];
    case 4:
      return [x, y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
    case 5:
      return [1 - y, x, width * (pW / pH), height * (pH / pW)];
    case 6:
      return [1 - x - height * (pH / pW), 1 - y, height * (pH / pW), width * (pW / pH)];
    case 7:
      return [y - width * (pW / pH), 1 - x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
    case 8:
      return [x - width, y - height, width, height];
    case 9:
      return [1 - y, x - width, height, width];
    case 10:
      return [1 - x, 1 - y, width, height];
    case 11:
      return [y - height, 1 - x, height, width];
    case 12:
      return [x - height * (pH / pW), y, height * (pH / pW), width * (pW / pH)];
    case 13:
      return [1 - y - width * (pW / pH), x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
    case 14:
      return [1 - x, 1 - y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
    case 15:
      return [y, 1 - x, width * (pW / pH), height * (pH / pW)];
    default:
      return [x, y, width, height];
  }
};
__publicField(_DrawingEditor, "_currentDrawId", -1);
__publicField(_DrawingEditor, "_currentParent", null);
__privateAdd(_DrawingEditor, _currentDraw, null);
__privateAdd(_DrawingEditor, _currentDrawingAC, null);
__privateAdd(_DrawingEditor, _currentDrawingOptions, null);
__privateAdd(_DrawingEditor, _currentPointerId, NaN);
__privateAdd(_DrawingEditor, _currentPointerType, null);
__privateAdd(_DrawingEditor, _currentPointerIds, null);
__privateAdd(_DrawingEditor, _currentMoveTimestamp, NaN);
__publicField(_DrawingEditor, "_INNER_MARGIN", 3);
var DrawingEditor = _DrawingEditor;
var _last2, _line2, _lines, _rotation2, _thickness3, _points3, _lastSVGPath, _lastIndex, _outlines2, _parentWidth, _parentHeight, _normalizePoint, normalizePoint_fn;
var InkDrawOutliner = class {
  constructor(x, y, parentWidth, parentHeight, rotation, thickness) {
    __privateAdd(this, _normalizePoint);
    __privateAdd(this, _last2, new Float64Array(6));
    __privateAdd(this, _line2, void 0);
    __privateAdd(this, _lines, void 0);
    __privateAdd(this, _rotation2, void 0);
    __privateAdd(this, _thickness3, void 0);
    __privateAdd(this, _points3, void 0);
    __privateAdd(this, _lastSVGPath, "");
    __privateAdd(this, _lastIndex, 0);
    __privateAdd(this, _outlines2, new InkDrawOutline());
    __privateAdd(this, _parentWidth, void 0);
    __privateAdd(this, _parentHeight, void 0);
    __privateSet(this, _parentWidth, parentWidth);
    __privateSet(this, _parentHeight, parentHeight);
    __privateSet(this, _rotation2, rotation);
    __privateSet(this, _thickness3, thickness);
    [x, y] = __privateMethod(this, _normalizePoint, normalizePoint_fn).call(this, x, y);
    const line = __privateSet(this, _line2, [NaN, NaN, NaN, NaN, x, y]);
    __privateSet(this, _points3, [x, y]);
    __privateSet(this, _lines, [{
      line,
      points: __privateGet(this, _points3)
    }]);
    __privateGet(this, _last2).set(line, 0);
  }
  updateProperty(name, value) {
    if (name === "stroke-width") {
      __privateSet(this, _thickness3, value);
    }
  }
  isEmpty() {
    return !__privateGet(this, _lines) || __privateGet(this, _lines).length === 0;
  }
  isCancellable() {
    return __privateGet(this, _points3).length <= 10;
  }
  add(x, y) {
    [x, y] = __privateMethod(this, _normalizePoint, normalizePoint_fn).call(this, x, y);
    const [x1, y1, x2, y2] = __privateGet(this, _last2).subarray(2, 6);
    const diffX = x - x2;
    const diffY = y - y2;
    const d = Math.hypot(__privateGet(this, _parentWidth) * diffX, __privateGet(this, _parentHeight) * diffY);
    if (d <= 2) {
      return null;
    }
    __privateGet(this, _points3).push(x, y);
    if (isNaN(x1)) {
      __privateGet(this, _last2).set([x2, y2, x, y], 2);
      __privateGet(this, _line2).push(NaN, NaN, NaN, NaN, x, y);
      return {
        path: {
          d: this.toSVGPath()
        }
      };
    }
    if (isNaN(__privateGet(this, _last2)[0])) {
      __privateGet(this, _line2).splice(6, 6);
    }
    __privateGet(this, _last2).set([x1, y1, x2, y2, x, y], 0);
    __privateGet(this, _line2).push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  end(x, y) {
    const change = this.add(x, y);
    if (change) {
      return change;
    }
    if (__privateGet(this, _points3).length === 2) {
      return {
        path: {
          d: this.toSVGPath()
        }
      };
    }
    return null;
  }
  startNew(x, y, parentWidth, parentHeight, rotation) {
    __privateSet(this, _parentWidth, parentWidth);
    __privateSet(this, _parentHeight, parentHeight);
    __privateSet(this, _rotation2, rotation);
    [x, y] = __privateMethod(this, _normalizePoint, normalizePoint_fn).call(this, x, y);
    const line = __privateSet(this, _line2, [NaN, NaN, NaN, NaN, x, y]);
    __privateSet(this, _points3, [x, y]);
    const last = __privateGet(this, _lines).at(-1);
    if (last) {
      last.line = new Float32Array(last.line);
      last.points = new Float32Array(last.points);
    }
    __privateGet(this, _lines).push({
      line,
      points: __privateGet(this, _points3)
    });
    __privateGet(this, _last2).set(line, 0);
    __privateSet(this, _lastIndex, 0);
    this.toSVGPath();
    return null;
  }
  getLastElement() {
    return __privateGet(this, _lines).at(-1);
  }
  setLastElement(element) {
    if (!__privateGet(this, _lines)) {
      return __privateGet(this, _outlines2).setLastElement(element);
    }
    __privateGet(this, _lines).push(element);
    __privateSet(this, _line2, element.line);
    __privateSet(this, _points3, element.points);
    __privateSet(this, _lastIndex, 0);
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  removeLastElement() {
    if (!__privateGet(this, _lines)) {
      return __privateGet(this, _outlines2).removeLastElement();
    }
    __privateGet(this, _lines).pop();
    __privateSet(this, _lastSVGPath, "");
    for (let i = 0, ii = __privateGet(this, _lines).length; i < ii; i++) {
      const {
        line,
        points
      } = __privateGet(this, _lines)[i];
      __privateSet(this, _line2, line);
      __privateSet(this, _points3, points);
      __privateSet(this, _lastIndex, 0);
      this.toSVGPath();
    }
    return {
      path: {
        d: __privateGet(this, _lastSVGPath)
      }
    };
  }
  toSVGPath() {
    const firstX = Outline.svgRound(__privateGet(this, _line2)[4]);
    const firstY = Outline.svgRound(__privateGet(this, _line2)[5]);
    if (__privateGet(this, _points3).length === 2) {
      __privateSet(this, _lastSVGPath, `${__privateGet(this, _lastSVGPath)} M ${firstX} ${firstY} Z`);
      return __privateGet(this, _lastSVGPath);
    }
    if (__privateGet(this, _points3).length <= 6) {
      const i = __privateGet(this, _lastSVGPath).lastIndexOf("M");
      __privateSet(this, _lastSVGPath, `${__privateGet(this, _lastSVGPath).slice(0, i)} M ${firstX} ${firstY}`);
      __privateSet(this, _lastIndex, 6);
    }
    if (__privateGet(this, _points3).length === 4) {
      const secondX = Outline.svgRound(__privateGet(this, _line2)[10]);
      const secondY = Outline.svgRound(__privateGet(this, _line2)[11]);
      __privateSet(this, _lastSVGPath, `${__privateGet(this, _lastSVGPath)} L ${secondX} ${secondY}`);
      __privateSet(this, _lastIndex, 12);
      return __privateGet(this, _lastSVGPath);
    }
    const buffer = [];
    if (__privateGet(this, _lastIndex) === 0) {
      buffer.push(`M ${firstX} ${firstY}`);
      __privateSet(this, _lastIndex, 6);
    }
    for (let i = __privateGet(this, _lastIndex), ii = __privateGet(this, _line2).length; i < ii; i += 6) {
      const [c1x, c1y, c2x, c2y, x, y] = __privateGet(this, _line2).slice(i, i + 6).map(Outline.svgRound);
      buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
    }
    __privateSet(this, _lastSVGPath, __privateGet(this, _lastSVGPath) + buffer.join(" "));
    __privateSet(this, _lastIndex, __privateGet(this, _line2).length);
    return __privateGet(this, _lastSVGPath);
  }
  getOutlines(parentWidth, parentHeight, scale, innerMargin) {
    const last = __privateGet(this, _lines).at(-1);
    last.line = new Float32Array(last.line);
    last.points = new Float32Array(last.points);
    __privateGet(this, _outlines2).build(__privateGet(this, _lines), parentWidth, parentHeight, scale, __privateGet(this, _rotation2), __privateGet(this, _thickness3), innerMargin);
    __privateSet(this, _last2, null);
    __privateSet(this, _line2, null);
    __privateSet(this, _lines, null);
    __privateSet(this, _lastSVGPath, null);
    return __privateGet(this, _outlines2);
  }
  get defaultSVGProperties() {
    return {
      root: {
        viewBox: "0 0 10000 10000"
      },
      rootClass: {
        draw: true
      },
      bbox: [0, 0, 1, 1]
    };
  }
};
_last2 = new WeakMap();
_line2 = new WeakMap();
_lines = new WeakMap();
_rotation2 = new WeakMap();
_thickness3 = new WeakMap();
_points3 = new WeakMap();
_lastSVGPath = new WeakMap();
_lastIndex = new WeakMap();
_outlines2 = new WeakMap();
_parentWidth = new WeakMap();
_parentHeight = new WeakMap();
_normalizePoint = new WeakSet();
normalizePoint_fn = function(x, y) {
  return Outline._normalizePoint(x, y, __privateGet(this, _parentWidth), __privateGet(this, _parentHeight), __privateGet(this, _rotation2));
};
var _bbox2, _currentRotation, _innerMargin3, _lines2, _parentWidth2, _parentHeight2, _parentScale, _rotation3, _thickness4, _getMarginComponents, getMarginComponents_fn, _getBBoxWithNoMargin, getBBoxWithNoMargin_fn, _computeBbox, computeBbox_fn, _updateThickness2, updateThickness_fn2;
var InkDrawOutline = class extends Outline {
  constructor() {
    super(...arguments);
    __privateAdd(this, _getMarginComponents);
    __privateAdd(this, _getBBoxWithNoMargin);
    __privateAdd(this, _computeBbox);
    __privateAdd(this, _updateThickness2);
    __privateAdd(this, _bbox2, void 0);
    __privateAdd(this, _currentRotation, 0);
    __privateAdd(this, _innerMargin3, void 0);
    __privateAdd(this, _lines2, void 0);
    __privateAdd(this, _parentWidth2, void 0);
    __privateAdd(this, _parentHeight2, void 0);
    __privateAdd(this, _parentScale, void 0);
    __privateAdd(this, _rotation3, void 0);
    __privateAdd(this, _thickness4, void 0);
  }
  build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {
    __privateSet(this, _parentWidth2, parentWidth);
    __privateSet(this, _parentHeight2, parentHeight);
    __privateSet(this, _parentScale, parentScale);
    __privateSet(this, _rotation3, rotation);
    __privateSet(this, _thickness4, thickness);
    __privateSet(this, _innerMargin3, innerMargin != null ? innerMargin : 0);
    __privateSet(this, _lines2, lines);
    __privateMethod(this, _computeBbox, computeBbox_fn).call(this);
  }
  get thickness() {
    return __privateGet(this, _thickness4);
  }
  setLastElement(element) {
    __privateGet(this, _lines2).push(element);
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  removeLastElement() {
    __privateGet(this, _lines2).pop();
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  toSVGPath() {
    const buffer = [];
    for (const {
      line
    } of __privateGet(this, _lines2)) {
      buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);
      if (line.length === 6) {
        buffer.push("Z");
        continue;
      }
      if (line.length === 12 && isNaN(line[6])) {
        buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);
        continue;
      }
      for (let i = 6, ii = line.length; i < ii; i += 6) {
        const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);
        buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
      }
    }
    return buffer.join("");
  }
  serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {
    const serializedLines = [];
    const serializedPoints = [];
    const [x, y, width, height] = __privateMethod(this, _getBBoxWithNoMargin, getBBoxWithNoMargin_fn).call(this);
    let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;
    switch (__privateGet(this, _rotation3)) {
      case 0:
        rescaleFn = Outline._rescale;
        tx = pageX;
        ty = pageY + pageHeight;
        sx = pageWidth;
        sy = -pageHeight;
        x1 = pageX + x * pageWidth;
        y1 = pageY + (1 - y - height) * pageHeight;
        x2 = pageX + (x + width) * pageWidth;
        y2 = pageY + (1 - y) * pageHeight;
        break;
      case 90:
        rescaleFn = Outline._rescaleAndSwap;
        tx = pageX;
        ty = pageY;
        sx = pageWidth;
        sy = pageHeight;
        x1 = pageX + y * pageWidth;
        y1 = pageY + x * pageHeight;
        x2 = pageX + (y + height) * pageWidth;
        y2 = pageY + (x + width) * pageHeight;
        break;
      case 180:
        rescaleFn = Outline._rescale;
        tx = pageX + pageWidth;
        ty = pageY;
        sx = -pageWidth;
        sy = pageHeight;
        x1 = pageX + (1 - x - width) * pageWidth;
        y1 = pageY + y * pageHeight;
        x2 = pageX + (1 - x) * pageWidth;
        y2 = pageY + (y + height) * pageHeight;
        break;
      case 270:
        rescaleFn = Outline._rescaleAndSwap;
        tx = pageX + pageWidth;
        ty = pageY + pageHeight;
        sx = -pageWidth;
        sy = -pageHeight;
        x1 = pageX + (1 - y - height) * pageWidth;
        y1 = pageY + (1 - x - width) * pageHeight;
        x2 = pageX + (1 - y) * pageWidth;
        y2 = pageY + (1 - x) * pageHeight;
        break;
    }
    for (const {
      line,
      points
    } of __privateGet(this, _lines2)) {
      serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));
      serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));
    }
    return {
      lines: serializedLines,
      points: serializedPoints,
      rect: [x1, y1, x2, y2]
    };
  }
  static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, {
    paths: {
      lines,
      points
    },
    rotation,
    thickness
  }) {
    const newLines = [];
    let tx, ty, sx, sy, rescaleFn;
    switch (rotation) {
      case 0:
        rescaleFn = Outline._rescale;
        tx = -pageX / pageWidth;
        ty = pageY / pageHeight + 1;
        sx = 1 / pageWidth;
        sy = -1 / pageHeight;
        break;
      case 90:
        rescaleFn = Outline._rescaleAndSwap;
        tx = -pageY / pageHeight;
        ty = -pageX / pageWidth;
        sx = 1 / pageHeight;
        sy = 1 / pageWidth;
        break;
      case 180:
        rescaleFn = Outline._rescale;
        tx = pageX / pageWidth + 1;
        ty = -pageY / pageHeight;
        sx = -1 / pageWidth;
        sy = 1 / pageHeight;
        break;
      case 270:
        rescaleFn = Outline._rescaleAndSwap;
        tx = pageY / pageHeight + 1;
        ty = pageX / pageWidth + 1;
        sx = -1 / pageHeight;
        sy = -1 / pageWidth;
        break;
    }
    if (!lines) {
      lines = [];
      for (const point of points) {
        const len = point.length;
        if (len === 2) {
          lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1]]));
          continue;
        }
        if (len === 4) {
          lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1], NaN, NaN, NaN, NaN, point[2], point[3]]));
          continue;
        }
        const line = new Float32Array(3 * (len - 2));
        lines.push(line);
        let [x1, y1, x2, y2] = point.subarray(0, 4);
        line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
        for (let i = 4; i < len; i += 2) {
          const x = point[i];
          const y = point[i + 1];
          line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);
          [x1, y1, x2, y2] = [x2, y2, x, y];
        }
      }
    }
    for (let i = 0, ii = lines.length; i < ii; i++) {
      newLines.push({
        line: rescaleFn(lines[i].map((x) => x != null ? x : NaN), tx, ty, sx, sy),
        points: rescaleFn(points[i].map((x) => x != null ? x : NaN), tx, ty, sx, sy)
      });
    }
    const outlines = new this.prototype.constructor();
    outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);
    return outlines;
  }
  get box() {
    return __privateGet(this, _bbox2);
  }
  updateProperty(name, value) {
    if (name === "stroke-width") {
      return __privateMethod(this, _updateThickness2, updateThickness_fn2).call(this, value);
    }
    return null;
  }
  updateParentDimensions([width, height], scale) {
    const [oldMarginX, oldMarginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
    __privateSet(this, _parentWidth2, width);
    __privateSet(this, _parentHeight2, height);
    __privateSet(this, _parentScale, scale);
    const [newMarginX, newMarginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
    const diffMarginX = newMarginX - oldMarginX;
    const diffMarginY = newMarginY - oldMarginY;
    const bbox = __privateGet(this, _bbox2);
    bbox[0] -= diffMarginX;
    bbox[1] -= diffMarginY;
    bbox[2] += 2 * diffMarginX;
    bbox[3] += 2 * diffMarginY;
    return bbox;
  }
  updateRotation(rotation) {
    __privateSet(this, _currentRotation, rotation);
    return {
      path: {
        transform: this.rotationTransform
      }
    };
  }
  get viewBox() {
    return __privateGet(this, _bbox2).map(Outline.svgRound).join(" ");
  }
  get defaultProperties() {
    const [x, y] = __privateGet(this, _bbox2);
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`
      }
    };
  }
  get rotationTransform() {
    const [, , width, height] = __privateGet(this, _bbox2);
    let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;
    switch (__privateGet(this, _currentRotation)) {
      case 90:
        b = height / width;
        c = -width / height;
        e = width;
        break;
      case 180:
        a = -1;
        d = -1;
        e = width;
        f = height;
        break;
      case 270:
        b = -height / width;
        c = width / height;
        f = height;
        break;
      default:
        return "";
    }
    return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;
  }
  getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {
    const [marginX, marginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
    const [x, y, width, height] = __privateGet(this, _bbox2);
    if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
      const tx = newX + newWidth / 2 - (x + width / 2);
      const ty = newY + newHeight / 2 - (y + height / 2);
      return {
        path: {
          "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
          transform: `${this.rotationTransform} translate(${tx} ${ty})`
        }
      };
    }
    const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
    const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
    const s2x = width / newWidth;
    const s2y = height / newHeight;
    return {
      path: {
        "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,
        transform: `${this.rotationTransform} scale(${s2x} ${s2y}) translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`
      }
    };
  }
  getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {
    const [marginX, marginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
    const bbox = __privateGet(this, _bbox2);
    const [x, y, width, height] = bbox;
    bbox[0] = newX;
    bbox[1] = newY;
    bbox[2] = newWidth;
    bbox[3] = newHeight;
    if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
      const tx2 = newX + newWidth / 2 - (x + width / 2);
      const ty2 = newY + newHeight / 2 - (y + height / 2);
      for (const {
        line,
        points
      } of __privateGet(this, _lines2)) {
        Outline._translate(line, tx2, ty2, line);
        Outline._translate(points, tx2, ty2, points);
      }
      return {
        root: {
          viewBox: this.viewBox
        },
        path: {
          "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
          transform: this.rotationTransform || null,
          d: this.toSVGPath()
        }
      };
    }
    const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
    const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
    const tx = -s1x * (x + marginX) + newX + marginX;
    const ty = -s1y * (y + marginY) + newY + marginY;
    if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {
      for (const {
        line,
        points
      } of __privateGet(this, _lines2)) {
        Outline._rescale(line, tx, ty, s1x, s1y, line);
        Outline._rescale(points, tx, ty, s1x, s1y, points);
      }
    }
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
        transform: this.rotationTransform || null,
        d: this.toSVGPath()
      }
    };
  }
  getPathTranslatedSVGProperties([newX, newY], parentDimensions) {
    const [newParentWidth, newParentHeight] = parentDimensions;
    const bbox = __privateGet(this, _bbox2);
    const tx = newX - bbox[0];
    const ty = newY - bbox[1];
    if (__privateGet(this, _parentWidth2) === newParentWidth && __privateGet(this, _parentHeight2) === newParentHeight) {
      for (const {
        line,
        points
      } of __privateGet(this, _lines2)) {
        Outline._translate(line, tx, ty, line);
        Outline._translate(points, tx, ty, points);
      }
    } else {
      const sx = __privateGet(this, _parentWidth2) / newParentWidth;
      const sy = __privateGet(this, _parentHeight2) / newParentHeight;
      __privateSet(this, _parentWidth2, newParentWidth);
      __privateSet(this, _parentHeight2, newParentHeight);
      for (const {
        line,
        points
      } of __privateGet(this, _lines2)) {
        Outline._rescale(line, tx, ty, sx, sy, line);
        Outline._rescale(points, tx, ty, sx, sy, points);
      }
      bbox[2] *= sx;
      bbox[3] *= sy;
    }
    bbox[0] = newX;
    bbox[1] = newY;
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        d: this.toSVGPath(),
        "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`
      }
    };
  }
  get defaultSVGProperties() {
    const bbox = __privateGet(this, _bbox2);
    return {
      root: {
        viewBox: this.viewBox
      },
      rootClass: {
        draw: true
      },
      path: {
        d: this.toSVGPath(),
        "transform-origin": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,
        transform: this.rotationTransform || null
      },
      bbox
    };
  }
};
_bbox2 = new WeakMap();
_currentRotation = new WeakMap();
_innerMargin3 = new WeakMap();
_lines2 = new WeakMap();
_parentWidth2 = new WeakMap();
_parentHeight2 = new WeakMap();
_parentScale = new WeakMap();
_rotation3 = new WeakMap();
_thickness4 = new WeakMap();
_getMarginComponents = new WeakSet();
getMarginComponents_fn = function(thickness = __privateGet(this, _thickness4)) {
  const margin = __privateGet(this, _innerMargin3) + thickness / 2 * __privateGet(this, _parentScale);
  return __privateGet(this, _rotation3) % 180 === 0 ? [margin / __privateGet(this, _parentWidth2), margin / __privateGet(this, _parentHeight2)] : [margin / __privateGet(this, _parentHeight2), margin / __privateGet(this, _parentWidth2)];
};
_getBBoxWithNoMargin = new WeakSet();
getBBoxWithNoMargin_fn = function() {
  const [x, y, width, height] = __privateGet(this, _bbox2);
  const [marginX, marginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this, 0);
  return [x + marginX, y + marginY, width - 2 * marginX, height - 2 * marginY];
};
_computeBbox = new WeakSet();
computeBbox_fn = function() {
  const bbox = __privateSet(this, _bbox2, new Float32Array([Infinity, Infinity, -Infinity, -Infinity]));
  for (const {
    line
  } of __privateGet(this, _lines2)) {
    if (line.length <= 12) {
      for (let i = 4, ii = line.length; i < ii; i += 6) {
        Util.pointBoundingBox(line[i], line[i + 1], bbox);
      }
      continue;
    }
    let lastX = line[4], lastY = line[5];
    for (let i = 6, ii = line.length; i < ii; i += 6) {
      const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);
      Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);
      lastX = x;
      lastY = y;
    }
  }
  const [marginX, marginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
  bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);
  bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);
  bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);
  bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);
  bbox[2] -= bbox[0];
  bbox[3] -= bbox[1];
};
_updateThickness2 = new WeakSet();
updateThickness_fn2 = function(thickness) {
  const [oldMarginX, oldMarginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
  __privateSet(this, _thickness4, thickness);
  const [newMarginX, newMarginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
  const [diffMarginX, diffMarginY] = [newMarginX - oldMarginX, newMarginY - oldMarginY];
  const bbox = __privateGet(this, _bbox2);
  bbox[0] -= diffMarginX;
  bbox[1] -= diffMarginY;
  bbox[2] += 2 * diffMarginX;
  bbox[3] += 2 * diffMarginY;
  return bbox;
};
var InkDrawingOptions = class _InkDrawingOptions extends DrawingOptions {
  constructor(viewerParameters) {
    super();
    this._viewParameters = viewerParameters;
    super.updateProperties({
      fill: "none",
      stroke: AnnotationEditor._defaultLineColor,
      "stroke-opacity": 1,
      "stroke-width": 1,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-miterlimit": 10
    });
  }
  updateSVGProperty(name, value) {
    if (name === "stroke-width") {
      value != null ? value : value = this["stroke-width"];
      value *= this._viewParameters.realScale;
    }
    super.updateSVGProperty(name, value);
  }
  clone() {
    const clone = new _InkDrawingOptions(this._viewParameters);
    clone.updateAll(this);
    return clone;
  }
};
var _hasElementChanged3, hasElementChanged_fn3;
var _InkEditor = class _InkEditor extends DrawingEditor {
  constructor(params) {
    super({
      ...params,
      name: "inkEditor"
    });
    __privateAdd(this, _hasElementChanged3);
    this._willKeepAspectRatio = true;
    this.defaultL10nId = "pdfjs-editor-ink-editor";
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);
  }
  static getDefaultDrawingOptions(options) {
    const clone = this._defaultDrawingOptions.clone();
    clone.updateProperties(options);
    return clone;
  }
  static get supportMultipleDrawings() {
    return true;
  }
  static get typesMap() {
    return shadow(this, "typesMap", /* @__PURE__ */ new Map([[AnnotationEditorParamsType.INK_THICKNESS, "stroke-width"], [AnnotationEditorParamsType.INK_COLOR, "stroke"], [AnnotationEditorParamsType.INK_OPACITY, "stroke-opacity"]]));
  }
  static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {
    return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions["stroke-width"]);
  }
  static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
    return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
  }
  static async deserialize(data, parent, uiManager) {
    let initialData = null;
    if (data instanceof InkAnnotationElement) {
      const {
        data: {
          inkLists,
          rect,
          rotation,
          id,
          color,
          opacity,
          borderStyle: {
            rawWidth: thickness
          },
          popupRef,
          contentsObj
        },
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      initialData = data = {
        annotationType: AnnotationEditorType.INK,
        color: Array.from(color),
        thickness,
        opacity,
        paths: {
          points: inkLists
        },
        boxes: null,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        comment: (contentsObj == null ? void 0 : contentsObj.str) || null
      };
    }
    const editor = await super.deserialize(data, parent, uiManager);
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data.comment);
    }
    return editor;
  }
  get toolbarButtons() {
    this._colorPicker || (this._colorPicker = new BasicColorPicker(this));
    return [["colorPicker", this._colorPicker]];
  }
  get colorType() {
    return AnnotationEditorParamsType.INK_COLOR;
  }
  get colorValue() {
    return this._drawingOptions.stroke;
  }
  onScaleChanging() {
    if (!this.parent) {
      return;
    }
    super.onScaleChanging();
    const {
      _drawId,
      _drawingOptions,
      parent
    } = this;
    _drawingOptions.updateSVGProperty("stroke-width");
    parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());
  }
  static onScaleChangingWhenDrawing() {
    const parent = this._currentParent;
    if (!parent) {
      return;
    }
    super.onScaleChangingWhenDrawing();
    this._defaultDrawingOptions.updateSVGProperty("stroke-width");
    parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
  }
  createDrawingOptions({
    color,
    thickness,
    opacity
  }) {
    this._drawingOptions = _InkEditor.getDefaultDrawingOptions({
      stroke: Util.makeHexColor(...color),
      "stroke-width": thickness,
      "stroke-opacity": opacity
    });
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const {
      lines,
      points,
      rect
    } = this.serializeDraw(isForCopying);
    const {
      _drawingOptions: {
        stroke,
        "stroke-opacity": opacity,
        "stroke-width": thickness
      }
    } = this;
    const serialized = {
      annotationType: AnnotationEditorType.INK,
      color: AnnotationEditor._colorManager.convert(stroke),
      opacity,
      thickness,
      paths: {
        lines,
        points
      },
      pageIndex: this.pageIndex,
      rect,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    this.addComment(serialized);
    if (isForCopying) {
      serialized.isCopy = true;
      return serialized;
    }
    if (this.annotationElementId && !__privateMethod(this, _hasElementChanged3, hasElementChanged_fn3).call(this, serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    const {
      points,
      rect
    } = this.serializeDraw(false);
    const params = {
      rect,
      thickness: this._drawingOptions["stroke-width"],
      points
    };
    if (this.hasEditedComment) {
      params.popup = this.comment;
    }
    annotation.updateEdited(params);
    return null;
  }
};
_hasElementChanged3 = new WeakSet();
hasElementChanged_fn3 = function(serialized) {
  const {
    color,
    thickness,
    opacity,
    pageIndex
  } = this._initialData;
  return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i) => c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;
};
__publicField(_InkEditor, "_type", "ink");
__publicField(_InkEditor, "_editorType", AnnotationEditorType.INK);
__publicField(_InkEditor, "_defaultDrawingOptions", null);
var InkEditor = _InkEditor;
var ContourDrawOutline = class extends InkDrawOutline {
  toSVGPath() {
    let path2 = super.toSVGPath();
    if (!path2.endsWith("Z")) {
      path2 += "Z";
    }
    return path2;
  }
};
var BASE_HEADER_LENGTH = 8;
var POINTS_PROPERTIES_NUMBER = 3;
var _PARAMETERS, _neighborIndexToId, neighborIndexToId_fn, _neighborIdToIndex, _clockwiseNonZero, clockwiseNonZero_fn, _counterClockwiseNonZero, counterClockwiseNonZero_fn, _findContours, findContours_fn, _douglasPeuckerHelper, douglasPeuckerHelper_fn, _douglasPeucker, douglasPeucker_fn, _bilateralFilter, bilateralFilter_fn, _getHistogram, getHistogram_fn, _toUint8, toUint8_fn, _guessThreshold, guessThreshold_fn, _getGrayPixels, getGrayPixels_fn;
var SignatureExtractor = class {
  static extractContoursFromText(text, {
    fontFamily,
    fontStyle,
    fontWeight
  }, pageWidth, pageHeight, rotation, innerMargin) {
    let canvas = new OffscreenCanvas(1, 1);
    let ctx = canvas.getContext("2d", {
      alpha: false
    });
    const fontSize = 200;
    const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    const {
      actualBoundingBoxLeft,
      actualBoundingBoxRight,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      fontBoundingBoxAscent,
      fontBoundingBoxDescent,
      width
    } = ctx.measureText(text);
    const SCALE = 1.5;
    const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);
    const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);
    canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
    ctx = canvas.getContext("2d", {
      alpha: true,
      willReadFrequently: true
    });
    ctx.font = font;
    ctx.filter = "grayscale(1)";
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    ctx.fillStyle = "black";
    ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);
    const uint8Buf = __privateMethod(this, _toUint8, toUint8_fn).call(this, ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);
    const histogram = __privateMethod(this, _getHistogram, getHistogram_fn).call(this, uint8Buf);
    const threshold = __privateMethod(this, _guessThreshold, guessThreshold_fn).call(this, histogram);
    const contourList = __privateMethod(this, _findContours, findContours_fn).call(this, uint8Buf, canvasWidth, canvasHeight, threshold);
    return this.processDrawnLines({
      lines: {
        curves: contourList,
        width: canvasWidth,
        height: canvasHeight
      },
      pageWidth,
      pageHeight,
      rotation,
      innerMargin,
      mustSmooth: true,
      areContours: true
    });
  }
  static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {
    const [uint8Buf, width, height] = __privateMethod(this, _getGrayPixels, getGrayPixels_fn).call(this, bitmap);
    const [buffer, histogram] = __privateMethod(this, _bilateralFilter, bilateralFilter_fn).call(this, uint8Buf, width, height, Math.hypot(width, height) * __privateGet(this, _PARAMETERS).sigmaSFactor, __privateGet(this, _PARAMETERS).sigmaR, __privateGet(this, _PARAMETERS).kernelSize);
    const threshold = __privateMethod(this, _guessThreshold, guessThreshold_fn).call(this, histogram);
    const contourList = __privateMethod(this, _findContours, findContours_fn).call(this, buffer, width, height, threshold);
    return this.processDrawnLines({
      lines: {
        curves: contourList,
        width,
        height
      },
      pageWidth,
      pageHeight,
      rotation,
      innerMargin,
      mustSmooth: true,
      areContours: true
    });
  }
  static processDrawnLines({
    lines,
    pageWidth,
    pageHeight,
    rotation,
    innerMargin,
    mustSmooth,
    areContours
  }) {
    var _a3;
    if (rotation % 180 !== 0) {
      [pageWidth, pageHeight] = [pageHeight, pageWidth];
    }
    const {
      curves,
      width,
      height
    } = lines;
    const thickness = (_a3 = lines.thickness) != null ? _a3 : 0;
    const linesAndPoints = [];
    const ratio = Math.min(pageWidth / width, pageHeight / height);
    const xScale = ratio / pageWidth;
    const yScale = ratio / pageHeight;
    const newCurves = [];
    for (const {
      points
    } of curves) {
      const reducedPoints = mustSmooth ? __privateMethod(this, _douglasPeucker, douglasPeucker_fn).call(this, points) : points;
      if (!reducedPoints) {
        continue;
      }
      newCurves.push(reducedPoints);
      const len = reducedPoints.length;
      const newPoints = new Float32Array(len);
      const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));
      linesAndPoints.push({
        line,
        points: newPoints
      });
      if (len === 2) {
        newPoints[0] = reducedPoints[0] * xScale;
        newPoints[1] = reducedPoints[1] * yScale;
        line.set([NaN, NaN, NaN, NaN, newPoints[0], newPoints[1]], 0);
        continue;
      }
      let [x1, y1, x2, y2] = reducedPoints;
      x1 *= xScale;
      y1 *= yScale;
      x2 *= xScale;
      y2 *= yScale;
      newPoints.set([x1, y1, x2, y2], 0);
      line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
      for (let i = 4; i < len; i += 2) {
        const x = newPoints[i] = reducedPoints[i] * xScale;
        const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;
        line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);
        [x1, y1, x2, y2] = [x2, y2, x, y];
      }
    }
    if (linesAndPoints.length === 0) {
      return null;
    }
    const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();
    outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);
    return {
      outline,
      newCurves,
      areContours,
      thickness,
      width,
      height
    };
  }
  static async compressSignature({
    outlines,
    areContours,
    thickness,
    width,
    height
  }) {
    let minDiff = Infinity;
    let maxDiff = -Infinity;
    let outlinesLength = 0;
    for (const points of outlines) {
      outlinesLength += points.length;
      for (let i = 2, ii = points.length; i < ii; i++) {
        const dx = points[i] - points[i - 2];
        minDiff = Math.min(minDiff, dx);
        maxDiff = Math.max(maxDiff, dx);
      }
    }
    let bufferType;
    if (minDiff >= -128 && maxDiff <= 127) {
      bufferType = Int8Array;
    } else if (minDiff >= -32768 && maxDiff <= 32767) {
      bufferType = Int16Array;
    } else {
      bufferType = Int32Array;
    }
    const len = outlines.length;
    const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;
    const header = new Uint32Array(headerLength);
    let offset = 0;
    header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;
    header[offset++] = 0;
    header[offset++] = width;
    header[offset++] = height;
    header[offset++] = areContours ? 0 : 1;
    header[offset++] = Math.max(0, Math.floor(thickness != null ? thickness : 0));
    header[offset++] = len;
    header[offset++] = bufferType.BYTES_PER_ELEMENT;
    for (const points of outlines) {
      header[offset++] = points.length - 2;
      header[offset++] = points[0];
      header[offset++] = points[1];
    }
    const cs = new CompressionStream("deflate-raw");
    const writer = cs.writable.getWriter();
    await writer.ready;
    writer.write(header);
    const BufferCtor = bufferType.prototype.constructor;
    for (const points of outlines) {
      const diffs = new BufferCtor(points.length - 2);
      for (let i = 2, ii = points.length; i < ii; i++) {
        diffs[i - 2] = points[i] - points[i - 2];
      }
      writer.write(diffs);
    }
    writer.close();
    const buf = await new Response(cs.readable).arrayBuffer();
    const bytes = new Uint8Array(buf);
    return toBase64Util(bytes);
  }
  static async decompressSignature(signatureData) {
    try {
      const bytes = fromBase64Util(signatureData);
      const {
        readable,
        writable
      } = new DecompressionStream("deflate-raw");
      const writer = writable.getWriter();
      await writer.ready;
      writer.write(bytes).then(async () => {
        await writer.ready;
        await writer.close();
      }).catch(() => {
      });
      let data = null;
      let offset = 0;
      for await (const chunk of readable) {
        data || (data = new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]));
        data.set(chunk, offset);
        offset += chunk.length;
      }
      const header = new Uint32Array(data.buffer, 0, data.length >> 2);
      const version2 = header[1];
      if (version2 !== 0) {
        throw new Error(`Invalid version: ${version2}`);
      }
      const width = header[2];
      const height = header[3];
      const areContours = header[4] === 0;
      const thickness = header[5];
      const numberOfDrawings = header[6];
      const bufferType = header[7];
      const outlines = [];
      const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;
      let diffs;
      switch (bufferType) {
        case Int8Array.BYTES_PER_ELEMENT:
          diffs = new Int8Array(data.buffer, diffsOffset);
          break;
        case Int16Array.BYTES_PER_ELEMENT:
          diffs = new Int16Array(data.buffer, diffsOffset);
          break;
        case Int32Array.BYTES_PER_ELEMENT:
          diffs = new Int32Array(data.buffer, diffsOffset);
          break;
      }
      offset = 0;
      for (let i = 0; i < numberOfDrawings; i++) {
        const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];
        const points = new Float32Array(len + 2);
        outlines.push(points);
        for (let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++) {
          points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];
        }
        for (let j = 0; j < len; j++) {
          points[j + 2] = points[j] + diffs[offset++];
        }
      }
      return {
        areContours,
        thickness,
        outlines,
        width,
        height
      };
    } catch (e) {
      warn(`decompressSignature: ${e}`);
      return null;
    }
  }
};
_PARAMETERS = new WeakMap();
_neighborIndexToId = new WeakSet();
neighborIndexToId_fn = function(i0, j0, i, j) {
  i -= i0;
  j -= j0;
  if (i === 0) {
    return j > 0 ? 0 : 4;
  }
  if (i === 1) {
    return j + 6;
  }
  return 2 - j;
};
_neighborIdToIndex = new WeakMap();
_clockwiseNonZero = new WeakSet();
clockwiseNonZero_fn = function(buf, width, i0, j0, i, j, offset) {
  const id = __privateMethod(this, _neighborIndexToId, neighborIndexToId_fn).call(this, i0, j0, i, j);
  for (let k = 0; k < 8; k++) {
    const kk = (-k + id - offset + 16) % 8;
    const shiftI = __privateGet(this, _neighborIdToIndex)[2 * kk];
    const shiftJ = __privateGet(this, _neighborIdToIndex)[2 * kk + 1];
    if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
      return kk;
    }
  }
  return -1;
};
_counterClockwiseNonZero = new WeakSet();
counterClockwiseNonZero_fn = function(buf, width, i0, j0, i, j, offset) {
  const id = __privateMethod(this, _neighborIndexToId, neighborIndexToId_fn).call(this, i0, j0, i, j);
  for (let k = 0; k < 8; k++) {
    const kk = (k + id + offset + 16) % 8;
    const shiftI = __privateGet(this, _neighborIdToIndex)[2 * kk];
    const shiftJ = __privateGet(this, _neighborIdToIndex)[2 * kk + 1];
    if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
      return kk;
    }
  }
  return -1;
};
_findContours = new WeakSet();
findContours_fn = function(buf, width, height, threshold) {
  const N = buf.length;
  const types = new Int32Array(N);
  for (let i = 0; i < N; i++) {
    types[i] = buf[i] <= threshold ? 1 : 0;
  }
  for (let i = 1; i < height - 1; i++) {
    types[i * width] = types[i * width + width - 1] = 0;
  }
  for (let i = 0; i < width; i++) {
    types[i] = types[width * height - 1 - i] = 0;
  }
  let nbd = 1;
  let lnbd;
  const contours = [];
  for (let i = 1; i < height - 1; i++) {
    lnbd = 1;
    for (let j = 1; j < width - 1; j++) {
      const ij = i * width + j;
      const pix = types[ij];
      if (pix === 0) {
        continue;
      }
      let i2 = i;
      let j2 = j;
      if (pix === 1 && types[ij - 1] === 0) {
        nbd += 1;
        j2 -= 1;
      } else if (pix >= 1 && types[ij + 1] === 0) {
        nbd += 1;
        j2 += 1;
        if (pix > 1) {
          lnbd = pix;
        }
      } else {
        if (pix !== 1) {
          lnbd = Math.abs(pix);
        }
        continue;
      }
      const points = [j, i];
      const isHole = j2 === j + 1;
      const contour = {
        isHole,
        points,
        id: nbd,
        parent: 0
      };
      contours.push(contour);
      let contour0;
      for (const c of contours) {
        if (c.id === lnbd) {
          contour0 = c;
          break;
        }
      }
      if (!contour0) {
        contour.parent = isHole ? lnbd : 0;
      } else if (contour0.isHole) {
        contour.parent = isHole ? contour0.parent : lnbd;
      } else {
        contour.parent = isHole ? lnbd : contour0.parent;
      }
      const k = __privateMethod(this, _clockwiseNonZero, clockwiseNonZero_fn).call(this, types, width, i, j, i2, j2, 0);
      if (k === -1) {
        types[ij] = -nbd;
        if (types[ij] !== 1) {
          lnbd = Math.abs(types[ij]);
        }
        continue;
      }
      let shiftI = __privateGet(this, _neighborIdToIndex)[2 * k];
      let shiftJ = __privateGet(this, _neighborIdToIndex)[2 * k + 1];
      const i1 = i + shiftI;
      const j1 = j + shiftJ;
      i2 = i1;
      j2 = j1;
      let i3 = i;
      let j3 = j;
      while (true) {
        const kk = __privateMethod(this, _counterClockwiseNonZero, counterClockwiseNonZero_fn).call(this, types, width, i3, j3, i2, j2, 1);
        shiftI = __privateGet(this, _neighborIdToIndex)[2 * kk];
        shiftJ = __privateGet(this, _neighborIdToIndex)[2 * kk + 1];
        const i4 = i3 + shiftI;
        const j4 = j3 + shiftJ;
        points.push(j4, i4);
        const ij3 = i3 * width + j3;
        if (types[ij3 + 1] === 0) {
          types[ij3] = -nbd;
        } else if (types[ij3] === 1) {
          types[ij3] = nbd;
        }
        if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {
          if (types[ij] !== 1) {
            lnbd = Math.abs(types[ij]);
          }
          break;
        } else {
          i2 = i3;
          j2 = j3;
          i3 = i4;
          j3 = j4;
        }
      }
    }
  }
  return contours;
};
_douglasPeuckerHelper = new WeakSet();
douglasPeuckerHelper_fn = function(points, start, end, output) {
  if (end - start <= 4) {
    for (let i = start; i < end - 2; i += 2) {
      output.push(points[i], points[i + 1]);
    }
    return;
  }
  const ax = points[start];
  const ay = points[start + 1];
  const abx = points[end - 4] - ax;
  const aby = points[end - 3] - ay;
  const dist = Math.hypot(abx, aby);
  const nabx = abx / dist;
  const naby = aby / dist;
  const aa = nabx * ay - naby * ax;
  const m = aby / abx;
  const invS = 1 / dist;
  const phi = Math.atan(m);
  const cosPhi = Math.cos(phi);
  const sinPhi = Math.sin(phi);
  const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));
  const poly = invS * (1 - tmax + tmax ** 2);
  const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));
  let dmax = 0;
  let index = start;
  for (let i = start + 2; i < end - 2; i += 2) {
    const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);
    if (d > dmax) {
      index = i;
      dmax = d;
    }
  }
  if (dmax > (dist * partialPhi) ** 2) {
    __privateMethod(this, _douglasPeuckerHelper, douglasPeuckerHelper_fn).call(this, points, start, index + 2, output);
    __privateMethod(this, _douglasPeuckerHelper, douglasPeuckerHelper_fn).call(this, points, index, end, output);
  } else {
    output.push(ax, ay);
  }
};
_douglasPeucker = new WeakSet();
douglasPeucker_fn = function(points) {
  const output = [];
  const len = points.length;
  __privateMethod(this, _douglasPeuckerHelper, douglasPeuckerHelper_fn).call(this, points, 0, len, output);
  output.push(points[len - 2], points[len - 1]);
  return output.length <= 4 ? null : output;
};
_bilateralFilter = new WeakSet();
bilateralFilter_fn = function(buf, width, height, sigmaS, sigmaR, kernelSize) {
  const kernel = new Float32Array(kernelSize ** 2);
  const sigmaS2 = -2 * sigmaS ** 2;
  const halfSize = kernelSize >> 1;
  for (let i = 0; i < kernelSize; i++) {
    const x = (i - halfSize) ** 2;
    for (let j = 0; j < kernelSize; j++) {
      kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);
    }
  }
  const rangeValues = new Float32Array(256);
  const sigmaR2 = -2 * sigmaR ** 2;
  for (let i = 0; i < 256; i++) {
    rangeValues[i] = Math.exp(i ** 2 / sigmaR2);
  }
  const N = buf.length;
  const out = new Uint8Array(N);
  const histogram = new Uint32Array(256);
  for (let i = 0; i < height; i++) {
    for (let j = 0; j < width; j++) {
      const ij = i * width + j;
      const center = buf[ij];
      let sum = 0;
      let norm = 0;
      for (let k = 0; k < kernelSize; k++) {
        const y = i + k - halfSize;
        if (y < 0 || y >= height) {
          continue;
        }
        for (let l = 0; l < kernelSize; l++) {
          const x = j + l - halfSize;
          if (x < 0 || x >= width) {
            continue;
          }
          const neighbour = buf[y * width + x];
          const w = kernel[k * kernelSize + l] * rangeValues[Math.abs(neighbour - center)];
          sum += neighbour * w;
          norm += w;
        }
      }
      const pix = out[ij] = Math.round(sum / norm);
      histogram[pix]++;
    }
  }
  return [out, histogram];
};
_getHistogram = new WeakSet();
getHistogram_fn = function(buf) {
  const histogram = new Uint32Array(256);
  for (const g of buf) {
    histogram[g]++;
  }
  return histogram;
};
_toUint8 = new WeakSet();
toUint8_fn = function(buf) {
  const N = buf.length;
  const out = new Uint8ClampedArray(N >> 2);
  let max2 = -Infinity;
  let min = Infinity;
  for (let i = 0, ii = out.length; i < ii; i++) {
    const pix = out[i] = buf[i << 2];
    max2 = Math.max(max2, pix);
    min = Math.min(min, pix);
  }
  const ratio = 255 / (max2 - min);
  for (let i = 0, ii = out.length; i < ii; i++) {
    out[i] = (out[i] - min) * ratio;
  }
  return out;
};
_guessThreshold = new WeakSet();
guessThreshold_fn = function(histogram) {
  let i;
  let M = -Infinity;
  let L = -Infinity;
  const min = histogram.findIndex((v) => v !== 0);
  let pos = min;
  let spos = min;
  for (i = min; i < 256; i++) {
    const v = histogram[i];
    if (v > M) {
      if (i - pos > L) {
        L = i - pos;
        spos = i - 1;
      }
      M = v;
      pos = i;
    }
  }
  for (i = spos - 1; i >= 0; i--) {
    if (histogram[i] > histogram[i + 1]) {
      break;
    }
  }
  return i;
};
_getGrayPixels = new WeakSet();
getGrayPixels_fn = function(bitmap) {
  const originalBitmap = bitmap;
  const {
    width,
    height
  } = bitmap;
  const {
    maxDim
  } = __privateGet(this, _PARAMETERS);
  let newWidth = width;
  let newHeight = height;
  if (width > maxDim || height > maxDim) {
    let prevWidth = width;
    let prevHeight = height;
    let steps = Math.log2(Math.max(width, height) / maxDim);
    const isteps = Math.floor(steps);
    steps = steps === isteps ? isteps - 1 : isteps;
    for (let i = 0; i < steps; i++) {
      newWidth = Math.ceil(prevWidth / 2);
      newHeight = Math.ceil(prevHeight / 2);
      const offscreen2 = new OffscreenCanvas(newWidth, newHeight);
      const ctx2 = offscreen2.getContext("2d");
      ctx2.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
      prevWidth = newWidth;
      prevHeight = newHeight;
      if (bitmap !== originalBitmap) {
        bitmap.close();
      }
      bitmap = offscreen2.transferToImageBitmap();
    }
    const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);
    newWidth = Math.round(newWidth * ratio);
    newHeight = Math.round(newHeight * ratio);
  }
  const offscreen = new OffscreenCanvas(newWidth, newHeight);
  const ctx = offscreen.getContext("2d", {
    willReadFrequently: true
  });
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, newWidth, newHeight);
  ctx.filter = "grayscale(1)";
  ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);
  const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;
  const uint8Buf = __privateMethod(this, _toUint8, toUint8_fn).call(this, grayImage);
  return [uint8Buf, newWidth, newHeight];
};
__privateAdd(SignatureExtractor, _neighborIndexToId);
__privateAdd(SignatureExtractor, _clockwiseNonZero);
__privateAdd(SignatureExtractor, _counterClockwiseNonZero);
__privateAdd(SignatureExtractor, _findContours);
__privateAdd(SignatureExtractor, _douglasPeuckerHelper);
__privateAdd(SignatureExtractor, _douglasPeucker);
__privateAdd(SignatureExtractor, _bilateralFilter);
__privateAdd(SignatureExtractor, _getHistogram);
__privateAdd(SignatureExtractor, _toUint8);
__privateAdd(SignatureExtractor, _guessThreshold);
__privateAdd(SignatureExtractor, _getGrayPixels);
__privateAdd(SignatureExtractor, _PARAMETERS, {
  maxDim: 512,
  sigmaSFactor: 0.02,
  sigmaR: 25,
  kernelSize: 16
});
__privateAdd(SignatureExtractor, _neighborIdToIndex, new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]));
var SignatureOptions = class _SignatureOptions extends DrawingOptions {
  constructor() {
    super();
    super.updateProperties({
      fill: AnnotationEditor._defaultLineColor,
      "stroke-width": 0
    });
  }
  clone() {
    const clone = new _SignatureOptions();
    clone.updateAll(this);
    return clone;
  }
};
var DrawnSignatureOptions = class _DrawnSignatureOptions extends InkDrawingOptions {
  constructor(viewerParameters) {
    super(viewerParameters);
    super.updateProperties({
      stroke: AnnotationEditor._defaultLineColor,
      "stroke-width": 1
    });
  }
  clone() {
    const clone = new _DrawnSignatureOptions(this._viewParameters);
    clone.updateAll(this);
    return clone;
  }
};
var _isExtracted, _description, _signatureData, _signatureUUID;
var _SignatureEditor = class _SignatureEditor extends DrawingEditor {
  constructor(params) {
    super({
      ...params,
      mustBeCommitted: true,
      name: "signatureEditor"
    });
    __privateAdd(this, _isExtracted, false);
    __privateAdd(this, _description, null);
    __privateAdd(this, _signatureData, null);
    __privateAdd(this, _signatureUUID, null);
    this._willKeepAspectRatio = true;
    __privateSet(this, _signatureData, params.signatureData || null);
    __privateSet(this, _description, null);
    this.defaultL10nId = "pdfjs-editor-signature-editor1";
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    this._defaultDrawingOptions = new SignatureOptions();
    this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);
  }
  static getDefaultDrawingOptions(options) {
    const clone = this._defaultDrawingOptions.clone();
    clone.updateProperties(options);
    return clone;
  }
  static get supportMultipleDrawings() {
    return false;
  }
  static get typesMap() {
    return shadow(this, "typesMap", /* @__PURE__ */ new Map());
  }
  static get isDrawer() {
    return false;
  }
  get telemetryFinalData() {
    return {
      type: "signature",
      hasDescription: !!__privateGet(this, _description)
    };
  }
  static computeTelemetryFinalData(data) {
    var _a3, _b2;
    const hasDescriptionStats = data.get("hasDescription");
    return {
      hasAltText: (_a3 = hasDescriptionStats.get(true)) != null ? _a3 : 0,
      hasNoAltText: (_b2 = hasDescriptionStats.get(false)) != null ? _b2 : 0
    };
  }
  get isResizable() {
    return true;
  }
  onScaleChanging() {
    if (this._drawId === null) {
      return;
    }
    super.onScaleChanging();
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    const {
      _isCopy
    } = this;
    if (_isCopy) {
      this._isCopy = false;
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    if (this._drawId === null) {
      if (__privateGet(this, _signatureData)) {
        const {
          lines,
          mustSmooth,
          areContours,
          description,
          uuid,
          heightInPage
        } = __privateGet(this, _signatureData);
        const {
          rawDims: {
            pageWidth,
            pageHeight
          },
          rotation
        } = this.parent.viewport;
        const outline = SignatureExtractor.processDrawnLines({
          lines,
          pageWidth,
          pageHeight,
          rotation,
          innerMargin: _SignatureEditor._INNER_MARGIN,
          mustSmooth,
          areContours
        });
        this.addSignature(outline, heightInPage, description, uuid);
      } else {
        this.div.setAttribute("data-l10n-args", JSON.stringify({
          description: ""
        }));
        this.div.hidden = true;
        this._uiManager.getSignature(this);
      }
    } else {
      this.div.setAttribute("data-l10n-args", JSON.stringify({
        description: __privateGet(this, _description) || ""
      }));
    }
    if (_isCopy) {
      this._isCopy = true;
      this._moveAfterPaste(baseX, baseY);
    }
    return this.div;
  }
  setUuid(uuid) {
    __privateSet(this, _signatureUUID, uuid);
    this.addEditToolbar();
  }
  getUuid() {
    return __privateGet(this, _signatureUUID);
  }
  get description() {
    return __privateGet(this, _description);
  }
  set description(description) {
    __privateSet(this, _description, description);
    if (!this.div) {
      return;
    }
    this.div.setAttribute("data-l10n-args", JSON.stringify({
      description
    }));
    super.addEditToolbar().then((toolbar) => {
      toolbar == null ? void 0 : toolbar.updateEditSignatureButton(description);
    });
  }
  getSignaturePreview() {
    const {
      newCurves,
      areContours,
      thickness,
      width,
      height
    } = __privateGet(this, _signatureData);
    const maxDim = Math.max(width, height);
    const outlineData = SignatureExtractor.processDrawnLines({
      lines: {
        curves: newCurves.map((points) => ({
          points
        })),
        thickness,
        width,
        height
      },
      pageWidth: maxDim,
      pageHeight: maxDim,
      rotation: 0,
      innerMargin: 0,
      mustSmooth: false,
      areContours
    });
    return {
      areContours,
      outline: outlineData.outline
    };
  }
  get toolbarButtons() {
    if (this._uiManager.signatureManager) {
      return [["editSignature", this._uiManager.signatureManager]];
    }
    return super.toolbarButtons;
  }
  addSignature(data, heightInPage, description, uuid) {
    const {
      x: savedX,
      y: savedY
    } = this;
    const {
      outline
    } = __privateSet(this, _signatureData, data);
    __privateSet(this, _isExtracted, outline instanceof ContourDrawOutline);
    this.description = description;
    let drawingOptions;
    if (__privateGet(this, _isExtracted)) {
      drawingOptions = _SignatureEditor.getDefaultDrawingOptions();
    } else {
      drawingOptions = _SignatureEditor._defaultDrawnSignatureOptions.clone();
      drawingOptions.updateProperties({
        "stroke-width": outline.thickness
      });
    }
    this._addOutlines({
      drawOutlines: outline,
      drawingOptions
    });
    const [parentWidth, parentHeight] = this.parentDimensions;
    const [, pageHeight] = this.pageDimensions;
    let newHeight = heightInPage / pageHeight;
    newHeight = newHeight >= 1 ? 0.5 : newHeight;
    this.width *= newHeight / this.height;
    if (this.width >= 1) {
      newHeight *= 0.9 / this.width;
      this.width = 0.9;
    }
    this.height = newHeight;
    this.setDims(parentWidth * this.width, parentHeight * this.height);
    this.x = savedX;
    this.y = savedY;
    this.center();
    this._onResized();
    this.onScaleChanging();
    this.rotate();
    this._uiManager.addToAnnotationStorage(this);
    this.setUuid(uuid);
    this._reportTelemetry({
      action: "pdfjs.signature.inserted",
      data: {
        hasBeenSaved: !!uuid,
        hasDescription: !!description
      }
    });
    this.div.hidden = false;
  }
  getFromImage(bitmap) {
    const {
      rawDims: {
        pageWidth,
        pageHeight
      },
      rotation
    } = this.parent.viewport;
    return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, _SignatureEditor._INNER_MARGIN);
  }
  getFromText(text, fontInfo) {
    const {
      rawDims: {
        pageWidth,
        pageHeight
      },
      rotation
    } = this.parent.viewport;
    return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, _SignatureEditor._INNER_MARGIN);
  }
  getDrawnSignature(curves) {
    const {
      rawDims: {
        pageWidth,
        pageHeight
      },
      rotation
    } = this.parent.viewport;
    return SignatureExtractor.processDrawnLines({
      lines: curves,
      pageWidth,
      pageHeight,
      rotation,
      innerMargin: _SignatureEditor._INNER_MARGIN,
      mustSmooth: false,
      areContours: false
    });
  }
  createDrawingOptions({
    areContours,
    thickness
  }) {
    if (areContours) {
      this._drawingOptions = _SignatureEditor.getDefaultDrawingOptions();
    } else {
      this._drawingOptions = _SignatureEditor._defaultDrawnSignatureOptions.clone();
      this._drawingOptions.updateProperties({
        "stroke-width": thickness
      });
    }
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    const {
      lines,
      points,
      rect
    } = this.serializeDraw(isForCopying);
    const {
      _drawingOptions: {
        "stroke-width": thickness
      }
    } = this;
    const serialized = {
      annotationType: AnnotationEditorType.SIGNATURE,
      isSignature: true,
      areContours: __privateGet(this, _isExtracted),
      color: [0, 0, 0],
      thickness: __privateGet(this, _isExtracted) ? 0 : thickness,
      pageIndex: this.pageIndex,
      rect,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    this.addComment(serialized);
    if (isForCopying) {
      serialized.paths = {
        lines,
        points
      };
      serialized.uuid = __privateGet(this, _signatureUUID);
      serialized.isCopy = true;
    } else {
      serialized.lines = lines;
    }
    if (__privateGet(this, _description)) {
      serialized.accessibilityData = {
        type: "Figure",
        alt: __privateGet(this, _description)
      };
    }
    return serialized;
  }
  static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
    if (data.areContours) {
      return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
    }
    return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
  }
  static async deserialize(data, parent, uiManager) {
    var _a3;
    const editor = await super.deserialize(data, parent, uiManager);
    __privateSet(editor, _isExtracted, data.areContours);
    editor.description = ((_a3 = data.accessibilityData) == null ? void 0 : _a3.alt) || "";
    __privateSet(editor, _signatureUUID, data.uuid);
    return editor;
  }
};
_isExtracted = new WeakMap();
_description = new WeakMap();
_signatureData = new WeakMap();
_signatureUUID = new WeakMap();
__publicField(_SignatureEditor, "_type", "signature");
__publicField(_SignatureEditor, "_editorType", AnnotationEditorType.SIGNATURE);
__publicField(_SignatureEditor, "_defaultDrawingOptions", null);
var SignatureEditor = _SignatureEditor;
var _bitmap, _bitmapId, _bitmapPromise, _bitmapUrl, _bitmapFile, _bitmapFileName, _canvas, _missingCanvas, _resizeTimeoutId, _isSvg, _hasBeenAddedInUndoStack, _getBitmapFetched, getBitmapFetched_fn, _getBitmapDone, getBitmapDone_fn, _getBitmap, getBitmap_fn, _createCanvas, createCanvas_fn, _scaleBitmap, scaleBitmap_fn, _drawBitmap, drawBitmap_fn, _serializeBitmap, serializeBitmap_fn, _hasElementChanged4, hasElementChanged_fn4;
var StampEditor = class extends AnnotationEditor {
  constructor(params) {
    super({
      ...params,
      name: "stampEditor"
    });
    __privateAdd(this, _getBitmapFetched);
    __privateAdd(this, _getBitmapDone);
    __privateAdd(this, _getBitmap);
    __privateAdd(this, _createCanvas);
    __privateAdd(this, _scaleBitmap);
    __privateAdd(this, _drawBitmap);
    __privateAdd(this, _serializeBitmap);
    __privateAdd(this, _hasElementChanged4);
    __privateAdd(this, _bitmap, null);
    __privateAdd(this, _bitmapId, null);
    __privateAdd(this, _bitmapPromise, null);
    __privateAdd(this, _bitmapUrl, null);
    __privateAdd(this, _bitmapFile, null);
    __privateAdd(this, _bitmapFileName, "");
    __privateAdd(this, _canvas, null);
    __privateAdd(this, _missingCanvas, false);
    __privateAdd(this, _resizeTimeoutId, null);
    __privateAdd(this, _isSvg, false);
    __privateAdd(this, _hasBeenAddedInUndoStack, false);
    __privateSet(this, _bitmapUrl, params.bitmapUrl);
    __privateSet(this, _bitmapFile, params.bitmapFile);
    this.defaultL10nId = "pdfjs-editor-stamp-editor";
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
  }
  static isHandlingMimeForPasting(mime) {
    return SupportedImageMimeTypes.includes(mime);
  }
  static paste(item, parent) {
    parent.pasteEditor({
      mode: AnnotationEditorType.STAMP
    }, {
      bitmapFile: item.getAsFile()
    });
  }
  altTextFinish() {
    if (this._uiManager.useNewAltTextFlow) {
      this.div.hidden = false;
    }
    super.altTextFinish();
  }
  get telemetryFinalData() {
    var _a3;
    return {
      type: "stamp",
      hasAltText: !!((_a3 = this.altTextData) == null ? void 0 : _a3.altText)
    };
  }
  static computeTelemetryFinalData(data) {
    var _a3, _b2;
    const hasAltTextStats = data.get("hasAltText");
    return {
      hasAltText: (_a3 = hasAltTextStats.get(true)) != null ? _a3 : 0,
      hasNoAltText: (_b2 = hasAltTextStats.get(false)) != null ? _b2 : 0
    };
  }
  async mlGuessAltText(imageData = null, updateAltTextData = true) {
    if (this.hasAltTextData()) {
      return null;
    }
    const {
      mlManager
    } = this._uiManager;
    if (!mlManager) {
      throw new Error("No ML.");
    }
    if (!await mlManager.isEnabledFor("altText")) {
      throw new Error("ML isn't enabled for alt text.");
    }
    const {
      data,
      width,
      height
    } = imageData || this.copyCanvas(null, null, true).imageData;
    const response = await mlManager.guess({
      name: "altText",
      request: {
        data,
        width,
        height,
        channels: data.length / (width * height)
      }
    });
    if (!response) {
      throw new Error("No response from the AI service.");
    }
    if (response.error) {
      throw new Error("Error from the AI service.");
    }
    if (response.cancel) {
      return null;
    }
    if (!response.output) {
      throw new Error("No valid response from the AI service.");
    }
    const altText = response.output;
    await this.setGuessedAltText(altText);
    if (updateAltTextData && !this.hasAltTextData()) {
      this.altTextData = {
        alt: altText,
        decorative: false
      };
    }
    return altText;
  }
  remove() {
    var _a3;
    if (__privateGet(this, _bitmapId)) {
      __privateSet(this, _bitmap, null);
      this._uiManager.imageManager.deleteId(__privateGet(this, _bitmapId));
      (_a3 = __privateGet(this, _canvas)) == null ? void 0 : _a3.remove();
      __privateSet(this, _canvas, null);
      if (__privateGet(this, _resizeTimeoutId)) {
        clearTimeout(__privateGet(this, _resizeTimeoutId));
        __privateSet(this, _resizeTimeoutId, null);
      }
    }
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      if (__privateGet(this, _bitmapId)) {
        __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
      }
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (__privateGet(this, _bitmapId) && __privateGet(this, _canvas) === null) {
      __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  onceAdded(focus) {
    this._isDraggable = true;
    if (focus) {
      this.div.focus();
    }
  }
  isEmpty() {
    return !(__privateGet(this, _bitmapPromise) || __privateGet(this, _bitmap) || __privateGet(this, _bitmapUrl) || __privateGet(this, _bitmapFile) || __privateGet(this, _bitmapId) || __privateGet(this, _missingCanvas));
  }
  get toolbarButtons() {
    return [["altText", this.createAltText()]];
  }
  get isResizable() {
    return true;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this._isCopy) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.div.hidden = true;
    this.createAltText();
    if (!__privateGet(this, _missingCanvas)) {
      if (__privateGet(this, _bitmap)) {
        __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
      } else {
        __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
      }
    }
    if (this._isCopy) {
      this._moveAfterPaste(baseX, baseY);
    }
    this._uiManager.addShouldRescale(this);
    return this.div;
  }
  setCanvas(annotationElementId, canvas) {
    const {
      id: bitmapId,
      bitmap
    } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);
    canvas.remove();
    if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {
      __privateSet(this, _bitmapId, bitmapId);
      if (bitmap) {
        __privateSet(this, _bitmap, bitmap);
      }
      __privateSet(this, _missingCanvas, false);
      __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
    }
  }
  _onResized() {
    this.onScaleChanging();
  }
  onScaleChanging() {
    if (!this.parent) {
      return;
    }
    if (__privateGet(this, _resizeTimeoutId) !== null) {
      clearTimeout(__privateGet(this, _resizeTimeoutId));
    }
    const TIME_TO_WAIT = 200;
    __privateSet(this, _resizeTimeoutId, setTimeout(() => {
      __privateSet(this, _resizeTimeoutId, null);
      __privateMethod(this, _drawBitmap, drawBitmap_fn).call(this);
    }, TIME_TO_WAIT));
  }
  copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {
    var _a3;
    if (!maxDataDimension) {
      maxDataDimension = 224;
    }
    const {
      width: bitmapWidth,
      height: bitmapHeight
    } = __privateGet(this, _bitmap);
    const outputScale = new OutputScale();
    let bitmap = __privateGet(this, _bitmap);
    let width = bitmapWidth, height = bitmapHeight;
    let canvas = null;
    if (maxPreviewDimension) {
      if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {
        const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);
        width = Math.floor(bitmapWidth * ratio);
        height = Math.floor(bitmapHeight * ratio);
      }
      canvas = document.createElement("canvas");
      const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);
      const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);
      if (!__privateGet(this, _isSvg)) {
        bitmap = __privateMethod(this, _scaleBitmap, scaleBitmap_fn).call(this, scaledWidth, scaledHeight);
      }
      const ctx = canvas.getContext("2d");
      ctx.filter = this._uiManager.hcmFilter;
      let white = "white", black = "#cfcfd8";
      if (this._uiManager.hcmFilter !== "none") {
        black = "black";
      } else if ((_a3 = window.matchMedia) == null ? void 0 : _a3.call(window, "(prefers-color-scheme: dark)").matches) {
        white = "#8f8f9d";
        black = "#42414d";
      }
      const boxDim = 15;
      const boxDimWidth = boxDim * outputScale.sx;
      const boxDimHeight = boxDim * outputScale.sy;
      const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);
      const patternCtx = pattern.getContext("2d");
      patternCtx.fillStyle = white;
      patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);
      patternCtx.fillStyle = black;
      patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);
      patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);
      ctx.fillStyle = ctx.createPattern(pattern, "repeat");
      ctx.fillRect(0, 0, scaledWidth, scaledHeight);
      ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
    }
    let imageData = null;
    if (createImageData) {
      let dataWidth, dataHeight;
      if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {
        dataWidth = bitmap.width;
        dataHeight = bitmap.height;
      } else {
        bitmap = __privateGet(this, _bitmap);
        if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {
          const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);
          dataWidth = Math.floor(bitmapWidth * ratio);
          dataHeight = Math.floor(bitmapHeight * ratio);
          if (!__privateGet(this, _isSvg)) {
            bitmap = __privateMethod(this, _scaleBitmap, scaleBitmap_fn).call(this, dataWidth, dataHeight);
          }
        }
      }
      const offscreen = new OffscreenCanvas(dataWidth, dataHeight);
      const offscreenCtx = offscreen.getContext("2d", {
        willReadFrequently: true
      });
      offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);
      imageData = {
        width: dataWidth,
        height: dataHeight,
        data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data
      };
    }
    return {
      canvas,
      width,
      height,
      imageData
    };
  }
  static async deserialize(data, parent, uiManager) {
    var _a3;
    let initialData = null;
    let missingCanvas = false;
    if (data instanceof StampAnnotationElement) {
      const {
        data: {
          rect: rect2,
          rotation,
          id,
          structParent,
          popupRef,
          contentsObj
        },
        container,
        parent: {
          page: {
            pageNumber
          }
        },
        canvas
      } = data;
      let bitmapId2, bitmap2;
      if (canvas) {
        delete data.canvas;
        ({
          id: bitmapId2,
          bitmap: bitmap2
        } = uiManager.imageManager.getFromCanvas(container.id, canvas));
        canvas.remove();
      } else {
        missingCanvas = true;
        data._hasNoCanvas = true;
      }
      const altText = ((_a3 = await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`)) == null ? void 0 : _a3.get("aria-label")) || "";
      initialData = data = {
        annotationType: AnnotationEditorType.STAMP,
        bitmapId: bitmapId2,
        bitmap: bitmap2,
        pageIndex: pageNumber - 1,
        rect: rect2.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        accessibilityData: {
          decorative: false,
          altText
        },
        isSvg: false,
        structParent,
        popupRef,
        comment: (contentsObj == null ? void 0 : contentsObj.str) || null
      };
    }
    const editor = await super.deserialize(data, parent, uiManager);
    const {
      rect,
      bitmap,
      bitmapUrl,
      bitmapId,
      isSvg,
      accessibilityData
    } = data;
    if (missingCanvas) {
      uiManager.addMissingCanvas(data.id, editor);
      __privateSet(editor, _missingCanvas, true);
    } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
      __privateSet(editor, _bitmapId, bitmapId);
      if (bitmap) {
        __privateSet(editor, _bitmap, bitmap);
      }
    } else {
      __privateSet(editor, _bitmapUrl, bitmapUrl);
    }
    __privateSet(editor, _isSvg, isSvg);
    const [parentWidth, parentHeight] = editor.pageDimensions;
    editor.width = (rect[2] - rect[0]) / parentWidth;
    editor.height = (rect[3] - rect[1]) / parentHeight;
    if (accessibilityData) {
      editor.altTextData = accessibilityData;
    }
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data.comment);
    }
    __privateSet(editor, _hasBeenAddedInUndoStack, !!initialData);
    return editor;
  }
  serialize(isForCopying = false, context = null) {
    var _a3;
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const serialized = {
      annotationType: AnnotationEditorType.STAMP,
      bitmapId: __privateGet(this, _bitmapId),
      pageIndex: this.pageIndex,
      rect: this.getPDFRect(),
      rotation: this.rotation,
      isSvg: __privateGet(this, _isSvg),
      structTreeParentId: this._structTreeParentId
    };
    this.addComment(serialized);
    if (isForCopying) {
      serialized.bitmapUrl = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, true);
      serialized.accessibilityData = this.serializeAltText(true);
      serialized.isCopy = true;
      return serialized;
    }
    const {
      decorative,
      altText
    } = this.serializeAltText(false);
    if (!decorative && altText) {
      serialized.accessibilityData = {
        type: "Figure",
        alt: altText
      };
    }
    if (this.annotationElementId) {
      const changes = __privateMethod(this, _hasElementChanged4, hasElementChanged_fn4).call(this, serialized);
      if (changes.isSame) {
        return null;
      }
      if (changes.isSameAltText) {
        delete serialized.accessibilityData;
      } else {
        serialized.accessibilityData.structParent = (_a3 = this._initialData.structParent) != null ? _a3 : -1;
      }
    }
    serialized.id = this.annotationElementId;
    if (context === null) {
      return serialized;
    }
    context.stamps || (context.stamps = /* @__PURE__ */ new Map());
    const area = __privateGet(this, _isSvg) ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
    if (!context.stamps.has(__privateGet(this, _bitmapId))) {
      context.stamps.set(__privateGet(this, _bitmapId), {
        area,
        serialized
      });
      serialized.bitmap = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, false);
    } else if (__privateGet(this, _isSvg)) {
      const prevData = context.stamps.get(__privateGet(this, _bitmapId));
      if (area > prevData.area) {
        prevData.area = area;
        prevData.serialized.bitmap.close();
        prevData.serialized.bitmap = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, false);
      }
    }
    return serialized;
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    const params = {
      rect: this.getPDFRect()
    };
    if (this.hasEditedComment) {
      params.popup = this.comment;
    }
    annotation.updateEdited(params);
    return null;
  }
};
_bitmap = new WeakMap();
_bitmapId = new WeakMap();
_bitmapPromise = new WeakMap();
_bitmapUrl = new WeakMap();
_bitmapFile = new WeakMap();
_bitmapFileName = new WeakMap();
_canvas = new WeakMap();
_missingCanvas = new WeakMap();
_resizeTimeoutId = new WeakMap();
_isSvg = new WeakMap();
_hasBeenAddedInUndoStack = new WeakMap();
_getBitmapFetched = new WeakSet();
getBitmapFetched_fn = function(data, fromId = false) {
  if (!data) {
    this.remove();
    return;
  }
  __privateSet(this, _bitmap, data.bitmap);
  if (!fromId) {
    __privateSet(this, _bitmapId, data.id);
    __privateSet(this, _isSvg, data.isSvg);
  }
  if (data.file) {
    __privateSet(this, _bitmapFileName, data.file.name);
  }
  __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
};
_getBitmapDone = new WeakSet();
getBitmapDone_fn = function() {
  __privateSet(this, _bitmapPromise, null);
  this._uiManager.enableWaiting(false);
  if (!__privateGet(this, _canvas)) {
    return;
  }
  if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _bitmap)) {
    this.addEditToolbar().then(() => {
      this._editToolbar.hide();
      this._uiManager.editAltText(this, true);
    });
    return;
  }
  if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _bitmap)) {
    this._reportTelemetry({
      action: "pdfjs.image.image_added",
      data: {
        alt_text_modal: false,
        alt_text_type: "empty"
      }
    });
    try {
      this.mlGuessAltText();
    } catch (e) {
    }
  }
  this.div.focus();
};
_getBitmap = new WeakSet();
getBitmap_fn = function() {
  if (__privateGet(this, _bitmapId)) {
    this._uiManager.enableWaiting(true);
    this._uiManager.imageManager.getFromId(__privateGet(this, _bitmapId)).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data, true)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this));
    return;
  }
  if (__privateGet(this, _bitmapUrl)) {
    const url = __privateGet(this, _bitmapUrl);
    __privateSet(this, _bitmapUrl, null);
    this._uiManager.enableWaiting(true);
    __privateSet(this, _bitmapPromise, this._uiManager.imageManager.getFromUrl(url).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
    return;
  }
  if (__privateGet(this, _bitmapFile)) {
    const file = __privateGet(this, _bitmapFile);
    __privateSet(this, _bitmapFile, null);
    this._uiManager.enableWaiting(true);
    __privateSet(this, _bitmapPromise, this._uiManager.imageManager.getFromFile(file).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
    return;
  }
  const input = document.createElement("input");
  input.type = "file";
  input.accept = SupportedImageMimeTypes.join(",");
  const signal = this._uiManager._signal;
  __privateSet(this, _bitmapPromise, new Promise((resolve) => {
    input.addEventListener("change", async () => {
      if (!input.files || input.files.length === 0) {
        this.remove();
      } else {
        this._uiManager.enableWaiting(true);
        const data = await this._uiManager.imageManager.getFromFile(input.files[0]);
        this._reportTelemetry({
          action: "pdfjs.image.image_selected",
          data: {
            alt_text_modal: this._uiManager.useNewAltTextFlow
          }
        });
        __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data);
      }
      resolve();
    }, {
      signal
    });
    input.addEventListener("cancel", () => {
      this.remove();
      resolve();
    }, {
      signal
    });
  }).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
  input.click();
};
_createCanvas = new WeakSet();
createCanvas_fn = function() {
  var _a3;
  const {
    div
  } = this;
  let {
    width,
    height
  } = __privateGet(this, _bitmap);
  const [pageWidth, pageHeight] = this.pageDimensions;
  const MAX_RATIO = 0.75;
  if (this.width) {
    width = this.width * pageWidth;
    height = this.height * pageHeight;
  } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
    const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
    width *= factor;
    height *= factor;
  }
  const [parentWidth, parentHeight] = this.parentDimensions;
  this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);
  this._uiManager.enableWaiting(false);
  const canvas = __privateSet(this, _canvas, document.createElement("canvas"));
  canvas.setAttribute("role", "img");
  this.addContainer(canvas);
  this.width = width / pageWidth;
  this.height = height / pageHeight;
  if ((_a3 = this._initialOptions) == null ? void 0 : _a3.isCentered) {
    this.center();
  } else {
    this.fixAndSetPosition();
  }
  this._initialOptions = null;
  if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {
    div.hidden = false;
  }
  __privateMethod(this, _drawBitmap, drawBitmap_fn).call(this);
  if (!__privateGet(this, _hasBeenAddedInUndoStack)) {
    this.parent.addUndoableEditor(this);
    __privateSet(this, _hasBeenAddedInUndoStack, true);
  }
  this._reportTelemetry({
    action: "inserted_image"
  });
  if (__privateGet(this, _bitmapFileName)) {
    this.div.setAttribute("aria-description", __privateGet(this, _bitmapFileName));
  }
  if (!this.annotationElementId) {
    this._uiManager.a11yAlert("pdfjs-editor-stamp-added-alert");
  }
};
_scaleBitmap = new WeakSet();
scaleBitmap_fn = function(width, height) {
  const {
    width: bitmapWidth,
    height: bitmapHeight
  } = __privateGet(this, _bitmap);
  let newWidth = bitmapWidth;
  let newHeight = bitmapHeight;
  let bitmap = __privateGet(this, _bitmap);
  while (newWidth > 2 * width || newHeight > 2 * height) {
    const prevWidth = newWidth;
    const prevHeight = newHeight;
    if (newWidth > 2 * width) {
      newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
    }
    if (newHeight > 2 * height) {
      newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
    }
    const offscreen = new OffscreenCanvas(newWidth, newHeight);
    const ctx = offscreen.getContext("2d");
    ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
    bitmap = offscreen.transferToImageBitmap();
  }
  return bitmap;
};
_drawBitmap = new WeakSet();
drawBitmap_fn = function() {
  const [parentWidth, parentHeight] = this.parentDimensions;
  const {
    width,
    height
  } = this;
  const outputScale = new OutputScale();
  const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);
  const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);
  const canvas = __privateGet(this, _canvas);
  if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {
    return;
  }
  canvas.width = scaledWidth;
  canvas.height = scaledHeight;
  const bitmap = __privateGet(this, _isSvg) ? __privateGet(this, _bitmap) : __privateMethod(this, _scaleBitmap, scaleBitmap_fn).call(this, scaledWidth, scaledHeight);
  const ctx = canvas.getContext("2d");
  ctx.filter = this._uiManager.hcmFilter;
  ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
};
_serializeBitmap = new WeakSet();
serializeBitmap_fn = function(toUrl) {
  if (toUrl) {
    if (__privateGet(this, _isSvg)) {
      const url = this._uiManager.imageManager.getSvgUrl(__privateGet(this, _bitmapId));
      if (url) {
        return url;
      }
    }
    const canvas = document.createElement("canvas");
    ({
      width: canvas.width,
      height: canvas.height
    } = __privateGet(this, _bitmap));
    const ctx = canvas.getContext("2d");
    ctx.drawImage(__privateGet(this, _bitmap), 0, 0);
    return canvas.toDataURL();
  }
  if (__privateGet(this, _isSvg)) {
    const [pageWidth, pageHeight] = this.pageDimensions;
    const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);
    const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);
    const offscreen = new OffscreenCanvas(width, height);
    const ctx = offscreen.getContext("2d");
    ctx.drawImage(__privateGet(this, _bitmap), 0, 0, __privateGet(this, _bitmap).width, __privateGet(this, _bitmap).height, 0, 0, width, height);
    return offscreen.transferToImageBitmap();
  }
  return structuredClone(__privateGet(this, _bitmap));
};
_hasElementChanged4 = new WeakSet();
hasElementChanged_fn4 = function(serialized) {
  var _a3;
  const {
    pageIndex,
    accessibilityData: {
      altText
    }
  } = this._initialData;
  const isSamePageIndex = serialized.pageIndex === pageIndex;
  const isSameAltText = (((_a3 = serialized.accessibilityData) == null ? void 0 : _a3.alt) || "") === altText;
  return {
    isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,
    isSameAltText
  };
};
__publicField(StampEditor, "_type", "stamp");
__publicField(StampEditor, "_editorType", AnnotationEditorType.STAMP);
var _accessibilityManager2, _allowClick, _annotationLayer, _clickAC, _editorFocusTimeoutId, _editors, _hadPointerDown, _isDisabling, _isEnabling, _drawingAC, _focusedElement, _textLayer, _textSelectionAC, _textLayerDblClickAC, _lastPointerDownTimestamp, _uiManager4, _editorTypes2, _textLayerPointerDown, textLayerPointerDown_fn, _currentEditorType, currentEditorType_get, _createNewEditor, createNewEditor_fn, _getCenterPoint, getCenterPoint_fn, _cleanup, cleanup_fn;
var _AnnotationEditorLayer = class _AnnotationEditorLayer {
  constructor({
    uiManager,
    pageIndex,
    div,
    structTreeLayer,
    accessibilityManager,
    annotationLayer,
    drawLayer,
    textLayer,
    viewport,
    l10n
  }) {
    __privateAdd(this, _textLayerPointerDown);
    __privateAdd(this, _currentEditorType);
    __privateAdd(this, _createNewEditor);
    __privateAdd(this, _getCenterPoint);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _accessibilityManager2, void 0);
    __privateAdd(this, _allowClick, false);
    __privateAdd(this, _annotationLayer, null);
    __privateAdd(this, _clickAC, null);
    __privateAdd(this, _editorFocusTimeoutId, null);
    __privateAdd(this, _editors, /* @__PURE__ */ new Map());
    __privateAdd(this, _hadPointerDown, false);
    __privateAdd(this, _isDisabling, false);
    __privateAdd(this, _isEnabling, false);
    __privateAdd(this, _drawingAC, null);
    __privateAdd(this, _focusedElement, null);
    __privateAdd(this, _textLayer, null);
    __privateAdd(this, _textSelectionAC, null);
    __privateAdd(this, _textLayerDblClickAC, null);
    __privateAdd(this, _lastPointerDownTimestamp, -1);
    __privateAdd(this, _uiManager4, void 0);
    const editorTypes = [...__privateGet(_AnnotationEditorLayer, _editorTypes2).values()];
    if (!_AnnotationEditorLayer._initialized) {
      _AnnotationEditorLayer._initialized = true;
      for (const editorType of editorTypes) {
        editorType.initialize(l10n, uiManager);
      }
    }
    uiManager.registerEditorTypes(editorTypes);
    __privateSet(this, _uiManager4, uiManager);
    this.pageIndex = pageIndex;
    this.div = div;
    __privateSet(this, _accessibilityManager2, accessibilityManager);
    __privateSet(this, _annotationLayer, annotationLayer);
    this.viewport = viewport;
    __privateSet(this, _textLayer, textLayer);
    this.drawLayer = drawLayer;
    this._structTree = structTreeLayer;
    __privateGet(this, _uiManager4).addLayer(this);
  }
  get isEmpty() {
    return __privateGet(this, _editors).size === 0;
  }
  get isInvisible() {
    return this.isEmpty && __privateGet(this, _uiManager4).getMode() === AnnotationEditorType.NONE;
  }
  updateToolbar(options) {
    __privateGet(this, _uiManager4).updateToolbar(options);
  }
  updateMode(mode = __privateGet(this, _uiManager4).getMode()) {
    __privateMethod(this, _cleanup, cleanup_fn).call(this);
    switch (mode) {
      case AnnotationEditorType.NONE:
        this.disableTextSelection();
        this.togglePointerEvents(false);
        this.toggleAnnotationLayerPointerEvents(true);
        this.disableClick();
        return;
      case AnnotationEditorType.INK:
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.enableClick();
        break;
      case AnnotationEditorType.HIGHLIGHT:
        this.enableTextSelection();
        this.togglePointerEvents(false);
        this.disableClick();
        break;
      default:
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(false);
    const {
      classList
    } = this.div;
    for (const editorType of __privateGet(_AnnotationEditorLayer, _editorTypes2).values()) {
      classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);
    }
    this.div.hidden = false;
  }
  hasTextLayer(textLayer) {
    var _a3;
    return textLayer === ((_a3 = __privateGet(this, _textLayer)) == null ? void 0 : _a3.div);
  }
  setEditingState(isEditing) {
    __privateGet(this, _uiManager4).setEditingState(isEditing);
  }
  addCommands(params) {
    __privateGet(this, _uiManager4).addCommands(params);
  }
  cleanUndoStack(type) {
    __privateGet(this, _uiManager4).cleanUndoStack(type);
  }
  toggleDrawing(enabled = false) {
    this.div.classList.toggle("drawing", !enabled);
  }
  togglePointerEvents(enabled = false) {
    this.div.classList.toggle("disabled", !enabled);
  }
  toggleAnnotationLayerPointerEvents(enabled = false) {
    var _a3;
    (_a3 = __privateGet(this, _annotationLayer)) == null ? void 0 : _a3.div.classList.toggle("disabled", !enabled);
  }
  async enable() {
    var _a3;
    __privateSet(this, _isEnabling, true);
    this.div.tabIndex = 0;
    this.togglePointerEvents(true);
    (_a3 = __privateGet(this, _textLayerDblClickAC)) == null ? void 0 : _a3.abort();
    __privateSet(this, _textLayerDblClickAC, null);
    const annotationElementIds = /* @__PURE__ */ new Set();
    for (const editor of __privateGet(this, _editors).values()) {
      editor.enableEditing();
      editor.show(true);
      if (editor.annotationElementId) {
        __privateGet(this, _uiManager4).removeChangedExistingAnnotation(editor);
        annotationElementIds.add(editor.annotationElementId);
      }
    }
    if (!__privateGet(this, _annotationLayer)) {
      __privateSet(this, _isEnabling, false);
      return;
    }
    const editables = __privateGet(this, _annotationLayer).getEditableAnnotations();
    for (const editable of editables) {
      editable.hide();
      if (__privateGet(this, _uiManager4).isDeletedAnnotationElement(editable.data.id)) {
        continue;
      }
      if (annotationElementIds.has(editable.data.id)) {
        continue;
      }
      const editor = await this.deserialize(editable);
      if (!editor) {
        continue;
      }
      this.addOrRebuild(editor);
      editor.enableEditing();
    }
    __privateSet(this, _isEnabling, false);
  }
  disable() {
    var _a3;
    __privateSet(this, _isDisabling, true);
    this.div.tabIndex = -1;
    this.togglePointerEvents(false);
    if (__privateGet(this, _textLayer) && !__privateGet(this, _textLayerDblClickAC)) {
      __privateSet(this, _textLayerDblClickAC, new AbortController());
      const signal = __privateGet(this, _uiManager4).combinedSignal(__privateGet(this, _textLayerDblClickAC));
      __privateGet(this, _textLayer).div.addEventListener("pointerdown", (e) => {
        const DBL_CLICK_THRESHOLD = 500;
        const {
          clientX,
          clientY,
          timeStamp
        } = e;
        const lastPointerDownTimestamp = __privateGet(this, _lastPointerDownTimestamp);
        if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {
          __privateSet(this, _lastPointerDownTimestamp, timeStamp);
          return;
        }
        __privateSet(this, _lastPointerDownTimestamp, -1);
        const {
          classList: classList2
        } = this.div;
        classList2.toggle("getElements", true);
        const elements = document.elementsFromPoint(clientX, clientY);
        classList2.toggle("getElements", false);
        if (!this.div.contains(elements[0])) {
          return;
        }
        let id;
        const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);
        for (const element of elements) {
          if (regex.test(element.id)) {
            id = element.id;
            break;
          }
        }
        if (!id) {
          return;
        }
        const editor = __privateGet(this, _editors).get(id);
        if ((editor == null ? void 0 : editor.annotationElementId) === null) {
          e.stopPropagation();
          e.preventDefault();
          editor.dblclick();
        }
      }, {
        signal,
        capture: true
      });
    }
    const changedAnnotations = /* @__PURE__ */ new Map();
    const resetAnnotations = /* @__PURE__ */ new Map();
    for (const editor of __privateGet(this, _editors).values()) {
      editor.disableEditing();
      if (!editor.annotationElementId) {
        continue;
      }
      if (editor.serialize() !== null) {
        changedAnnotations.set(editor.annotationElementId, editor);
        continue;
      } else {
        resetAnnotations.set(editor.annotationElementId, editor);
      }
      (_a3 = this.getEditableAnnotation(editor.annotationElementId)) == null ? void 0 : _a3.show();
      editor.remove();
    }
    if (__privateGet(this, _annotationLayer)) {
      const editables = __privateGet(this, _annotationLayer).getEditableAnnotations();
      for (const editable of editables) {
        const {
          id
        } = editable.data;
        if (__privateGet(this, _uiManager4).isDeletedAnnotationElement(id)) {
          editable.updateEdited({
            deleted: true
          });
          continue;
        }
        let editor = resetAnnotations.get(id);
        if (editor) {
          editor.resetAnnotationElement(editable);
          editor.show(false);
          editable.show();
          continue;
        }
        editor = changedAnnotations.get(id);
        if (editor) {
          __privateGet(this, _uiManager4).addChangedExistingAnnotation(editor);
          if (editor.renderAnnotationElement(editable)) {
            editor.show(false);
          }
        }
        editable.show();
      }
    }
    __privateMethod(this, _cleanup, cleanup_fn).call(this);
    if (this.isEmpty) {
      this.div.hidden = true;
    }
    const {
      classList
    } = this.div;
    for (const editorType of __privateGet(_AnnotationEditorLayer, _editorTypes2).values()) {
      classList.remove(`${editorType._type}Editing`);
    }
    this.disableTextSelection();
    this.toggleAnnotationLayerPointerEvents(true);
    __privateSet(this, _isDisabling, false);
  }
  getEditableAnnotation(id) {
    var _a3;
    return ((_a3 = __privateGet(this, _annotationLayer)) == null ? void 0 : _a3.getEditableAnnotation(id)) || null;
  }
  setActiveEditor(editor) {
    const currentActive = __privateGet(this, _uiManager4).getActive();
    if (currentActive === editor) {
      return;
    }
    __privateGet(this, _uiManager4).setActiveEditor(editor);
  }
  enableTextSelection() {
    var _a3;
    this.div.tabIndex = -1;
    if (((_a3 = __privateGet(this, _textLayer)) == null ? void 0 : _a3.div) && !__privateGet(this, _textSelectionAC)) {
      __privateSet(this, _textSelectionAC, new AbortController());
      const signal = __privateGet(this, _uiManager4).combinedSignal(__privateGet(this, _textSelectionAC));
      __privateGet(this, _textLayer).div.addEventListener("pointerdown", __privateMethod(this, _textLayerPointerDown, textLayerPointerDown_fn).bind(this), {
        signal
      });
      __privateGet(this, _textLayer).div.classList.add("highlighting");
    }
  }
  disableTextSelection() {
    var _a3;
    this.div.tabIndex = 0;
    if (((_a3 = __privateGet(this, _textLayer)) == null ? void 0 : _a3.div) && __privateGet(this, _textSelectionAC)) {
      __privateGet(this, _textSelectionAC).abort();
      __privateSet(this, _textSelectionAC, null);
      __privateGet(this, _textLayer).div.classList.remove("highlighting");
    }
  }
  enableClick() {
    if (__privateGet(this, _clickAC)) {
      return;
    }
    __privateSet(this, _clickAC, new AbortController());
    const signal = __privateGet(this, _uiManager4).combinedSignal(__privateGet(this, _clickAC));
    this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
      signal
    });
    const pointerup = this.pointerup.bind(this);
    this.div.addEventListener("pointerup", pointerup, {
      signal
    });
    this.div.addEventListener("pointercancel", pointerup, {
      signal
    });
  }
  disableClick() {
    var _a3;
    (_a3 = __privateGet(this, _clickAC)) == null ? void 0 : _a3.abort();
    __privateSet(this, _clickAC, null);
  }
  attach(editor) {
    __privateGet(this, _editors).set(editor.id, editor);
    const {
      annotationElementId
    } = editor;
    if (annotationElementId && __privateGet(this, _uiManager4).isDeletedAnnotationElement(annotationElementId)) {
      __privateGet(this, _uiManager4).removeDeletedAnnotationElement(editor);
    }
  }
  detach(editor) {
    var _a3;
    __privateGet(this, _editors).delete(editor.id);
    (_a3 = __privateGet(this, _accessibilityManager2)) == null ? void 0 : _a3.removePointerInTextLayer(editor.contentDiv);
    if (!__privateGet(this, _isDisabling) && editor.annotationElementId) {
      __privateGet(this, _uiManager4).addDeletedAnnotationElement(editor);
    }
  }
  remove(editor) {
    this.detach(editor);
    __privateGet(this, _uiManager4).removeEditor(editor);
    editor.div.remove();
    editor.isAttachedToDOM = false;
  }
  changeParent(editor) {
    var _a3;
    if (editor.parent === this) {
      return;
    }
    if (editor.parent && editor.annotationElementId) {
      __privateGet(this, _uiManager4).addDeletedAnnotationElement(editor.annotationElementId);
      AnnotationEditor.deleteAnnotationElement(editor);
      editor.annotationElementId = null;
    }
    this.attach(editor);
    (_a3 = editor.parent) == null ? void 0 : _a3.detach(editor);
    editor.setParent(this);
    if (editor.div && editor.isAttachedToDOM) {
      editor.div.remove();
      this.div.append(editor.div);
    }
  }
  add(editor) {
    if (editor.parent === this && editor.isAttachedToDOM) {
      return;
    }
    this.changeParent(editor);
    __privateGet(this, _uiManager4).addEditor(editor);
    this.attach(editor);
    if (!editor.isAttachedToDOM) {
      const div = editor.render();
      this.div.append(div);
      editor.isAttachedToDOM = true;
    }
    editor.fixAndSetPosition();
    editor.onceAdded(!__privateGet(this, _isEnabling));
    __privateGet(this, _uiManager4).addToAnnotationStorage(editor);
    editor._reportTelemetry(editor.telemetryInitialData);
  }
  moveEditorInDOM(editor) {
    var _a3;
    if (!editor.isAttachedToDOM) {
      return;
    }
    const {
      activeElement
    } = document;
    if (editor.div.contains(activeElement) && !__privateGet(this, _editorFocusTimeoutId)) {
      editor._focusEventsAllowed = false;
      __privateSet(this, _editorFocusTimeoutId, setTimeout(() => {
        __privateSet(this, _editorFocusTimeoutId, null);
        if (!editor.div.contains(document.activeElement)) {
          editor.div.addEventListener("focusin", () => {
            editor._focusEventsAllowed = true;
          }, {
            once: true,
            signal: __privateGet(this, _uiManager4)._signal
          });
          activeElement.focus();
        } else {
          editor._focusEventsAllowed = true;
        }
      }, 0));
    }
    editor._structTreeParentId = (_a3 = __privateGet(this, _accessibilityManager2)) == null ? void 0 : _a3.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
  }
  addOrRebuild(editor) {
    if (editor.needsToBeRebuilt()) {
      editor.parent || (editor.parent = this);
      editor.rebuild();
      editor.show();
    } else {
      this.add(editor);
    }
  }
  addUndoableEditor(editor) {
    const cmd = () => editor._uiManager.rebuild(editor);
    const undo2 = () => {
      editor.remove();
    };
    this.addCommands({
      cmd,
      undo: undo2,
      mustExec: false
    });
  }
  getNextId() {
    return __privateGet(this, _uiManager4).getId();
  }
  combinedSignal(ac) {
    return __privateGet(this, _uiManager4).combinedSignal(ac);
  }
  canCreateNewEmptyEditor() {
    var _a3;
    return (_a3 = __privateGet(this, _currentEditorType, currentEditorType_get)) == null ? void 0 : _a3.canCreateNewEmptyEditor();
  }
  async pasteEditor(options, params) {
    this.updateToolbar(options);
    await __privateGet(this, _uiManager4).updateMode(options.mode);
    const {
      offsetX,
      offsetY
    } = __privateMethod(this, _getCenterPoint, getCenterPoint_fn).call(this);
    const id = this.getNextId();
    const editor = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
      parent: this,
      id,
      x: offsetX,
      y: offsetY,
      uiManager: __privateGet(this, _uiManager4),
      isCentered: true,
      ...params
    });
    if (editor) {
      this.add(editor);
    }
  }
  async deserialize(data) {
    var _a3, _b2;
    return await ((_b2 = __privateGet(_AnnotationEditorLayer, _editorTypes2).get((_a3 = data.annotationType) != null ? _a3 : data.annotationEditorType)) == null ? void 0 : _b2.deserialize(data, this, __privateGet(this, _uiManager4))) || null;
  }
  createAndAddNewEditor(event, isCentered, data = {}) {
    const id = this.getNextId();
    const editor = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
      parent: this,
      id,
      x: event.offsetX,
      y: event.offsetY,
      uiManager: __privateGet(this, _uiManager4),
      isCentered,
      ...data
    });
    if (editor) {
      this.add(editor);
    }
    return editor;
  }
  addNewEditor(data = {}) {
    this.createAndAddNewEditor(__privateMethod(this, _getCenterPoint, getCenterPoint_fn).call(this), true, data);
  }
  setSelected(editor) {
    __privateGet(this, _uiManager4).setSelected(editor);
  }
  toggleSelected(editor) {
    __privateGet(this, _uiManager4).toggleSelected(editor);
  }
  unselect(editor) {
    __privateGet(this, _uiManager4).unselect(editor);
  }
  pointerup(event) {
    var _a3;
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    if (!__privateGet(this, _hadPointerDown)) {
      return;
    }
    __privateSet(this, _hadPointerDown, false);
    if (((_a3 = __privateGet(this, _currentEditorType, currentEditorType_get)) == null ? void 0 : _a3.isDrawer) && __privateGet(this, _currentEditorType, currentEditorType_get).supportMultipleDrawings) {
      return;
    }
    if (!__privateGet(this, _allowClick)) {
      __privateSet(this, _allowClick, true);
      return;
    }
    const currentMode = __privateGet(this, _uiManager4).getMode();
    if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {
      __privateGet(this, _uiManager4).unselectAll();
      return;
    }
    this.createAndAddNewEditor(event, false);
  }
  pointerdown(event) {
    var _a3;
    if (__privateGet(this, _uiManager4).getMode() === AnnotationEditorType.HIGHLIGHT) {
      this.enableTextSelection();
    }
    if (__privateGet(this, _hadPointerDown)) {
      __privateSet(this, _hadPointerDown, false);
      return;
    }
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    __privateSet(this, _hadPointerDown, true);
    if ((_a3 = __privateGet(this, _currentEditorType, currentEditorType_get)) == null ? void 0 : _a3.isDrawer) {
      this.startDrawingSession(event);
      return;
    }
    const editor = __privateGet(this, _uiManager4).getActive();
    __privateSet(this, _allowClick, !editor || editor.isEmpty());
  }
  startDrawingSession(event) {
    this.div.focus({
      preventScroll: true
    });
    if (__privateGet(this, _drawingAC)) {
      __privateGet(this, _currentEditorType, currentEditorType_get).startDrawing(this, __privateGet(this, _uiManager4), false, event);
      return;
    }
    __privateGet(this, _uiManager4).setCurrentDrawingSession(this);
    __privateSet(this, _drawingAC, new AbortController());
    const signal = __privateGet(this, _uiManager4).combinedSignal(__privateGet(this, _drawingAC));
    this.div.addEventListener("blur", ({
      relatedTarget
    }) => {
      if (relatedTarget && !this.div.contains(relatedTarget)) {
        __privateSet(this, _focusedElement, null);
        this.commitOrRemove();
      }
    }, {
      signal
    });
    __privateGet(this, _currentEditorType, currentEditorType_get).startDrawing(this, __privateGet(this, _uiManager4), false, event);
  }
  pause(on) {
    if (on) {
      const {
        activeElement
      } = document;
      if (this.div.contains(activeElement)) {
        __privateSet(this, _focusedElement, activeElement);
      }
      return;
    }
    if (__privateGet(this, _focusedElement)) {
      setTimeout(() => {
        var _a3;
        (_a3 = __privateGet(this, _focusedElement)) == null ? void 0 : _a3.focus();
        __privateSet(this, _focusedElement, null);
      }, 0);
    }
  }
  endDrawingSession(isAborted = false) {
    if (!__privateGet(this, _drawingAC)) {
      return null;
    }
    __privateGet(this, _uiManager4).setCurrentDrawingSession(null);
    __privateGet(this, _drawingAC).abort();
    __privateSet(this, _drawingAC, null);
    __privateSet(this, _focusedElement, null);
    return __privateGet(this, _currentEditorType, currentEditorType_get).endDrawing(isAborted);
  }
  findNewParent(editor, x, y) {
    const layer = __privateGet(this, _uiManager4).findParent(x, y);
    if (layer === null || layer === this) {
      return false;
    }
    layer.changeParent(editor);
    return true;
  }
  commitOrRemove() {
    if (__privateGet(this, _drawingAC)) {
      this.endDrawingSession();
      return true;
    }
    return false;
  }
  onScaleChanging() {
    if (!__privateGet(this, _drawingAC)) {
      return;
    }
    __privateGet(this, _currentEditorType, currentEditorType_get).onScaleChangingWhenDrawing(this);
  }
  destroy() {
    var _a3, _b2;
    this.commitOrRemove();
    if (((_a3 = __privateGet(this, _uiManager4).getActive()) == null ? void 0 : _a3.parent) === this) {
      __privateGet(this, _uiManager4).commitOrRemove();
      __privateGet(this, _uiManager4).setActiveEditor(null);
    }
    if (__privateGet(this, _editorFocusTimeoutId)) {
      clearTimeout(__privateGet(this, _editorFocusTimeoutId));
      __privateSet(this, _editorFocusTimeoutId, null);
    }
    for (const editor of __privateGet(this, _editors).values()) {
      (_b2 = __privateGet(this, _accessibilityManager2)) == null ? void 0 : _b2.removePointerInTextLayer(editor.contentDiv);
      editor.setParent(null);
      editor.isAttachedToDOM = false;
      editor.div.remove();
    }
    this.div = null;
    __privateGet(this, _editors).clear();
    __privateGet(this, _uiManager4).removeLayer(this);
  }
  render({
    viewport
  }) {
    this.viewport = viewport;
    setLayerDimensions(this.div, viewport);
    for (const editor of __privateGet(this, _uiManager4).getEditors(this.pageIndex)) {
      this.add(editor);
      editor.rebuild();
    }
    this.updateMode();
  }
  update({
    viewport
  }) {
    __privateGet(this, _uiManager4).commitOrRemove();
    __privateMethod(this, _cleanup, cleanup_fn).call(this);
    const oldRotation = this.viewport.rotation;
    const rotation = viewport.rotation;
    this.viewport = viewport;
    setLayerDimensions(this.div, {
      rotation
    });
    if (oldRotation !== rotation) {
      for (const editor of __privateGet(this, _editors).values()) {
        editor.rotate(rotation);
      }
    }
  }
  get pageDimensions() {
    const {
      pageWidth,
      pageHeight
    } = this.viewport.rawDims;
    return [pageWidth, pageHeight];
  }
  get scale() {
    return __privateGet(this, _uiManager4).viewParameters.realScale;
  }
};
_accessibilityManager2 = new WeakMap();
_allowClick = new WeakMap();
_annotationLayer = new WeakMap();
_clickAC = new WeakMap();
_editorFocusTimeoutId = new WeakMap();
_editors = new WeakMap();
_hadPointerDown = new WeakMap();
_isDisabling = new WeakMap();
_isEnabling = new WeakMap();
_drawingAC = new WeakMap();
_focusedElement = new WeakMap();
_textLayer = new WeakMap();
_textSelectionAC = new WeakMap();
_textLayerDblClickAC = new WeakMap();
_lastPointerDownTimestamp = new WeakMap();
_uiManager4 = new WeakMap();
_editorTypes2 = new WeakMap();
_textLayerPointerDown = new WeakSet();
textLayerPointerDown_fn = function(event) {
  __privateGet(this, _uiManager4).unselectAll();
  const {
    target
  } = event;
  if (target === __privateGet(this, _textLayer).div || (target.getAttribute("role") === "img" || target.classList.contains("endOfContent")) && __privateGet(this, _textLayer).div.contains(target)) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    __privateGet(this, _uiManager4).showAllEditors("highlight", true, true);
    __privateGet(this, _textLayer).div.classList.add("free");
    this.toggleDrawing();
    HighlightEditor.startHighlighting(this, __privateGet(this, _uiManager4).direction === "ltr", {
      target: __privateGet(this, _textLayer).div,
      x: event.x,
      y: event.y
    });
    __privateGet(this, _textLayer).div.addEventListener("pointerup", () => {
      __privateGet(this, _textLayer).div.classList.remove("free");
      this.toggleDrawing(true);
    }, {
      once: true,
      signal: __privateGet(this, _uiManager4)._signal
    });
    event.preventDefault();
  }
};
_currentEditorType = new WeakSet();
currentEditorType_get = function() {
  return __privateGet(_AnnotationEditorLayer, _editorTypes2).get(__privateGet(this, _uiManager4).getMode());
};
_createNewEditor = new WeakSet();
createNewEditor_fn = function(params) {
  const editorType = __privateGet(this, _currentEditorType, currentEditorType_get);
  return editorType ? new editorType.prototype.constructor(params) : null;
};
_getCenterPoint = new WeakSet();
getCenterPoint_fn = function() {
  const {
    x,
    y,
    width,
    height
  } = this.div.getBoundingClientRect();
  const tlX = Math.max(0, x);
  const tlY = Math.max(0, y);
  const brX = Math.min(window.innerWidth, x + width);
  const brY = Math.min(window.innerHeight, y + height);
  const centerX = (tlX + brX) / 2 - x;
  const centerY = (tlY + brY) / 2 - y;
  const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];
  return {
    offsetX,
    offsetY
  };
};
_cleanup = new WeakSet();
cleanup_fn = function() {
  for (const editor of __privateGet(this, _editors).values()) {
    if (editor.isEmpty()) {
      editor.remove();
    }
  }
};
__publicField(_AnnotationEditorLayer, "_initialized", false);
__privateAdd(_AnnotationEditorLayer, _editorTypes2, new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor, SignatureEditor].map((type) => [type._editorType, type])));
var AnnotationEditorLayer = _AnnotationEditorLayer;
var _parent2, _mapping, _toUpdate, _id5, _setBox, setBox_fn, _createSVG, createSVG_fn, _createClipPath, createClipPath_fn, _updateProperties, updateProperties_fn;
var _DrawLayer = class _DrawLayer {
  constructor({
    pageIndex
  }) {
    __privateAdd(this, _createSVG);
    __privateAdd(this, _createClipPath);
    __privateAdd(this, _updateProperties);
    __privateAdd(this, _parent2, null);
    __privateAdd(this, _mapping, /* @__PURE__ */ new Map());
    __privateAdd(this, _toUpdate, /* @__PURE__ */ new Map());
    this.pageIndex = pageIndex;
  }
  setParent(parent) {
    if (!__privateGet(this, _parent2)) {
      __privateSet(this, _parent2, parent);
      return;
    }
    if (__privateGet(this, _parent2) !== parent) {
      if (__privateGet(this, _mapping).size > 0) {
        for (const root of __privateGet(this, _mapping).values()) {
          root.remove();
          parent.append(root);
        }
      }
      __privateSet(this, _parent2, parent);
    }
  }
  static get _svgFactory() {
    return shadow(this, "_svgFactory", new DOMSVGFactory());
  }
  draw(properties, isPathUpdatable = false, hasClip = false) {
    const id = __privateWrapper(_DrawLayer, _id5)._++;
    const root = __privateMethod(this, _createSVG, createSVG_fn).call(this);
    const defs = _DrawLayer._svgFactory.createElement("defs");
    root.append(defs);
    const path2 = _DrawLayer._svgFactory.createElement("path");
    defs.append(path2);
    const pathId = `path_p${this.pageIndex}_${id}`;
    path2.setAttribute("id", pathId);
    path2.setAttribute("vector-effect", "non-scaling-stroke");
    if (isPathUpdatable) {
      __privateGet(this, _toUpdate).set(id, path2);
    }
    const clipPathId = hasClip ? __privateMethod(this, _createClipPath, createClipPath_fn).call(this, defs, pathId) : null;
    const use = _DrawLayer._svgFactory.createElement("use");
    root.append(use);
    use.setAttribute("href", `#${pathId}`);
    this.updateProperties(root, properties);
    __privateGet(this, _mapping).set(id, root);
    return {
      id,
      clipPathId: `url(#${clipPathId})`
    };
  }
  drawOutline(properties, mustRemoveSelfIntersections) {
    const id = __privateWrapper(_DrawLayer, _id5)._++;
    const root = __privateMethod(this, _createSVG, createSVG_fn).call(this);
    const defs = _DrawLayer._svgFactory.createElement("defs");
    root.append(defs);
    const path2 = _DrawLayer._svgFactory.createElement("path");
    defs.append(path2);
    const pathId = `path_p${this.pageIndex}_${id}`;
    path2.setAttribute("id", pathId);
    path2.setAttribute("vector-effect", "non-scaling-stroke");
    let maskId;
    if (mustRemoveSelfIntersections) {
      const mask = _DrawLayer._svgFactory.createElement("mask");
      defs.append(mask);
      maskId = `mask_p${this.pageIndex}_${id}`;
      mask.setAttribute("id", maskId);
      mask.setAttribute("maskUnits", "objectBoundingBox");
      const rect = _DrawLayer._svgFactory.createElement("rect");
      mask.append(rect);
      rect.setAttribute("width", "1");
      rect.setAttribute("height", "1");
      rect.setAttribute("fill", "white");
      const use = _DrawLayer._svgFactory.createElement("use");
      mask.append(use);
      use.setAttribute("href", `#${pathId}`);
      use.setAttribute("stroke", "none");
      use.setAttribute("fill", "black");
      use.setAttribute("fill-rule", "nonzero");
      use.classList.add("mask");
    }
    const use1 = _DrawLayer._svgFactory.createElement("use");
    root.append(use1);
    use1.setAttribute("href", `#${pathId}`);
    if (maskId) {
      use1.setAttribute("mask", `url(#${maskId})`);
    }
    const use2 = use1.cloneNode();
    root.append(use2);
    use1.classList.add("mainOutline");
    use2.classList.add("secondaryOutline");
    this.updateProperties(root, properties);
    __privateGet(this, _mapping).set(id, root);
    return id;
  }
  finalizeDraw(id, properties) {
    __privateGet(this, _toUpdate).delete(id);
    this.updateProperties(id, properties);
  }
  updateProperties(elementOrId, properties) {
    var _a3;
    if (!properties) {
      return;
    }
    const {
      root,
      bbox,
      rootClass,
      path: path2
    } = properties;
    const element = typeof elementOrId === "number" ? __privateGet(this, _mapping).get(elementOrId) : elementOrId;
    if (!element) {
      return;
    }
    if (root) {
      __privateMethod(this, _updateProperties, updateProperties_fn).call(this, element, root);
    }
    if (bbox) {
      __privateMethod(_a3 = _DrawLayer, _setBox, setBox_fn).call(_a3, element, bbox);
    }
    if (rootClass) {
      const {
        classList
      } = element;
      for (const [className, value] of Object.entries(rootClass)) {
        classList.toggle(className, value);
      }
    }
    if (path2) {
      const defs = element.firstChild;
      const pathElement = defs.firstChild;
      __privateMethod(this, _updateProperties, updateProperties_fn).call(this, pathElement, path2);
    }
  }
  updateParent(id, layer) {
    if (layer === this) {
      return;
    }
    const root = __privateGet(this, _mapping).get(id);
    if (!root) {
      return;
    }
    __privateGet(layer, _parent2).append(root);
    __privateGet(this, _mapping).delete(id);
    __privateGet(layer, _mapping).set(id, root);
  }
  remove(id) {
    __privateGet(this, _toUpdate).delete(id);
    if (__privateGet(this, _parent2) === null) {
      return;
    }
    __privateGet(this, _mapping).get(id).remove();
    __privateGet(this, _mapping).delete(id);
  }
  destroy() {
    __privateSet(this, _parent2, null);
    for (const root of __privateGet(this, _mapping).values()) {
      root.remove();
    }
    __privateGet(this, _mapping).clear();
    __privateGet(this, _toUpdate).clear();
  }
};
_parent2 = new WeakMap();
_mapping = new WeakMap();
_toUpdate = new WeakMap();
_id5 = new WeakMap();
_setBox = new WeakSet();
setBox_fn = function(element, [x, y, width, height]) {
  const {
    style
  } = element;
  style.top = `${100 * y}%`;
  style.left = `${100 * x}%`;
  style.width = `${100 * width}%`;
  style.height = `${100 * height}%`;
};
_createSVG = new WeakSet();
createSVG_fn = function() {
  const svg = _DrawLayer._svgFactory.create(1, 1, true);
  __privateGet(this, _parent2).append(svg);
  svg.setAttribute("aria-hidden", true);
  return svg;
};
_createClipPath = new WeakSet();
createClipPath_fn = function(defs, pathId) {
  const clipPath = _DrawLayer._svgFactory.createElement("clipPath");
  defs.append(clipPath);
  const clipPathId = `clip_${pathId}`;
  clipPath.setAttribute("id", clipPathId);
  clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
  const clipPathUse = _DrawLayer._svgFactory.createElement("use");
  clipPath.append(clipPathUse);
  clipPathUse.setAttribute("href", `#${pathId}`);
  clipPathUse.classList.add("clip");
  return clipPathId;
};
_updateProperties = new WeakSet();
updateProperties_fn = function(element, properties) {
  for (const [key, value] of Object.entries(properties)) {
    if (value === null) {
      element.removeAttribute(key);
    } else {
      element.setAttribute(key, value);
    }
  }
};
__privateAdd(_DrawLayer, _setBox);
__privateAdd(_DrawLayer, _id5, 0);
var DrawLayer = _DrawLayer;
{
  globalThis._pdfjsTestingUtils = {
    HighlightOutliner
  };
}
globalThis.pdfjsLib = {
  AbortException,
  AnnotationEditorLayer,
  AnnotationEditorParamsType,
  AnnotationEditorType,
  AnnotationEditorUIManager,
  AnnotationLayer,
  AnnotationMode,
  AnnotationType,
  build,
  ColorPicker,
  createValidAbsoluteUrl,
  DOMSVGFactory,
  DrawLayer,
  FeatureTest: util_FeatureTest,
  fetchData,
  getDocument,
  getFilenameFromUrl,
  getPdfFilenameFromUrl,
  getRGB,
  getUuid,
  getXfaPageViewport,
  GlobalWorkerOptions,
  ImageKind: util_ImageKind,
  InvalidPDFException,
  isDataScheme,
  isPdfFile,
  isValidExplicitDest,
  MathClamp,
  noContextMenu,
  normalizeUnicode,
  OPS,
  OutputScale,
  PasswordResponses,
  PDFDataRangeTransport,
  PDFDateString,
  PDFWorker,
  PermissionFlag,
  PixelsPerInch,
  RenderingCancelledException,
  ResponseException,
  setLayerDimensions,
  shadow,
  SignatureExtractor,
  stopEvent,
  SupportedImageMimeTypes,
  TextLayer,
  TouchManager,
  updateUrlHash,
  Util,
  VerbosityLevel,
  version,
  XfaLayer
};

// src/TypstView.ts
var TypstView = class extends import_obsidian.TextFileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentMode = "source";
    this.modeIconContainer = null;
    this.typstEditor = null;
    this.fileContent = "";
    this.savedEditorState = null;
    this.savedReadingScrollTop = 0;
    this.plugin = plugin;
    this.currentMode = plugin.settings.defaultMode;
    GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@${version}/build/pdf.worker.min.mjs`;
  }
  getViewType() {
    return "typst-view";
  }
  getDisplayText() {
    var _a3;
    return ((_a3 = this.file) == null ? void 0 : _a3.basename) || "Typst File";
  }
  getIcon() {
    return "typst-file";
  }
  async onOpen() {
    await super.onOpen();
    this.addModeIcon();
    this.applySettings();
  }
  onResize() {
    super.onResize();
    this.applySettings();
  }
  applySettings() {
    if (this.plugin.settings.editorReadableWidth) {
      this.containerEl.addClass("typst-readable-width");
      console.log("\u{1F50D} TypstView: Applied typst-readable-width class");
    } else {
      this.containerEl.removeClass("typst-readable-width");
      console.log("\u{1F50D} TypstView: Removed typst-readable-width class");
    }
    const styles = getComputedStyle(document.body);
    const fileLineWidth = styles.getPropertyValue("--file-line-width").trim();
    const fileMargins = styles.getPropertyValue("--file-margins").trim();
    console.log("\u{1F50D} TypstView: --file-line-width CSS value:", fileLineWidth);
    console.log("\u{1F50D} TypstView: --file-margins CSS value:", fileMargins);
  }
  onClose() {
    this.cleanupEditor();
    return super.onClose();
  }
  addModeIcon() {
    const viewActions = this.containerEl.querySelector(".view-actions");
    if (viewActions) {
      this.modeIconContainer = createDiv("clickable-icon");
      this.modeIconContainer.addClass("view-action");
      this.modeIconContainer.addEventListener("click", () => {
        this.toggleMode();
      });
      this.updateModeIcon();
      viewActions.prepend(this.modeIconContainer);
      this.addPdfExportButton(viewActions);
    }
  }
  addPdfExportButton(viewActions) {
    var _a3;
    const exportButton = createDiv("clickable-icon");
    exportButton.addClass("view-action");
    exportButton.setAttribute("aria-label", "Export to PDF");
    (0, import_obsidian.setIcon)(exportButton, "file-text");
    exportButton.addEventListener("click", async () => {
      await this.exportToPdf();
    });
    if ((_a3 = this.modeIconContainer) == null ? void 0 : _a3.nextSibling) {
      viewActions.insertBefore(
        exportButton,
        this.modeIconContainer.nextSibling
      );
    } else {
      viewActions.appendChild(exportButton);
    }
  }
  async exportToPdf() {
    if (!this.file) {
      console.error("No file available for export");
      return;
    }
    try {
      const content = this.getViewData();
      const pdfData = await this.plugin.compileToPdf(content);
      if (!pdfData) {
        console.error("PDF compilation failed");
        return;
      }
      const filePath = this.file.path;
      const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
      const baseName = this.file.basename;
      const pdfFileName = `${baseName}.pdf`;
      const pdfPath = folderPath ? `${folderPath}/${pdfFileName}` : pdfFileName;
      const arrayBuffer = pdfData.buffer.slice(
        pdfData.byteOffset,
        pdfData.byteOffset + pdfData.byteLength
      );
      const existingFile = this.app.vault.getAbstractFileByPath(pdfPath);
      if (existingFile) {
        await this.app.vault.modifyBinary(existingFile, arrayBuffer);
      } else {
        await this.app.vault.createBinary(pdfPath, arrayBuffer);
      }
      new import_obsidian.Notice(`PDF exported to: ${pdfPath}`);
    } catch (error) {
      console.error("Failed to export PDF:", error);
    }
  }
  async toggleMode() {
    if (this.currentMode === "source") {
      await this.switchToReadingMode();
    } else {
      this.switchToSourceMode();
    }
  }
  getCurrentMode() {
    return this.currentMode;
  }
  async recompileIfInReadingMode() {
    if (this.currentMode === "reading") {
      const pdfData = await this.compile();
      if (pdfData) {
        await this.showReadingMode(pdfData);
      }
    }
  }
  async switchToReadingMode() {
    this.saveEditorState();
    const pdfData = await this.compile();
    if (!pdfData)
      return;
    this.setMode("reading");
    await this.showReadingMode(pdfData);
  }
  switchToSourceMode() {
    this.saveEditorState();
    this.setMode("source");
    this.showSourceMode();
    this.restoreEditorState();
  }
  setMode(mode) {
    this.currentMode = mode;
    this.updateModeIcon();
  }
  async compile() {
    console.log("\u{1F7E1} TypstView: Starting PDF compile()");
    const content = this.getViewData();
    console.log("\u{1F7E1} TypstView: Got content, length:", content.length);
    console.log("\u{1F7E1} TypstView: Calling plugin's compileToPdf");
    try {
      const result = await this.plugin.compileToPdf(content);
      console.log("\u{1F7E1} TypstView: PDF compilation completed successfully");
      return result;
    } catch (error) {
      console.error("\u{1F534} TypstView: PDF compilation failed:", error);
      throw error;
    }
  }
  updateModeIcon() {
    if (!this.modeIconContainer)
      return;
    this.modeIconContainer.empty();
    if (this.currentMode === "source") {
      (0, import_obsidian.setIcon)(this.modeIconContainer, "pencil-line");
      this.modeIconContainer.setAttribute(
        "aria-label",
        "Currently in source mode. Click to switch to reading mode."
      );
    } else {
      (0, import_obsidian.setIcon)(this.modeIconContainer, "book-open");
      this.modeIconContainer.setAttribute(
        "aria-label",
        "Currently in reading mode. Click to switch to source mode."
      );
    }
  }
  async setViewData(data, clear) {
    this.fileContent = data;
    if (this.currentMode === "source") {
      this.showSourceMode();
    } else {
      await this.loadReadingMode(data);
    }
  }
  async loadReadingMode(data) {
    const pdfData = await this.compile();
    if (!pdfData) {
      this.setMode("source");
      this.showSourceMode();
    } else {
      await this.showReadingMode(pdfData);
    }
  }
  getViewData() {
    if (this.currentMode === "source" && this.typstEditor) {
      return this.typstEditor.getContent();
    }
    return this.fileContent;
  }
  getContentElement() {
    return this.containerEl.querySelector(".view-content");
  }
  cleanupEditor() {
    if (this.typstEditor) {
      this.typstEditor.destroy();
      this.typstEditor = null;
    }
  }
  showSourceMode() {
    const contentEl = this.getContentElement();
    if (!contentEl)
      return;
    contentEl.empty();
    this.cleanupEditor();
    this.typstEditor = new TypstEditor(
      contentEl,
      this.app,
      (content) => {
        this.fileContent = content;
        this.requestSave();
      }
    );
    this.typstEditor.initialize(this.fileContent);
  }
  saveEditorState() {
    if (this.typstEditor) {
      const state = this.typstEditor.getEditorState();
      if (state) {
        this.savedEditorState = state;
      }
    } else if (this.currentMode === "reading") {
      const contentEl = this.getContentElement();
      if (contentEl) {
        this.savedReadingScrollTop = contentEl.scrollTop;
      }
    }
  }
  restoreEditorState() {
    if (this.savedEditorState && this.typstEditor) {
      setTimeout(() => {
        if (this.typstEditor && this.savedEditorState) {
          this.typstEditor.restoreEditorState(this.savedEditorState);
          this.typstEditor.focus();
        }
      }, 0);
    } else if (this.typstEditor) {
      setTimeout(() => {
        var _a3;
        (_a3 = this.typstEditor) == null ? void 0 : _a3.focus();
      }, 0);
    }
  }
  async showReadingMode(pdfData) {
    const contentEl = this.getContentElement();
    if (!contentEl)
      return;
    contentEl.empty();
    this.cleanupEditor();
    const readingDiv = contentEl.createDiv("typst-reading-mode");
    try {
      const loadingTask = getDocument({ data: pdfData });
      const pdfDocument = await loadingTask.promise;
      for (let pageNumber = 1; pageNumber <= pdfDocument.numPages; pageNumber++) {
        await this.renderPage(pdfDocument, pageNumber, readingDiv);
      }
      if (this.savedReadingScrollTop > 0) {
        setTimeout(() => {
          if (contentEl) {
            contentEl.scrollTop = this.savedReadingScrollTop;
          }
        }, 0);
      }
    } catch (error) {
      console.error("\u{1F534} TypstView: PDF rendering failed:", error);
    }
  }
  async renderPage(pdfDocument, pageNumber, container) {
    try {
      console.log(`\u{1F4C4} Starting to render page ${pageNumber}`);
      const page = await pdfDocument.getPage(pageNumber);
      const scale = 1.5;
      const outputScale = window.devicePixelRatio || 1;
      const viewport = page.getViewport({ scale: scale * outputScale });
      console.log(
        `\u{1F4D0} Viewport: ${viewport.width / outputScale}x${viewport.height / outputScale}px, scale: ${scale}, DPI: ${outputScale}`
      );
      const pageContainer = container.createDiv("typst-pdf-page");
      pageContainer.style.position = "relative";
      pageContainer.style.width = `${viewport.width / outputScale}px`;
      pageContainer.style.height = `${viewport.height / outputScale}px`;
      pageContainer.style.marginBottom = "20px";
      pageContainer.style.setProperty("--scale-factor", scale.toString());
      console.log(
        `\u{1F4E6} Page container created with dimensions: ${viewport.width / outputScale}x${viewport.height / outputScale}`
      );
      pageContainer.style.opacity = "0";
      const canvas = pageContainer.createEl("canvas");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      canvas.style.display = "block";
      canvas.style.width = `${Math.floor(viewport.width / outputScale)}px`;
      canvas.style.height = `${Math.floor(viewport.height / outputScale)}px`;
      const context = canvas.getContext("2d");
      const renderContext = {
        canvasContext: context,
        viewport,
        canvas
      };
      console.log(
        `\u{1F3A8} Rendering canvas for page ${pageNumber} at ${canvas.width}x${canvas.height} (display: ${canvas.style.width}x${canvas.style.height})...`
      );
      const renderTask = page.render(renderContext);
      await renderTask.promise;
      console.log(`\u2705 Canvas rendered successfully for page ${pageNumber}`);
      console.log(`\u{1F4DD} Getting text content for page ${pageNumber}...`);
      const textContent = await page.getTextContent();
      console.log(`\u{1F4DD} Text content retrieved:`, {
        items: textContent.items.length,
        styles: Object.keys(textContent.styles || {}).length
      });
      const textLayerDiv = pageContainer.createDiv("textLayer");
      textLayerDiv.style.position = "absolute";
      textLayerDiv.style.left = "0";
      textLayerDiv.style.top = "0";
      textLayerDiv.style.width = `${Math.floor(
        viewport.width / outputScale
      )}px`;
      textLayerDiv.style.height = `${Math.floor(
        viewport.height / outputScale
      )}px`;
      textLayerDiv.style.overflow = "hidden";
      textLayerDiv.style.lineHeight = "1.0";
      console.log(
        `\u{1F3AD} Text layer div created with dimensions: ${Math.floor(
          viewport.width / outputScale
        )}x${Math.floor(viewport.height / outputScale)}`
      );
      console.log(`\u{1F527} Creating TextLayer instance...`);
      const textLayer = new TextLayer({
        textContentSource: textContent,
        container: textLayerDiv,
        viewport
      });
      console.log(`\u2699\uFE0F Rendering text layer...`);
      await textLayer.render();
      console.log(`\u2705 Text layer rendered successfully`);
      console.log(
        `\u{1F4CA} Text layer children count: ${textLayerDiv.children.length}`
      );
      const annotations = await page.getAnnotations();
      console.log(`\u{1F516} Annotations found: ${annotations.length}`);
      if (annotations.length > 0) {
        const annotationLayerDiv = pageContainer.createDiv("annotationLayer");
        annotationLayerDiv.style.position = "absolute";
        annotationLayerDiv.style.left = "0";
        annotationLayerDiv.style.top = "0";
        annotationLayerDiv.style.right = "0";
        annotationLayerDiv.style.bottom = "0";
        const annotationViewport = viewport.clone({ dontFlip: true });
        const annotationLayer = new AnnotationLayer({
          div: annotationLayerDiv,
          accessibilityManager: null,
          annotationCanvasMap: null,
          annotationEditorUIManager: null,
          page,
          viewport: annotationViewport,
          structTreeLayer: null
        });
        console.log(`\u{1F516} Rendering annotation layer...`);
        await annotationLayer.render({
          viewport: annotationViewport,
          div: annotationLayerDiv,
          annotations,
          page,
          linkService: this.createLinkService(pdfDocument),
          downloadManager: void 0,
          annotationStorage: void 0,
          imageResourcesPath: "",
          renderForms: true,
          enableScripting: false,
          hasJSActions: false,
          fieldObjects: null,
          annotationCanvasMap: void 0,
          accessibilityManager: void 0,
          annotationEditorUIManager: void 0,
          structTreeLayer: void 0
        });
        console.log(`\u2705 Annotation layer rendered successfully`);
      }
      pageContainer.style.opacity = "1";
      console.log(
        `\u{1F389} Page ${pageNumber} fully rendered. Final layer structure:`,
        {
          pageContainer: pageContainer.className,
          canvas: !!canvas,
          textLayer: !!textLayerDiv,
          textLayerSpans: textLayerDiv.querySelectorAll("span").length,
          annotationLayer: annotations.length > 0
        }
      );
    } catch (error) {
      console.error(`\u274C Failed to render page ${pageNumber}:`, error);
    }
  }
  createLinkService(pdfDocument) {
    return {
      externalLinkTarget: 2,
      externalLinkRel: "noopener noreferrer",
      externalLinkEnabled: true,
      getDestinationHash: (dest) => {
        return `#page=${dest}`;
      },
      goToDestination: async (dest) => {
        if (typeof dest === "string") {
          const explicitDest = await pdfDocument.getDestination(dest);
          if (explicitDest) {
            dest = explicitDest;
          }
        }
        if (Array.isArray(dest)) {
          const pageRef = dest[0];
          const pageIndex = await pdfDocument.getPageIndex(pageRef);
          const pageNum = pageIndex + 1;
          console.log("Navigating to page:", pageNum);
        }
      },
      getPageIndex: async (ref) => {
        return await pdfDocument.getPageIndex(ref);
      }
    };
  }
  clear() {
    this.fileContent = "";
    if (this.typstEditor) {
      this.typstEditor.setContent("");
    }
  }
};

// src/commands.ts
var import_obsidian3 = require("obsidian");

// src/modal.ts
var import_obsidian2 = require("obsidian");
var CreateTypstFileModal = class extends import_obsidian2.Modal {
  constructor(app, plugin) {
    super(app);
    this.fileName = "";
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Create New Typst File" });
    new import_obsidian2.Setting(contentEl).setName("File name").setDesc("Enter the name of the Typst file (without .typ extension)").addText((text) => {
      text.setPlaceholder("note").setValue(this.fileName).onChange((value) => {
        this.fileName = value;
      });
      text.inputEl.focus();
      text.inputEl.select();
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          this.createFile();
        }
      });
    });
    const buttonContainer = contentEl.createDiv("modal-button-container");
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => {
      this.createFile();
    });
  }
  async createFile() {
    if (!this.fileName.trim()) {
      new import_obsidian2.Notice("Please enter a file name");
      return;
    }
    try {
      const fileName = this.fileName.trim();
      const fullPath = (0, import_obsidian2.normalizePath)(`${fileName}.typ`);
      const existingFile = this.app.vault.getAbstractFileByPath(fullPath);
      if (existingFile && existingFile instanceof import_obsidian2.TFile) {
        new import_obsidian2.Notice("File already exists");
        const leaf2 = this.app.workspace.getLeaf(true);
        leaf2.openFile(existingFile);
        this.close();
        return;
      }
      const newFile = await this.app.vault.create(fullPath, "", {});
      const leaf = this.app.workspace.getLeaf(true);
      leaf.openFile(newFile);
      this.close();
    } catch (error) {
      console.error("Error creating Typst file:", error);
      new import_obsidian2.Notice("Error creating file");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands.ts
function registerCommands(plugin) {
  plugin.addCommand({
    id: "create-typst-file",
    name: "Create new Typst file",
    callback: () => {
      new CreateTypstFileModal(plugin.app, plugin).open();
    }
  });
  plugin.addCommand({
    id: "toggle-typst-mode",
    name: "Toggle between source and reading mode",
    checkCallback: (inTypstView) => {
      const view = plugin.app.workspace.getActiveViewOfType(TypstView);
      if (view instanceof TypstView) {
        if (!inTypstView) {
          view.toggleMode();
          const mode = view.getCurrentMode();
        }
        return true;
      }
      if (!inTypstView) {
        new import_obsidian3.Notice("Must be in a Typst (.typ) file");
      }
      return false;
    }
  });
  plugin.addCommand({
    id: "export-to-pdf",
    name: "Export to PDF",
    checkCallback: (inTypstView) => {
      const view = plugin.app.workspace.getActiveViewOfType(TypstView);
      if (view instanceof TypstView) {
        if (!inTypstView) {
          view.exportToPdf();
        }
        return true;
      }
      if (!inTypstView) {
        new import_obsidian3.Notice("Must be in a Typst (.typ) file");
      }
      return false;
    }
  });
}

// src/util.ts
var TypstIcon = `<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 700 700"><path d="M367.7 477.4c0 25.2 3.6 42.1 10.9 50.7 7.3 8.6 20.7 12.9 40.2 12.9 19.5 0 44.9-9.9 76-29.8l19.9 32.8c-58.3 48.4-106.3 72.5-144.1 72.5s-67.6-9.1-89.4-27.3c-21.9-18.2-32.8-50.5-32.8-96.9V232h-49.7l-8-36.8 57.6-17.9v-48.7L367.5 74v109.3l117.2-8.9L474 239l-106.3-4v242.4z" fill="currentColor"/></svg>`;
var pluginId = "typst-for-obsidian";

// src/settings.ts
var import_obsidian4 = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultMode: "source",
  editorReadableWidth: false,
  useDefaultLayoutFunctions: true,
  autoDownloadPackages: true,
  fontFamilies: [],
  compileOnSave: false,
  // prettier-ignore
  customLayoutFunctions: `#set page(
  width: %LINEWIDTH%pt,
  height: auto,
  margin: (x: 0.25em, y: 0.25em),
  fill: rgb("%BGCOLOR%")
)

#set text(
  size: %FONTSIZE%,
  fill: rgb("%THEMECOLOR%")
)

#show math.equation: set text(fill: rgb("%THEMECOLOR%"))

#set par(
  justify: true,
  leading: 0.65em
)

#set block(fill: none)
#set rect(fill: none, stroke: rgb("%THEMECOLOR%"))
#set box(fill: none)
#set circle(fill: none, stroke: rgb("%THEMECOLOR%"))
#set ellipse(fill: none, stroke: rgb("%THEMECOLOR%"))
#set polygon(fill: none, stroke: rgb("%THEMECOLOR%"))
#set line(stroke: rgb("%THEMECOLOR%"))`
};
var TypstSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setName("Default file mode").setDesc(
      "Choose whether Typst files open in source or reading mode by default"
    ).addDropdown(
      (dropdown) => dropdown.addOption("source", "Source mode").addOption("reading", "Reading mode").setValue(this.plugin.settings.defaultMode).onChange(async (value) => {
        this.plugin.settings.defaultMode = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Compile on save").setDesc(
      "Automatically recompile the document when saving (Ctrl/Cmd+S) while in reading mode"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.compileOnSave).onChange(async (value) => {
        this.plugin.settings.compileOnSave = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Use default layout functions").setDesc(
      "When enabled, wraps editor content with default page, text, and styling functions."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useDefaultLayoutFunctions).onChange(async (value) => {
        this.plugin.settings.useDefaultLayoutFunctions = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.useDefaultLayoutFunctions) {
      const layoutSetting = new import_obsidian4.Setting(containerEl).setName("Custom layout functions").setDesc(
        "Customize the default layout functions. Available variables: %THEMECOLOR%, %BGCOLOR%, %FONTSIZE%, %LINEWIDTH%, %ACCENTCOLOR%, %FAINTCOLOR%, %MUTEDCOLOR%, %BGPRIMARY%, %BGPRIMARYALT%, %BGSECONDARY%, %BGSECONDARYALT%, %SUCCESSCOLOR%, %WARNINGCOLOR%, %ERRORCOLOR%, %HEADINGCOLOR%, %FONTTEXT%, %FONTMONO%, %BORDERWIDTH%"
      );
      let textArea;
      layoutSetting.addTextArea((text) => {
        textArea = text.inputEl;
        text.setPlaceholder("Enter Typst layout functions...").setValue(this.plugin.settings.customLayoutFunctions).onChange(async (value) => {
          this.plugin.settings.customLayoutFunctions = value;
          await this.plugin.saveSettings();
        });
        text.inputEl.addClass("typst-layout-textarea");
        text.inputEl.rows = 10;
      });
      layoutSetting.addButton(
        (button) => button.setButtonText("Reset to default").setIcon("rotate-ccw").setTooltip("Reset to default layout functions").onClick(async () => {
          this.plugin.settings.customLayoutFunctions = DEFAULT_SETTINGS.customLayoutFunctions;
          await this.plugin.saveSettings();
          textArea.value = this.plugin.settings.customLayoutFunctions;
        })
      );
    }
    new import_obsidian4.Setting(containerEl).setName("Font families").setDesc(
      "List of system font families to load for Typst compilation (one per line). Leave empty to use default fonts."
    ).addTextArea(
      (text) => text.setPlaceholder("Arial\nHelvetica\nTimes New Roman").setValue(this.plugin.settings.fontFamilies.join("\n")).onChange(async (value) => {
        this.plugin.settings.fontFamilies = value.split("\n").map((font) => font.trim().toLowerCase()).filter((font) => font.length > 0);
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/PackageManager.ts
var import_obsidian7 = require("obsidian");

// src/PackageParser.ts
var IMPORT_REGEX = /#import\s+"@([a-zA-Z0-9_-]+)\/([a-zA-Z0-9._-]+):([a-zA-Z0-9._+-]+)"(.*?)$/gm;
function parsePackageImports(content) {
  const imports = [];
  let match;
  console.log(
    `[parsePackageImports] Parsing package imports from content: ${content}`
  );
  IMPORT_REGEX.lastIndex = 0;
  while ((match = IMPORT_REGEX.exec(content)) !== null) {
    const [_, namespace, name, version2, scopedImports] = match;
    const packageImport = {
      namespace: namespace.trim(),
      name: name.trim(),
      version: version2.trim(),
      scopedImports: (scopedImports == null ? void 0 : scopedImports.trim()) || ""
    };
    console.log(`[parsePackageImports] Found package import: ${packageImport}`);
    imports.push(packageImport);
  }
  return imports;
}

// src/PackageDownloader.ts
var import_obsidian5 = require("obsidian");
var import_js_untar = __toESM(require_untar());

// node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits2;
  let xbits;
  let f;
  let overflow = 0;
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    s.bl_count[bits2] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits2 = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits2 > max_length) {
      bits2 = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits2;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits2]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits2 + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits2 = max_length - 1;
    while (s.bl_count[bits2] === 0) {
      bits2--;
    }
    s.bl_count[bits2]--;
    s.bl_count[bits2 + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits2 = max_length; bits2 !== 0; bits2--) {
    n = s.bl_count[bits2];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits2) {
        s.opt_len += (bits2 - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits2;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits2;
  let n;
  for (bits2 = 1; bits2 <= MAX_BITS$1; bits2++) {
    code = code + bl_count[bits2 - 1] << 1;
    next_code[bits2] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits2;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    bl_count[bits2] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t2 = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max2) => {
  const len = max2 || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max2));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max2) => {
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  let pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits2;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits2 = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits2 < 15) {
        hold += input[_in++] << bits2;
        bits2 += 8;
        hold += input[_in++] << bits2;
        bits2 += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits2 -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits2 < op) {
                hold += input[_in++] << bits2;
                bits2 += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits2 -= op;
            }
            if (bits2 < 15) {
              hold += input[_in++] << bits2;
              bits2 += 8;
              hold += input[_in++] << bits2;
              bits2 += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits2 -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits2 < op) {
                    hold += input[_in++] << bits2;
                    bits2 += 8;
                    if (bits2 < op) {
                      hold += input[_in++] << bits2;
                      bits2 += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits2 -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits2 >> 3;
  _in -= len;
  bits2 -= len << 3;
  hold &= (1 << bits2) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits2;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits2 = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max2 = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits2;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max2; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits2;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits2 = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits2 = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits2 -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits2 = 0;
          break;
        case FLAGS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = TIME;
        case TIME:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = OS;
        case OS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits2 = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits2 = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits2 & 7;
            bits2 -= bits2 & 7;
            state.mode = CHECK;
            break;
          }
          while (bits2 < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits2 -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits2 -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits2 -= 2;
          break;
        case STORED:
          hold >>>= bits2 & 7;
          bits2 -= bits2 & 7;
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits2 = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits2 < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits2 -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits2 -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits2 -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits2 < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits2 -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits2 -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits2 -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits2 -= 3;
              } else {
                n = here_bits + 7;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits2 -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits2 = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits2 < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits2 < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits2;
              bits2 += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits2;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var ungzip_1 = ungzip;

// src/PackageDownloader.ts
var PackageDownloader = class {
  constructor(app) {
    this.app = app;
  }
  // Download and extract a Typst preview package from URL
  async downloadPackage(name, version2, targetPath) {
    const url = `https://packages.typst.app/preview/${name}-${version2}.tar.gz`;
    try {
      const exists = await this.packageExists(url);
      if (!exists) {
        throw new Error(`Package ${name}:${version2} not found`);
      }
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(
          `Download failed: ${response.status} ${response.statusText}`
        );
      }
      const arrayBuffer = await response.arrayBuffer();
      const decompressed = ungzip_1(new Uint8Array(arrayBuffer));
      const files = await (0, import_js_untar.default)(decompressed.buffer);
      console.log(
        `[PackageDownloader] Extracted ${files.length} files from ${name}:${version2}`
      );
      await this.writePackageFiles(files, targetPath);
    } catch (error) {
      const msg = `Failed to download package ${name}:${version2}: ${error.message}`;
      new import_obsidian5.Notice(msg);
      throw new Error(msg);
    }
  }
  async packageExists(url) {
    try {
      const response = await fetch(url, { method: "HEAD" });
      return response.ok;
    } catch (error) {
      return false;
    }
  }
  async writePackageFiles(files, targetPath) {
    console.log(
      `[PackageDownloader] Writing ${files.length} files to ${targetPath}`
    );
    const targetExists = await this.app.vault.adapter.exists(targetPath);
    if (!targetExists) {
      console.log(
        `[PackageDownloader] Creating target directory: ${targetPath}`
      );
      await this.app.vault.adapter.mkdir(targetPath);
    }
    for (const file of files) {
      const filePath = `${targetPath}/${file.name}`;
      console.log(
        `[PackageDownloader] Writing file: ${file.name} to ${filePath}`
      );
      try {
        if (file.type === "directory") {
          const dirExists = await this.app.vault.adapter.exists(filePath);
          if (!dirExists) {
            await this.app.vault.adapter.mkdir(filePath);
          }
        } else if (file.type === "file") {
          await this.app.vault.adapter.writeBinary(filePath, file.buffer);
          console.log(
            `[PackageDownloader] Wrote file: ${file.name} to ${filePath}`
          );
        }
      } catch (error) {
        throw new Error(`Failed to write file ${file.name}: ${error.message}`);
      }
    }
  }
};

// src/LocalPackageManager.ts
var import_obsidian6 = require("obsidian");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var LocalPackageManager = class {
  constructor() {
  }
  async findLocalPackage(name, version2) {
    const dataDir = this.getDataDir();
    if (!dataDir) {
      return null;
    }
    const packagePath = path.join(
      dataDir,
      "typst",
      "packages",
      "local",
      name,
      version2
    );
    try {
      await fs.promises.access(path.join(packagePath, "typst.toml"));
      return this.readPackageFiles(packagePath);
    } catch (error) {
      return null;
    }
  }
  async readPackageFiles(basePath) {
    const files = /* @__PURE__ */ new Map();
    const entries = await fs.promises.readdir(basePath, {
      withFileTypes: true
    });
    for (const entry of entries) {
      const fullPath = path.join(basePath, entry.name);
      if (entry.isDirectory()) {
        const subFiles = await this.readPackageFiles(fullPath);
        for (const [subPath, content] of subFiles.entries()) {
          files.set(path.join(entry.name, subPath), content);
        }
      } else {
        const content = await fs.promises.readFile(fullPath, "utf-8");
        files.set(entry.name, content);
      }
    }
    return files;
  }
  getDataDir() {
    if (import_obsidian6.Platform.isLinux) {
      return process.env.XDG_DATA_HOME || path.join(process.env.HOME || "", ".local", "share");
    } else if (import_obsidian6.Platform.isWin) {
      return process.env.APPDATA || null;
    } else if (import_obsidian6.Platform.isMacOS) {
      return path.join(
        process.env.HOME || "",
        "Library",
        "Application Support"
      );
    }
    return null;
  }
};

// src/PackageManager.ts
var PackageManager = class {
  constructor(app) {
    this.app = app;
    this.downloader = new PackageDownloader(app);
    this.localPackageManager = new LocalPackageManager();
    this.resolvedPackages = /* @__PURE__ */ new Map();
  }
  async resolvePackages(content) {
    const imports = parsePackageImports(content);
    this.resolvedPackages.clear();
    for (const imp of imports) {
      const packageImportString = this.getPackageImportString(imp);
      if (this.resolvedPackages.has(packageImportString)) {
        continue;
      }
      if (imp.namespace === "preview") {
        const previewPath = this.getPreviewPackagePath(imp.name, imp.version);
        if (!await this.app.vault.adapter.exists(previewPath)) {
          new import_obsidian7.Notice(`Downloading package ${imp.name}:${imp.version}`);
          await this.downloader.downloadPackage(
            imp.name,
            imp.version,
            previewPath
          );
        }
        this.resolvedPackages.set(packageImportString, previewPath);
      } else if (imp.namespace === "local") {
        const localPackageFiles = await this.localPackageManager.findLocalPackage(
          imp.name,
          imp.version
        );
        if (localPackageFiles) {
          this.resolvedPackages.set(packageImportString, localPackageFiles);
        } else {
          new import_obsidian7.Notice(`Could not find local package ${imp.name}:${imp.version}`);
        }
      }
    }
  }
  getPackageImportString(packageImport) {
    return `@${packageImport.namespace}/${packageImport.name}:${packageImport.version}`;
  }
  getPreviewPackagePath(name, version2) {
    return `${this.app.vault.configDir}/plugins/${pluginId}/packages/preview/${name}/${version2}`;
  }
};

// src/compiler.worker.ts
function inlineWorker() {
  let blob = new Blob(['var Q={},o;function B(t){let e=o.__externref_table_alloc();return o.__wbindgen_export_2.set(e,t),e}function D(t,e){try{return t.apply(this,e)}catch(n){let r=B(n);o.__wbindgen_exn_store(r)}}var m=null;function w(){return(m===null||m.byteLength===0)&&(m=new Uint8Array(o.memory.buffer)),m}var W=new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0});W.decode();var L=2146435072,T=0;function j(t,e){return T+=e,T>=L&&(W=new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}),W.decode(),T=e),W.decode(w().subarray(t,t+e))}function A(t,e){return t=t>>>0,j(t,e)}var y=null;function V(){return(y===null||y.byteLength===0)&&(y=new Uint8ClampedArray(o.memory.buffer)),y}function q(t,e){return t=t>>>0,V().subarray(t/1,t/1+e)}var l=0,h=new TextEncoder;"encodeInto"in h||(h.encodeInto=function(t,e){let n=h.encode(t);return e.set(n),{read:t.length,written:n.length}});function f(t,e,n){if(n===void 0){let a=h.encode(t),_=e(a.length,1)>>>0;return w().subarray(_,_+a.length).set(a),l=a.length,_}let r=t.length,i=e(r,1)>>>0,c=w(),s=0;for(;s<r;s++){let a=t.charCodeAt(s);if(a>127)break;c[i+s]=a}if(s!==r){s!==0&&(t=t.slice(s)),i=n(i,r,r=s+t.length*3,1)>>>0;let a=w().subarray(i+s,i+r),_=h.encodeInto(t,a);s+=_.written,i=n(i,r,s,1)>>>0}return l=s,i}var d=null;function u(){return(d===null||d.buffer.detached===!0||d.buffer.detached===void 0&&d.buffer!==o.memory.buffer)&&(d=new DataView(o.memory.buffer)),d}function E(t){return t==null}function k(t){let e=o.__wbindgen_export_2.get(t);return o.__externref_table_dealloc(t),e}function G(t,e){return t=t>>>0,w().subarray(t/1,t/1+e)}function N(t,e){let n=e(t.length*1,1)>>>0;return w().set(t,n/1),l=t.length,n}var U=typeof FinalizationRegistry=="undefined"?{register:()=>{},unregister:()=>{}}:new FinalizationRegistry(t=>o.__wbg_compiler_free(t>>>0,1)),p=class{__destroy_into_raw(){let e=this.__wbg_ptr;return this.__wbg_ptr=0,U.unregister(this),e}free(){let e=this.__destroy_into_raw();o.__wbg_compiler_free(e,0)}constructor(e,n){let r=f(e,o.__wbindgen_malloc,o.__wbindgen_realloc),i=l,c=o.compiler_new(r,i,n);return this.__wbg_ptr=c>>>0,U.register(this,this.__wbg_ptr,this),this}compile_image(e,n,r,i,c,s){let a=f(e,o.__wbindgen_malloc,o.__wbindgen_realloc),_=l,C=f(n,o.__wbindgen_malloc,o.__wbindgen_realloc),M=l,b=f(i,o.__wbindgen_malloc,o.__wbindgen_realloc),F=l,x=o.compiler_compile_image(this.__wbg_ptr,a,_,C,M,r,b,F,c,s);if(x[2])throw k(x[1]);return k(x[0])}compile_svg(e,n){let r,i;try{let a=f(e,o.__wbindgen_malloc,o.__wbindgen_realloc),_=l,C=f(n,o.__wbindgen_malloc,o.__wbindgen_realloc),M=l,b=o.compiler_compile_svg(this.__wbg_ptr,a,_,C,M);var c=b[0],s=b[1];if(b[3])throw c=0,s=0,k(b[2]);return r=c,i=s,A(c,s)}finally{o.__wbindgen_free(r,i,1)}}compile_pdf(e,n){let r=f(e,o.__wbindgen_malloc,o.__wbindgen_realloc),i=l,c=f(n,o.__wbindgen_malloc,o.__wbindgen_realloc),s=l,a=o.compiler_compile_pdf(this.__wbg_ptr,r,i,c,s);if(a[3])throw k(a[2]);var _=G(a[0],a[1]).slice();return o.__wbindgen_free(a[0],a[1]*1,1),_}add_font(e){let n=N(e,o.__wbindgen_malloc),r=l;o.compiler_add_font(this.__wbg_ptr,n,r)}};Symbol.dispose&&(p.prototype[Symbol.dispose]=p.prototype.free);var X=new Set(["basic","cors","default"]);async function Y(t,e){if(typeof Response=="function"&&t instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(t,e)}catch(r){if(t.ok&&X.has(t.type)&&t.headers.get("Content-Type")!=="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n",r);else throw r}let n=await t.arrayBuffer();return await WebAssembly.instantiate(n,e)}else{let n=await WebAssembly.instantiate(t,e);return n instanceof WebAssembly.Instance?{instance:n,module:t}:n}}function H(){let t={};return t.wbg={},t.wbg.__wbg_call_a5400b25a865cfd8=function(){return D(function(e,n,r){return e.call(n,r)},arguments)},t.wbg.__wbg_error_7534b8e9a36f1ab4=function(e,n){let r,i;try{r=e,i=n,console.error(A(e,n))}finally{o.__wbindgen_free(r,i,1)}},t.wbg.__wbg_getTime_6bb3f64e0f18f817=function(e){return e.getTime()},t.wbg.__wbg_getTimezoneOffset_1e3ddc1382e7c8b0=function(e){return e.getTimezoneOffset()},t.wbg.__wbg_new0_b0a0a38c201e6df5=function(){return new Date},t.wbg.__wbg_new_5a2ae4557f92b50e=function(e){return new Date(e)},t.wbg.__wbg_new_8a6f238a6ece86ea=function(){return new Error},t.wbg.__wbg_newwithu8clampedarrayandsh_132382d049b78e28=function(){return D(function(e,n,r,i){return new ImageData(q(e,n),r>>>0,i>>>0)},arguments)},t.wbg.__wbg_stack_0ed75d68575b0f3c=function(e,n){let r=n.stack,i=f(r,o.__wbindgen_malloc,o.__wbindgen_realloc),c=l;u().setInt32(e+4*1,c,!0),u().setInt32(e+4*0,i,!0)},t.wbg.__wbg_wbindgennumberget_f74b4c7525ac05cb=function(e,n){let r=n,i=typeof r=="number"?r:void 0;u().setFloat64(e+8*1,E(i)?0:i,!0),u().setInt32(e+4*0,!E(i),!0)},t.wbg.__wbg_wbindgenstringget_0f16a6ddddef376f=function(e,n){let r=n,i=typeof r=="string"?r:void 0;var c=E(i)?0:f(i,o.__wbindgen_malloc,o.__wbindgen_realloc),s=l;u().setInt32(e+4*1,s,!0),u().setInt32(e+4*0,c,!0)},t.wbg.__wbg_wbindgenthrow_451ec1a8469d7eb6=function(e,n){throw new Error(A(e,n))},t.wbg.__wbindgen_cast_2241b6af4c4b2941=function(e,n){return A(e,n)},t.wbg.__wbindgen_cast_d6cd19b81560fd6e=function(e){return e},t.wbg.__wbindgen_init_externref_table=function(){let e=o.__wbindgen_export_2,n=e.grow(4);e.set(0,void 0),e.set(n+0,void 0),e.set(n+1,null),e.set(n+2,!0),e.set(n+3,!1)},t}function J(t,e){return o=t.exports,R.__wbindgen_wasm_module=e,d=null,m=null,y=null,o.__wbindgen_start(),o}async function R(t){if(o!==void 0)return o;typeof t!="undefined"&&(Object.getPrototypeOf(t)===Object.prototype?{module_or_path:t}=t:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof t=="undefined"&&(t=new URL("obsidian_typst_bg.wasm",Q.url));let e=H();(typeof t=="string"||typeof Request=="function"&&t instanceof Request||typeof URL=="function"&&t instanceof URL)&&(t=fetch(t));let{instance:n,module:r}=await Y(await t,e);return J(n,r)}var P=R;var z=!1,Z=new TextDecoder,v,I,O=[],S=new XMLHttpRequest;function $(t){try{if(!z){if(t.startsWith("@")){if(O.includes(t.slice(1)))return I+t.slice(1);throw 2}t="http://localhost/_capacitor_file_"+v+"/"+t,S.open("GET",t,!1);try{S.send()}catch(r){throw console.error(r),3}if(S.status==404)throw 2;return S.responseText}let e=new Int32Array(new SharedArrayBuffer(4,{maxByteLength:1e8}));e[0]=0,postMessage({buffer:e,path:t});let n=Atomics.wait(e,0,0);if(e[0]==0)return Z.decode(Uint8Array.from(e.slice(1)));throw e[0]}catch(e){throw typeof e!="number"?(console.error(e),1):e}}var g;onmessage=t=>{console.log("\\u{1F7E3} Worker: Received message:",t.data.type);let e=t.data;switch(e.type){case"canUseSharedArrayBuffer":console.log("\\u{1F7E3} Worker: Setting canUseSharedArrayBuffer to:",e.data),z=e.data;break;case"startup":console.log("\\u{1F7E3} Worker: Starting typst initialization"),P(e.data.wasm).then(n=>{console.log("\\u{1F7E3} Worker: typst initialized, creating compiler"),g=new p("",$),console.log("Typst web assembly loaded!"),console.log("\\u{1F7E3} Worker: Sending ready signal"),postMessage({type:"ready"})}).catch(n=>{console.error("\\u{1F534} Worker: typst initialization failed:",n),postMessage({type:"error",error:n.toString()})}),v=e.data.basePath,I=e.data.packagePath,console.log("\\u{1F7E3} Worker: Set basePath:",v,"packagePath:",I);break;case"fonts":if(console.log("\\u{1F7E3} Worker: Adding fonts, count:",e.data.length),!g){console.warn("\\u{1F7E1} Worker: Compiler not initialized yet, cannot add fonts");break}e.data.forEach(n=>g.add_font(new Uint8Array(n)));break;case"compile":if(console.log("\\u{1F7E3} Worker: Compile request, format:",e.data.format),!g){console.error("\\u{1F534} Worker: Compiler not initialized!"),postMessage({error:"Compiler not initialized"});return}try{if(e.data.format=="image"){console.log("\\u{1F7E3} Worker: Compiling to image");let n=e.data,r=g.compile_image(n.source,n.path,n.pixel_per_pt,n.fill,n.size,n.display);console.log("\\u{1F7E3} Worker: Image compilation complete, posting result"),postMessage(r)}else if(e.data.format=="svg"){console.log("\\u{1F7E3} Worker: Compiling to SVG");let n=g.compile_svg(e.data.source,e.data.path);console.log("\\u{1F7E3} Worker: SVG compilation complete, posting result"),postMessage(n)}else if(e.data.format=="pdf"){console.log("\\u{1F7E3} Worker: Compiling to PDF");let n=e.data,r=g.compile_pdf(n.source,n.path);console.log("\\u{1F7E3} Worker: PDF compilation complete, posting result"),postMessage(r)}}catch(n){console.error("\\u{1F534} Worker: Compilation failed:",n),postMessage({error:n.toString()})}break;case"packages":console.log("\\u{1F7E3} Worker: Setting packages, count:",e.data.length),O=e.data;break;default:throw console.error("\\u{1F534} Worker: Unknown message type:",e),e}};console.log("Typst compiler worker loaded!");\n']);
  let url = URL.createObjectURL(blob);
  let worker = new Worker(url);
  URL.revokeObjectURL(url);
  return worker;
}

// src/main.ts
var import_js_untar2 = __toESM(require_untar());

// node_modules/fflate/esm/browser.js
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a2 = freb(fleb, 2);
var fl = _a2.b;
var revfl = _a2.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a) {
  var m = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err2 = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err2);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t2 = s + l;
        if (t2 > sl) {
          if (noSt)
            err2(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t2), bt);
        st.b = bt += l, st.p = pos = t2 * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err2(1);
      if (pos > tbts) {
        if (noSt)
          err2(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err2(0);
        break;
      }
      if (!c)
        err2(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err2(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err2(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err2(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err2(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err2(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err2(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
};
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err2(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}

// src/main.ts
var TypstForObsidian = class extends import_obsidian8.Plugin {
  async onload() {
    console.log("\u{1F535} TypstForObsidian: Loading Typst Renderer");
    this.textEncoder = new TextEncoder();
    await this.loadSettings();
    this.pluginPath = this.app.vault.configDir + "/plugins/typst-for-obsidian/";
    this.packagePath = this.pluginPath + "packages/";
    this.wasmPath = this.pluginPath + "obsidian_typst_bg.wasm";
    console.log("\u{1F535} TypstForObsidian: Creating compiler worker");
    this.compilerWorker = new inlineWorker();
    if (!await this.app.vault.adapter.exists(this.wasmPath)) {
      new import_obsidian8.Notice(
        "Typst Renderer: Downloading required web assembly component!",
        5e3
      );
      try {
        await this.fetchWasm();
        new import_obsidian8.Notice("Typst Renderer: Web assembly component downloaded!", 5e3);
      } catch (error) {
        new import_obsidian8.Notice("Typst Renderer: Failed to fetch component: " + error, 0);
        console.error("Typst Renderer: Failed to fetch component: " + error);
      }
    }
    console.log("\u{1F535} TypstForObsidian: Posting startup message to worker");
    this.compilerWorker.postMessage({
      type: "startup",
      data: {
        wasm: URL.createObjectURL(
          new Blob([await this.app.vault.adapter.readBinary(this.wasmPath)], {
            type: "application/wasm"
          })
        ),
        // @ts-ignore
        basePath: this.app.vault.adapter.basePath,
        packagePath: this.packagePath
      }
    });
    if (import_obsidian8.Platform.isDesktopApp) {
      console.log(
        "\u{1F535} TypstForObsidian: Desktop app, enabling SharedArrayBuffer"
      );
      this.compilerWorker.postMessage({
        type: "canUseSharedArrayBuffer",
        data: true
      });
      this.fs = require("fs");
      this.compilerWorker.addEventListener("message", (event) => {
        var _a3;
        if (((_a3 = event.data) == null ? void 0 : _a3.type) === "ready") {
          this.loadFonts();
        }
      });
    } else {
      await this.app.vault.adapter.mkdir(this.packagePath);
      const packages = await this.getPackageList();
      this.compilerWorker.postMessage({ type: "packages", data: packages });
    }
    (0, import_obsidian8.addIcon)("typst-file", TypstIcon);
    this.packageManager = new PackageManager(this.app);
    this.registerExtensions(["typ"], "typst-view");
    this.registerView("typst-view", (leaf) => new TypstView(leaf, this));
    registerCommands(this);
    this.addSettingTab(new TypstSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("css-change", () => {
        this.onThemeChange();
      })
    );
    console.log("\u{1F535} TypstForObsidian: onload() completed successfully");
  }
  async loadFonts() {
    console.log("\u{1F535} TypstForObsidian: Loading system fonts");
    try {
      let fonts = await Promise.all(
        //@ts-expect-error
        (await window.queryLocalFonts()).filter(
          (font) => this.settings.fontFamilies.includes(font.family.toLowerCase())
        ).map(
          async (font) => await (await font.blob()).arrayBuffer()
        )
      );
      console.log(`\u{1F535} TypstForObsidian: Loaded ${fonts.length} fonts`);
      this.compilerWorker.postMessage({ type: "fonts", data: fonts }, fonts);
    } catch (error) {
      console.warn("\u{1F7E1} TypstForObsidian: Could not load system fonts:", error);
    }
  }
  onThemeChange() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof TypstView) {
        const typstView = leaf.view;
        typstView.recompileIfInReadingMode();
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async fetchWasm() {
    try {
      const wasmSourcePath = this.pluginPath + "pkg/obsidian_typst_bg.wasm";
      const wasmData = await this.app.vault.adapter.readBinary(wasmSourcePath);
      await this.app.vault.adapter.mkdir(this.pluginPath);
      await this.app.vault.adapter.writeBinary(this.wasmPath, wasmData);
    } catch (error) {
      console.error("Failed to fetch WASM:", error);
      throw error;
    }
  }
  async getPackageList() {
    const packages = [];
    try {
      if (await this.app.vault.adapter.exists(this.packagePath)) {
        const entries = await this.app.vault.adapter.list(this.packagePath);
        for (const entry of entries.folders) {
          packages.push(entry.split("/").slice(-3).join("/"));
        }
      }
    } catch (error) {
      console.error("Failed to get package list:", error);
    }
    return packages;
  }
  // Enhanced compilation method that handles WorkerRequests
  async compileToSvg(source, path2 = "/main.typ") {
    console.log("\u{1F536} Main: compileToSvg called");
    let finalSource = source;
    if (this.settings.useDefaultLayoutFunctions) {
      finalSource = this.settings.customLayoutFunctions + "\n" + source;
    }
    finalSource = finalSource + "#linebreak()\n#linebreak()";
    console.log(finalSource);
    finalSource = finalSource.replace(
      /%THEMECOLOR%/g,
      this.getThemeTextColor()
    );
    finalSource = finalSource.replace(/%FONTSIZE%/g, this.getCssFontSize());
    finalSource = finalSource.replace(/%ACCENTCOLOR%/g, this.getAccentColor());
    finalSource = finalSource.replace(/%FAINTCOLOR%/g, this.getFaintColor());
    finalSource = finalSource.replace(/%MUTEDCOLOR%/g, this.getMutedColor());
    finalSource = finalSource.replace(/%BGCOLOR%/g, this.getThemeBGColor());
    finalSource = finalSource.replace(
      /%BGPRIMARY%/g,
      this.getBackgroundPrimary()
    );
    finalSource = finalSource.replace(
      /%BGPRIMARYALT%/g,
      this.getBackgroundPrimaryAlt()
    );
    finalSource = finalSource.replace(
      /%BGSECONDARY%/g,
      this.getBackgroundSecondary()
    );
    finalSource = finalSource.replace(
      /%BGSECONDARYALT%/g,
      this.getBackgroundSecondaryAlt()
    );
    finalSource = finalSource.replace(
      /%SUCCESSCOLOR%/g,
      this.getSuccessColor()
    );
    finalSource = finalSource.replace(
      /%WARNINGCOLOR%/g,
      this.getWarningColor()
    );
    finalSource = finalSource.replace(/%ERRORCOLOR%/g, this.getErrorColor());
    finalSource = finalSource.replace(
      /%HEADINGCOLOR%/g,
      this.getHeadingColor()
    );
    finalSource = finalSource.replace(/%FONTTEXT%/g, this.getFontText());
    finalSource = finalSource.replace(/%FONTMONO%/g, this.getFontMonospace());
    finalSource = finalSource.replace(/%BORDERWIDTH%/g, this.getBorderWidth());
    console.log(
      "\u{1F536} Main: Applied layout functions, theme color, and font size"
    );
    const message = {
      type: "compile",
      data: {
        format: "svg",
        path: path2,
        source: finalSource
      }
    };
    console.log("\u{1F536} Main: Posting SVG compile message to worker");
    this.compilerWorker.postMessage(message);
    while (true) {
      const result = await new Promise((resolve, reject) => {
        const listener = (ev) => {
          if (ev.data && ev.data.type === "ready") {
            console.log("\u{1F536} Main: Ignoring ready signal");
            return;
          }
          remove();
          resolve(ev.data);
        };
        const errorListener = (error) => {
          console.error("\u{1F534} Main: Worker error during compile:", error);
          remove();
          reject(error);
        };
        const remove = () => {
          this.compilerWorker.removeEventListener("message", listener);
          this.compilerWorker.removeEventListener("error", errorListener);
        };
        this.compilerWorker.addEventListener("message", listener);
        this.compilerWorker.addEventListener("error", errorListener);
      });
      if (typeof result === "string") {
        console.log("\u{1F536} Main: Got SVG string result, optimizing for display");
        const processedSvg = this.quantizeSVG(result, 0.05);
        return processedSvg;
      } else if (result && result.error) {
        throw new Error(result.error);
      } else if (result && result.buffer && result.path) {
        console.log("\u{1F536} Main: Got WorkerRequest for path:", result.path);
        await this.handleWorkerRequest(result);
        continue;
      } else {
        console.error("\u{1F534} Main: Unexpected response format:", result);
        throw new Error("Invalid response format");
      }
    }
  }
  // Enhanced compilation method for PDF that mirrors compileToSvg
  async compileToPdf(source, path2 = "/main.typ") {
    console.log("\u{1F536} Main: compileToPdf called");
    let finalSource = source;
    if (this.settings.useDefaultLayoutFunctions) {
      finalSource = this.settings.customLayoutFunctions + "\n" + source;
    } else {
      finalSource = "#set page: (margin: (x: 0.25em, y: 0.25em));" + source;
    }
    finalSource = finalSource + "#linebreak()\n#linebreak()";
    finalSource = finalSource.replace(
      /%THEMECOLOR%/g,
      this.getThemeTextColor()
    );
    finalSource = finalSource.replace(/%FONTSIZE%/g, this.getCssFontSize());
    finalSource = finalSource.replace(/%BGCOLOR%/g, this.getThemeBGColor());
    finalSource = finalSource.replace(
      /%LINEWIDTH%/g,
      this.pxToPt(this.getFileLineWidth())
    );
    finalSource = finalSource.replace(/%ACCENTCOLOR%/g, this.getAccentColor());
    finalSource = finalSource.replace(/%FAINTCOLOR%/g, this.getFaintColor());
    finalSource = finalSource.replace(/%MUTEDCOLOR%/g, this.getMutedColor());
    finalSource = finalSource.replace(
      /%BGPRIMARY%/g,
      this.getBackgroundPrimary()
    );
    finalSource = finalSource.replace(
      /%BGPRIMARYALT%/g,
      this.getBackgroundPrimaryAlt()
    );
    finalSource = finalSource.replace(
      /%BGSECONDARY%/g,
      this.getBackgroundSecondary()
    );
    finalSource = finalSource.replace(
      /%BGSECONDARYALT%/g,
      this.getBackgroundSecondaryAlt()
    );
    finalSource = finalSource.replace(
      /%SUCCESSCOLOR%/g,
      this.getSuccessColor()
    );
    finalSource = finalSource.replace(
      /%WARNINGCOLOR%/g,
      this.getWarningColor()
    );
    finalSource = finalSource.replace(/%ERRORCOLOR%/g, this.getErrorColor());
    finalSource = finalSource.replace(
      /%HEADINGCOLOR%/g,
      this.getHeadingColor()
    );
    finalSource = finalSource.replace(/%FONTTEXT%/g, this.getFontText());
    finalSource = finalSource.replace(/%FONTMONO%/g, this.getFontMonospace());
    finalSource = finalSource.replace(/%BORDERWIDTH%/g, this.getBorderWidth());
    console.log(
      "\u{1F536} Main: Applied layout functions, theme color, and font size for PDF"
    );
    const message = {
      type: "compile",
      data: {
        format: "pdf",
        path: path2,
        source: finalSource
      }
    };
    console.log("\u{1F536} Main: Posting PDF compile message to worker");
    this.compilerWorker.postMessage(message);
    while (true) {
      const result = await new Promise((resolve, reject) => {
        const listener = (ev) => {
          if (ev.data && ev.data.type === "ready") {
            console.log("\u{1F536} Main: Ignoring ready signal");
            return;
          }
          remove();
          resolve(ev.data);
        };
        const errorListener = (error) => {
          console.error("\u{1F534} Main: Worker error during PDF compile:", error);
          remove();
          reject(error);
        };
        const remove = () => {
          this.compilerWorker.removeEventListener("message", listener);
          this.compilerWorker.removeEventListener("error", errorListener);
        };
        this.compilerWorker.addEventListener("message", listener);
        this.compilerWorker.addEventListener("error", errorListener);
      });
      if (result instanceof Uint8Array || result && result.constructor && result.constructor.name === "Uint8Array") {
        console.log("\u{1F536} Main: Got PDF bytes result");
        return result;
      } else if (result && result.error) {
        throw new Error(result.error);
      } else if (result && result.buffer && result.path) {
        console.log("\u{1F536} Main: Got WorkerRequest for path:", result.path);
        await this.handleWorkerRequest(result);
        continue;
      } else {
        console.error("\u{1F534} Main: Unexpected PDF response format:", result);
        throw new Error("Invalid PDF response format");
      }
    }
  }
  pxToPt(px) {
    const pxValue = parseFloat(px.replace("px", ""));
    const ptValue = pxValue / 1.5;
    console.log(
      `\u{1F50D} Main: Converting ${px} \u2192 ${pxValue}px \u2192 ${ptValue}pt (for 1.5 scale)`
    );
    return `${ptValue}`;
  }
  quantizeSVG(svg, precision = 0.05) {
    const numberRegex = /-?\d+\.?\d*(?:[eE][+-]?\d+)?/g;
    const quantize = (num) => {
      var _a3;
      const value = parseFloat(num);
      if (isNaN(value))
        return num;
      return (Math.round(value / precision) * precision).toFixed(
        precision >= 1 ? 0 : ((_a3 = precision.toString().split(".")[1]) == null ? void 0 : _a3.length) || 0
      );
    };
    const coordAttrs = [
      "x",
      "y",
      "x1",
      "y1",
      "x2",
      "y2",
      "cx",
      "cy",
      "r",
      "rx",
      "ry",
      "width",
      "height",
      "dx",
      "dy",
      "offset"
    ];
    const attrPattern = coordAttrs.join("|");
    const attrRegex = new RegExp(`(${attrPattern})=["']([^"']+)["']`, "g");
    let result = svg.replace(attrRegex, (match, attr, value) => {
      const quantized = value.replace(numberRegex, quantize);
      return `${attr}="${quantized}"`;
    });
    result = result.replace(/\bd=["']([^"']+)["']/g, (match, pathData) => {
      const quantized = pathData.replace(numberRegex, quantize);
      return `d="${quantized}"`;
    });
    result = result.replace(/\bpoints=["']([^"']+)["']/g, (match, points) => {
      const quantized = points.replace(numberRegex, quantize);
      return `points="${quantized}"`;
    });
    result = result.replace(
      /\btransform=["']([^"']+)["']/g,
      (match, transform) => {
        const quantized = transform.replace(numberRegex, quantize);
        return `transform="${quantized}"`;
      }
    );
    result = result.replace(/\bstyle=["']([^"']+)["']/g, (match, style) => {
      const quantized = style.replace(
        /(stroke-width|font-size):\s*(-?\d+\.?\d*)/g,
        (m, prop, val) => `${prop}: ${quantize(val)}`
      );
      return `style="${quantized}"`;
    });
    return result;
  }
  cssColorToHex(color) {
    if (color.startsWith("#")) {
      return color.slice(1);
    }
    const rgbMatch = color.match(
      /rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/
    );
    if (rgbMatch) {
      const r = parseInt(rgbMatch[1]);
      const g = parseInt(rgbMatch[2]);
      const b = parseInt(rgbMatch[3]);
      const toHex = (n) => {
        const hex = n.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      };
      return toHex(r) + toHex(g) + toHex(b);
    }
    const hslMatch = color.match(
      /hsla?\((\d+),\s*(\d+)%,\s*(\d+)%(?:,\s*[\d.]+)?\)/
    );
    if (hslMatch) {
      const h = parseInt(hslMatch[1]) / 360;
      const s = parseInt(hslMatch[2]) / 100;
      const l = parseInt(hslMatch[3]) / 100;
      const hslToRgb = (h2, s2, l2) => {
        let r, g, b;
        if (s2 === 0) {
          r = g = b = l2;
        } else {
          const hue2rgb = (p2, q2, t2) => {
            if (t2 < 0)
              t2 += 1;
            if (t2 > 1)
              t2 -= 1;
            if (t2 < 1 / 6)
              return p2 + (q2 - p2) * 6 * t2;
            if (t2 < 1 / 2)
              return q2;
            if (t2 < 2 / 3)
              return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
            return p2;
          };
          const q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
          const p = 2 * l2 - q;
          r = hue2rgb(p, q, h2 + 1 / 3);
          g = hue2rgb(p, q, h2);
          b = hue2rgb(p, q, h2 - 1 / 3);
        }
        const toHex = (x) => {
          const hex = Math.round(x * 255).toString(16);
          return hex.length === 1 ? "0" + hex : hex;
        };
        return toHex(r) + toHex(g) + toHex(b);
      };
      return hslToRgb(h, s, l);
    }
    try {
      const tempEl = document.createElement("div");
      tempEl.style.color = color;
      document.body.appendChild(tempEl);
      const computed = getComputedStyle(tempEl).color;
      document.body.removeChild(tempEl);
      return this.cssColorToHex(computed);
    } catch (e) {
      console.warn("Failed to convert color:", color, e);
      return "ffffff";
    }
  }
  getThemeTextColor() {
    const bodyStyle = getComputedStyle(document.body);
    const textColor = bodyStyle.getPropertyValue("--text-normal").trim();
    if (textColor) {
      return this.cssColorToHex(textColor);
    }
    return "ffffff";
  }
  getCssFontSize() {
    const bodyStyle = getComputedStyle(document.body);
    const fontSize = bodyStyle.getPropertyValue("--font-text-size").trim();
    if (fontSize) {
      const pxValue = parseFloat(fontSize.replace("px", ""));
      const ptValue = pxValue * 0.75;
      console.log(`\u{1F536} Main: Converted font size ${fontSize} to ${ptValue}pt`);
      return `${ptValue}pt`;
    }
    console.log("\u{1F536} Main: Could not determine font size, using fallback");
    return "16pt";
  }
  getThemeBGColor() {
    const bodyStyle = getComputedStyle(document.body);
    const bgColor = bodyStyle.getPropertyValue("--background-primary").trim();
    if (bgColor) {
      return this.cssColorToHex(bgColor);
    }
    return "ffffff";
  }
  getFileLineWidth() {
    const bodyStyle = getComputedStyle(document.body);
    const fileLineWidth = bodyStyle.getPropertyValue("--file-line-width").trim();
    console.log("\u{1F50D} Main: --file-line-width CSS variable:", fileLineWidth);
    if (fileLineWidth) {
      return fileLineWidth;
    }
    console.log("\u{1F50D} Main: Using fallback width: 700");
    return "700";
  }
  getCssVariable(variableName, fallback = "000000") {
    const bodyStyle = getComputedStyle(document.body);
    const value = bodyStyle.getPropertyValue(variableName).trim();
    if (value) {
      if (variableName.includes("color") || variableName.includes("background") || variableName.includes("text-")) {
        return this.cssColorToHex(value);
      }
      return value;
    }
    return fallback;
  }
  // Color getters
  getAccentColor() {
    return this.getCssVariable("--text-accent", "ffffff");
  }
  getFaintColor() {
    return this.getCssVariable("--text-faint", "888888");
  }
  getMutedColor() {
    return this.getCssVariable("--text-muted", "999999");
  }
  getBackgroundPrimary() {
    return this.getCssVariable("--background-primary", "ffffff");
  }
  getBackgroundPrimaryAlt() {
    return this.getCssVariable("--background-primary-alt", "f5f5f5");
  }
  getBackgroundSecondary() {
    return this.getCssVariable("--background-secondary", "f0f0f0");
  }
  getBackgroundSecondaryAlt() {
    return this.getCssVariable("--background-secondary-alt", "e8e8e8");
  }
  getSuccessColor() {
    return this.getCssVariable("--text-success", "00ff00");
  }
  getWarningColor() {
    return this.getCssVariable("--text-warning", "ffaa00");
  }
  getErrorColor() {
    return this.getCssVariable("--text-error", "ff0000");
  }
  // Font getters
  getFontText() {
    const bodyStyle = getComputedStyle(document.body);
    const fontText = bodyStyle.getPropertyValue("--font-text").trim();
    return fontText || "sans-serif";
  }
  getFontMonospace() {
    const bodyStyle = getComputedStyle(document.body);
    const fontMono = bodyStyle.getPropertyValue("--font-monospace").trim();
    return fontMono || "monospace";
  }
  // Border width
  getBorderWidth() {
    const bodyStyle = getComputedStyle(document.body);
    const borderWidth = bodyStyle.getPropertyValue("--border-width").trim();
    return borderWidth || "1px";
  }
  // Heading color - typically same as text color but can be customized
  getHeadingColor() {
    const bodyStyle = getComputedStyle(document.body);
    const headingColor = bodyStyle.getPropertyValue("--text-heading").trim() || bodyStyle.getPropertyValue("--text-normal").trim();
    if (headingColor) {
      return this.cssColorToHex(headingColor);
    }
    return this.getThemeTextColor();
  }
  async handleWorkerRequest({ buffer: wbuffer, path: path2 }) {
    console.log("\u{1F536} Main: Handling worker request for path:", path2);
    try {
      const text = await (path2.startsWith("@") ? this.preparePackage(path2.slice(1)) : this.getFileString(path2));
      if (text) {
        let buffer = Int32Array.from(this.textEncoder.encode(text));
        if (wbuffer.byteLength < buffer.byteLength + 4) {
          wbuffer.buffer.grow(buffer.byteLength + 4);
        }
        wbuffer.set(buffer, 1);
        wbuffer[0] = 0;
      }
    } catch (error) {
      if (typeof error === "number") {
        wbuffer[0] = error;
      } else {
        wbuffer[0] = 1;
        console.error(error);
      }
    } finally {
      Atomics.notify(wbuffer, 0);
    }
  }
  async preparePackage(spec) {
    console.log("\u{1F536} Main: Preparing package:", spec);
    if (import_obsidian8.Platform.isDesktopApp) {
      let subdir = "/typst/packages/" + spec;
      let dir = require("path").normalize(this.getDataDir() + subdir);
      if (this.fs.existsSync(dir)) {
        console.log("\u{1F536} Main: Found package in data directory:", dir);
        return dir;
      }
      dir = require("path").normalize(this.getCacheDir() + subdir);
      if (this.fs.existsSync(dir)) {
        console.log("\u{1F536} Main: Found package in cache directory:", dir);
        return dir;
      }
    }
    const folder = this.packagePath + spec + "/";
    if (await this.app.vault.adapter.exists(folder)) {
      console.log("\u{1F536} Main: Package exists locally in plugin directory");
      return folder;
    }
    if (spec.startsWith("preview") && this.settings.autoDownloadPackages) {
      console.log("\u{1F536} Main: Downloading preview package:", spec);
      const [namespace, name, version2] = spec.split("/");
      try {
        await this.fetchPackage(folder, name, version2);
        return folder;
      } catch (e) {
        if (e == 2) {
          throw e;
        }
        console.error(e);
        throw 3;
      }
    }
    throw 2;
  }
  getDataDir() {
    if (import_obsidian8.Platform.isLinux) {
      if ("XDG_DATA_HOME" in process.env) {
        return process.env["XDG_DATA_HOME"];
      } else {
        return process.env["HOME"] + "/.local/share";
      }
    } else if (import_obsidian8.Platform.isWin) {
      return process.env["APPDATA"];
    } else if (import_obsidian8.Platform.isMacOS) {
      return process.env["HOME"] + "/Library/Application Support";
    }
    throw "Cannot find data directory on an unknown platform";
  }
  getCacheDir() {
    if (import_obsidian8.Platform.isLinux) {
      if ("XDG_CACHE_HOME" in process.env) {
        return process.env["XDG_CACHE_HOME"];
      } else {
        return process.env["HOME"] + "/.cache";
      }
    } else if (import_obsidian8.Platform.isWin) {
      return process.env["LOCALAPPDATA"];
    } else if (import_obsidian8.Platform.isMacOS) {
      return process.env["HOME"] + "/Library/Caches";
    }
    throw "Cannot find cache directory on an unknown platform";
  }
  async fetchPackage(folder, name, version2) {
    console.log("\u{1F536} Main: Fetching package:", name, version2);
    const url = `https://packages.typst.org/preview/${name}-${version2}.tar.gz`;
    const response = await fetch(url);
    if (response.status == 404) {
      throw 2;
    }
    await this.app.vault.adapter.mkdir(folder);
    const decompressed = decompressSync(
      new Uint8Array(await response.arrayBuffer())
    );
    const untarrer = (0, import_js_untar2.default)(decompressed.buffer);
    await untarrer.progress(async (file) => {
      if (file.type == "5" && file.name != ".") {
        await this.app.vault.adapter.mkdir(folder + file.name);
      }
      if (file.type === "0") {
        await this.app.vault.adapter.writeBinary(
          folder + file.name,
          file.buffer
        );
      }
    });
    console.log("\u{1F536} Main: Package downloaded successfully");
  }
  async getFileString(path2) {
    try {
      if (require("path").isAbsolute(path2)) {
        return await this.fs.promises.readFile(path2, { encoding: "utf8" });
      } else {
        return await this.app.vault.adapter.read((0, import_obsidian8.normalizePath)(path2));
      }
    } catch (error) {
      console.error("Failed to read file:", path2, error);
      throw 2;
    }
  }
};
/*! Bundled license information:

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
